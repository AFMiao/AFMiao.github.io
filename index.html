<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>小苗的个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="小苗的个人博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小苗的个人博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="小苗的个人博客"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="小苗的个人博客"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Arnold Miao"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"小苗的个人博客","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Arnold Miao"},"publisher":{"@type":"Organization","name":"小苗的个人博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-28T02:32:59.000Z" title="2022/6/28 10:32:59">2022-06-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-30T01:26:42.999Z" title="2022/6/30 09:26:42">2022-06-30</time></span><span class="level-item">38 minutes read (About 5637 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">算法入门</a></h1><div class="content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="算法与数据结构的重要性"><a href="#算法与数据结构的重要性" class="headerlink" title="算法与数据结构的重要性"></a>算法与数据结构的重要性</h3><h4 id="课程定位与目标人群"><a href="#课程定位与目标人群" class="headerlink" title="课程定位与目标人群"></a>课程定位与目标人群</h4><h4 id="算法与数据结构无处不在"><a href="#算法与数据结构无处不在" class="headerlink" title="算法与数据结构无处不在"></a>算法与数据结构无处不在</h4><p>掌握算法与数据结构的基础知识, 对于编写性能优良、可读性强的工程代码和理解编程语言信息库函数的源代码都很有帮助.</p>
<h4 id="什么是算法与数据结构"><a href="#什么是算法与数据结构" class="headerlink" title="什么是算法与数据结构"></a>什么是算法与数据结构</h4><h5 id="算法是解决问题的方法"><a href="#算法是解决问题的方法" class="headerlink" title="算法是解决问题的方法"></a>算法是解决问题的方法</h5><p>学习算法的目的之一是<strong>高效地</strong>解决问题. 解决这些问题的方式可能是直接使用计算机科学家发明出来的算法与数据结构, 可能是偶尔的灵光一现, 也有可能是对前人思想的改进. 总而言之, 我们需要有一定的只是储备和解决问题的经验.</p>
<h5 id="数据结构是解决问题的过程中使用的容器"><a href="#数据结构是解决问题的过程中使用的容器" class="headerlink" title="数据结构是解决问题的过程中使用的容器"></a>数据结构是解决问题的过程中使用的容器</h5><p>容器是存放数据的地方, 同时容器还提供了一定的处理数据的能力, 协助我们高效地完成任务.</p>
<p>编程领域中的数据结构们都是一些有些抽象的概念, 但是这些数据结构都我们的编程过程中发挥了巨大的现实作用.</p>
<p>我们要介绍一个概念: <strong>数据结构是缓存</strong>.</p>
<h5 id="数据结构是缓存"><a href="#数据结构是缓存" class="headerlink" title="数据结构是缓存"></a>数据结构是缓存</h5><p>在解决问题的时候, 我们通常不是一下子把数据处理完, 而是需要先将它们放在一个容器里, 等到一定的时刻再把它们拿出来. 使用数据结构是一种”空间换时间”思想的体现, 如果我们在恰当的时刻使用了合适的数据结构, 那我们处理数据的效率就能够大幅度提升.</p>
<p>以下是一些常用的数据结构及其应用场所:</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>符合「后进先出」的规律</td>
</tr>
<tr>
<td>队列</td>
<td>符合「先进先出」的规律</td>
</tr>
<tr>
<td>哈希表(散列表)</td>
<td>实现「快速存取」数据的功能</td>
</tr>
<tr>
<td>二分搜索树(红黑树、B 树系列)</td>
<td>维护了一组数据的顺序性, 得到一个数据的上下界</td>
</tr>
<tr>
<td>并查集</td>
<td>用于处理不相交集合的「动态」连接问题</td>
</tr>
<tr>
<td>优先队列</td>
<td>有「动态」添加、删除数据且需要获得最值的场景</td>
</tr>
<tr>
<td>字典树(Tier)</td>
<td>用于保存和统计大量的字符串和相关的信息</td>
</tr>
<tr>
<td>线段树</td>
<td>处理数组的区间信息的汇总（求和、最值等）、单点更新、区间更新问题</td>
</tr>
<tr>
<td>树状数组</td>
<td>处理数组的前缀和、单点更新、区间更新问题</td>
</tr>
</tbody></table>
<p>我们创建这么多数据结构的原因为: <strong>没有完美的数据结构或算法</strong></p>
<h5 id="没有完美的数据结构或算法"><a href="#没有完美的数据结构或算法" class="headerlink" title="没有完美的数据结构或算法"></a>没有完美的数据结构或算法</h5><p>任何算法都是一种交换. 我们没有办法得到所有想要的东西. u低于算法与数据结构来说, 时间性能和空间消耗通常来说是不可能同时最优的: 一个算法和数据结构对于一个任务来说是优点, 但放在另一个场景下就可能是缺点. 在设计算法时, 我们或是用时间换空间, 或是用空间换时间, 或是综合考虑两者, 设计一个折中方案.</p>
<h3 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h3><p>现行评估算法性能好坏的方法有两个, 即<strong>执行时间</strong>和<strong>内存消耗</strong>. 在服务端, 我们更关注的是执行时间, 因为用户一般不会关心程序在服务器端用了多少内存.</p>
<p>在LeetCode提交代码的时候, 会看到提交记录中显示一共有多少测试用例, 又通过了多少测试用例. 这种评估方法被称作<strong>事后评估法</strong>. 这是一种不是很准确的方法, 因为其测试结果受到输入数据的规模、编程语言、执行时系统状况等多方面影响.</p>
<p>我们在现实中更多采用的是<strong>事前评估法</strong>, 即大O复杂度表示法. 与此相关的两个概念是”时间复杂度”和”空间复杂度”.</p>
<p>我们在此暂不给出详细的是时间复杂度和空间复杂度的定义.</p>
<h4 id="动态看待时间复杂度和空间复杂度"><a href="#动态看待时间复杂度和空间复杂度" class="headerlink" title="动态看待时间复杂度和空间复杂度"></a>动态看待时间复杂度和空间复杂度</h4><p>时间复杂度和空间复杂度的前面还有一个词——渐近. 它表示算法在输入数据的规模成倍增长的时候, 相应的时间消耗多增长了多少. 例如Gauss计算从1到100的和, 如果真的从1加到最后一个, 那么从1加到100和从1加到1000000000所需的时间一定是不一样的; 但如果我们使用等差数列求和公式计算, 那么无论n多大, 计算资源的消耗都不会有太大的变动.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个算法执行的操作数与输入规模n线性相关.</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">toSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个算法执行的操作数与n无关</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">toSum2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子较为清晰地展示了<strong>渐近</strong>时间复杂度的含义, 即不关注一两个测试用例的结果, 而是重视输入规模发生成倍增长、数目扩大到很大时, 相应的时间和空间的消耗增加了多少.</p>
<p>我们在上面的代码中并没有具体说”常数次”究竟执行了多少次, 因为这并不重要. 由于几乎任何东西都有可能影响到程序的执行时间, 故计算出准确的函数执行步数没有太大必要; 此外, 复杂的计算也不利于工程师进行交流.</p>
<p>时间复杂度的计算只需要得出一个大概的结果. 估算的意义是:</p>
<ol>
<li>便于不同的算法进行比较;</li>
<li>有利于程序员在编码时进行自我检查和优化.</li>
</ol>
<h4 id="计算时间复杂度和空间复杂度"><a href="#计算时间复杂度和空间复杂度" class="headerlink" title="计算时间复杂度和空间复杂度"></a>计算时间复杂度和空间复杂度</h4><p>需要强调的是, 时间复杂度的计算(估算)只有在输入规模非常大的时候才有意义.</p>
<h4 id="常见的时间复杂度计算规则"><a href="#常见的时间复杂度计算规则" class="headerlink" title="常见的时间复杂度计算规则"></a>常见的时间复杂度计算规则</h4><h5 id="常数加法系数看作0"><a href="#常数加法系数看作0" class="headerlink" title="常数加法系数看作0"></a>常数加法系数看作0</h5><p>一段程序必须要做的操作(常数次操作)不计入复杂度的计算. 一般而言, 常数次操作不会是造成程序性能瓶颈的原因.</p>
<h5 id="对于一个多项式-只保留最高次幂的项-并将乘法系数简化为1"><a href="#对于一个多项式-只保留最高次幂的项-并将乘法系数简化为1" class="headerlink" title="对于一个多项式, 只保留最高次幂的项, 并将乘法系数简化为1"></a>对于一个多项式, 只保留最高次幂的项, 并将乘法系数简化为1</h5><p>常见结论:</p>
<ol>
<li>一次遍历, 里面不再有循环的操作, 时间复杂度为$O(N)$. 也就是说, 我们将输入数据里所有的元素看一遍, 就可以得到结果. 这就是所谓的<strong>具有线性复杂度的算法</strong>.</li>
<li>双重循环, 内外层都与输入规模相关的时候, 时间复杂度是$O(N^2)$.</li>
</ol>
<p>需要注意的是, 有些算法名义上是双重循环, 但事实上, 程序只遍历了数组一次或若干次, 故此类算法的时间复杂度仍然是$O(N)$.</p>
<h5 id="对数或者含有对数乘法银子的项-对数底都看作2"><a href="#对数或者含有对数乘法银子的项-对数底都看作2" class="headerlink" title="对数或者含有对数乘法银子的项, 对数底都看作2"></a>对数或者含有对数乘法银子的项, 对数底都看作2</h5><p>对数级别的时间复杂度, 常见且典型的算法是<strong>二分算法</strong>, 时间复杂度的表达式为$O(\log N)$</p>
<h4 id="绝大多数情况下关注最坏情况"><a href="#绝大多数情况下关注最坏情况" class="headerlink" title="绝大多数情况下关注最坏情况"></a>绝大多数情况下关注最坏情况</h4><p>如果一个程序最坏的情况都是可被接受的, 那么其最好的情况就一定可以被接受. 这就是所谓的”做最好的准备, 做最坏的打算”.</p>
<p>当然, 凡是都有例外: 如果一个程序, 我们采用了一些手段, 导致最坏情况出现的概率大大降低, 那么我们会约定俗称地将时间复杂度定义成”一般情况”.</p>
<h4 id="时间复杂度的数学定义"><a href="#时间复杂度的数学定义" class="headerlink" title="时间复杂度的数学定义"></a>时间复杂度的数学定义</h4><p>在对时间复杂度有了一个感性的认识后, 我们再来看《算法导论》中对时间复杂度的数学定义: $O(G(n))&#x3D;f(n): \exists c, n_0 &gt; 0, \forall n \geqslant n_0, 0 \leqslant f(n) \leqslant cg(n)$.</p>
<p>$O$表示的是一个函数的渐进上界. 说上界, 是因为我们要考虑最坏的情况. 此外, $O$只是一个符号, 不代表任何具体的表达式.</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="二分查找的基本思想-减而治之"><a href="#二分查找的基本思想-减而治之" class="headerlink" title="二分查找的基本思想: 减而治之"></a>二分查找的基本思想: 减而治之</h3><h4 id="何为”减而治之”"><a href="#何为”减而治之”" class="headerlink" title="何为”减而治之”?"></a>何为”减而治之”?</h4><p>略.</p>
<h4 id="二分查找算法的应用范围"><a href="#二分查找算法的应用范围" class="headerlink" title="二分查找算法的应用范围"></a>二分查找算法的应用范围</h4><h5 id="在有序数组中查找一个数-二分下标"><a href="#在有序数组中查找一个数-二分下标" class="headerlink" title="在有序数组中查找一个数(二分下标)"></a>在有序数组中查找一个数(二分下标)</h5><h5 id="在整数范围内查找一个整数-二分答案"><a href="#在整数范围内查找一个整数-二分答案" class="headerlink" title="在整数范围内查找一个整数(二分答案)"></a>在整数范围内查找一个整数(二分答案)</h5><h4 id="二分查找算法的两种思路"><a href="#二分查找算法的两种思路" class="headerlink" title="二分查找算法的两种思路"></a>二分查找算法的两种思路</h4><ol>
<li>在循环体中查找元素(本节介绍)</li>
<li>在循环体中排除目标元素一定不存在的区间(下一节介绍)</li>
</ol>
<h4 id="二分查找的最基本问题"><a href="#二分查找的最基本问题" class="headerlink" title="二分查找的最基本问题"></a>二分查找的最基本问题</h4><p>一个最基本的二分查找问题就是<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">在有序数组中查找目标元素下表的问题</a>. 如果目标存在, 则返回目标下表; 如果不存在, 则返回-1. 我们可以假设数组中的元素不重复.</p>
<p>由于数组是有序且升序的数组, 所以我们在进行二分查找时, 可先看位于数组中间的那个元素的值:</p>
<ol>
<li>如果中间的元素正好等于目标元素, 则直接返回即可;</li>
<li>如果中间元素不等于目标元素, 则根据大小关系在两侧进行查找.</li>
</ol>
<p>我们来看一下示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 目标元素可能存在在区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 推荐的写法是 int mid = left + (right - left) / 2;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 目标元素可能存在在区间 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 目标元素可能存在在区间 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;        &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法能够做到”真正的二分”, 即<code>while</code>循环中只需要做一次判断.</p>
<p>还有一道与这个题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/guess-number-higher-or-lower/">类似的题</a>, 也可以做一做. 我的答案如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">myNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (guess(myNum) != <span class="number">0</span>) &#123;</span><br><span class="line">            myNum = right + (left - right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guess(myNum) == <span class="number">1</span>) &#123;</span><br><span class="line">                left = myNum + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = myNum - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> myNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的, 改进后如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (guess(mid) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找的典型问题-一-二分下标"><a href="#二分查找的典型问题-一-二分下标" class="headerlink" title="二分查找的典型问题(一): 二分下标"></a>二分查找的典型问题(一): 二分下标</h3><p>所谓二分下标, 指的是在一个有序数组(该条件可适当放宽)中查找目标元素的下表. 我们来看两个例子.</p>
<h4 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">该题</a>给定了一个排序数组和目标值, 要求在数组中找到目标值, 并返回其索引; 如果目标值不存在于数组中, 则返回它将会被顺序插入的位置.</p>
<p>我自己的提交如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">这道题</a>要求我们在一个有序的数组中找到和目标元素相等的元素的第一个位置和最后一个位置.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] arr, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrLength</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arrLength == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstPosition</span> <span class="operator">=</span> firstPosition(arr, target);</span><br><span class="line">        <span class="keyword">if</span> (firstPosition == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastPosition</span> <span class="operator">=</span> lastPositon(arr, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;firstPosition, lastPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstPosition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (arr[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastPositon</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要强调的是什么时候使用<code>mid = left + (right - left) / 2</code>(即向下取整), 什么时候又使用<code>mid = left + (right - left + 1) / 2</code>(即向上取整). 有如下结论:</p>
<ol>
<li>向下取整: 配合<code>left = mid + 1</code>, <code>right = mid</code>使用</li>
<li>向上取整: 配合<code>left = mid</code>, <code>right = mid - 1</code>使用</li>
</ol>
<h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">练习一</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他二分法程序不同, 这里虽然使用了向下取整, 但是最后返回的是<code>right</code>.</p>
<h4 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">练习二</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = right - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题最大的特点在于它是一个有可能连续出现相同元素的旋转数组, 故可能会出现取值范围两端元素相等的情况. 如不做调整, 就会在数组两端元素相等、两端元素为数组元素最大元素且数组中间值也为最大数组最大元素时出现返回值为数组最大值的情况.</p>
<p>为了避免这种情况的发生, 我们可以手动去除掉最右侧的元素(反正它也是重复的). 这样就让数组不能满足上述的三个条件, 变为普通的数组.</p>
<h4 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">练习三</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target || nums[left] == target || nums[right] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是左侧升序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[left] &lt; target) &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 如果左侧断序</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; target) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 如果两端相等</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-bad-version/solution/">练习四</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习五-山脉数组的峰顶索引"><a href="#练习五-山脉数组的峰顶索引" class="headerlink" title="练习五: 山脉数组的峰顶索引"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">练习五: 山脉数组的峰顶索引</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; arr[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; arr[mid-<span class="number">1</span>]) &#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; arr[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习六-山脉数组中查找目标值"><a href="#练习六-山脉数组中查找目标值" class="headerlink" title="练习六: 山脉数组中查找目标值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-in-mountain-array/">练习六: 山脉数组中查找目标值</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findInMountainArray</span><span class="params">(<span class="type">int</span> target, MountainArray mountainArr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peak</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(mountainArr, target, <span class="number">0</span>, peak, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(mountainArr, target, peak + <span class="number">1</span>, mountainArr.length() - <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(MountainArray mountainArr, <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            target *= -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> mountainArr.get(mid) * (flag ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题的关键在于: 找山峰, 然后现在左侧查找目标值, 再在右侧寻找目标值.</p>
<h4 id="练习七-寻找两个正序数组的中位数"><a href="#练习七-寻找两个正序数组的中位数" class="headerlink" title="练习七:  寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">练习七:  寻找两个正序数组的中位数</a></h4><h3 id="二分查找的典型问题-二-答案二分"><a href="#二分查找的典型问题-二-答案二分" class="headerlink" title="二分查找的典型问题(二): 答案二分"></a>二分查找的典型问题(二): 答案二分</h3><h4 id="例题一-x-的平方根"><a href="#例题一-x-的平方根" class="headerlink" title="例题一: $x$的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">例题一: $x$的平方根</a></h4><p>使用二分法求平方根的方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种使用Newton迭代解决求根问题的方法. 由于我自己还没有参悟透, 所以就不厚脸皮写在这里了. 各位有兴趣可以去<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/">这里</a>看一下.</p>
<h2 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h4><p>选择排序的原理为: 选取未排定部分的最小元素, 然后将它交换到未排定部分的第一个位置.</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        min = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">                min = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            cache = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = cache;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着这个机会介绍一些编程规范:</p>
<ol>
<li>如果一个问题的输入为数组, 我们则需要将输入数组的长度变成一个变量, 因为输入数组的长度在后面编程的过程中很可能会多次用到.</li>
<li>建议将交换数组中两个元素的方法抽取成一个单独的方法, 因为它不构成程序的主要逻辑.</li>
</ol>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ol>
<li>时间复杂度: $O(N^2)$</li>
<li>空间复杂度: $O(1)$</li>
</ol>
<h4 id="选择排序的特点"><a href="#选择排序的特点" class="headerlink" title="选择排序的特点"></a>选择排序的特点</h4><ol>
<li>交换的次数最少: 如果一个排序任务交换的成本很高, 则可以考虑使用选择排序</li>
<li>运行时间与输入无关: 每次扫描除了比上一次扫描少了一个元素以外并没有其他的区别. 选择排序没有记录更多的信息.</li>
</ol>
<h4 id="选择排序体现的算法思想"><a href="#选择排序体现的算法思想" class="headerlink" title="选择排序体现的算法思想"></a>选择排序体现的算法思想</h4><ol>
<li>贪心算法: 每一轮外层循环, 我们只选出”未排定部分”最小的元素, 这种”局部最优, 则整体最优”的思想叫做<strong>贪心算法</strong>. 我们后面会专门说他.</li>
<li>减而治之: 该算法在二分查找中已经说过了, 不再赘述.</li>
</ol>
<h4 id="选择排序的优化"><a href="#选择排序的优化" class="headerlink" title="选择排序的优化"></a>选择排序的优化</h4><p>选择排序是一个效率不高的算法, 因为其每次循环不为下次循环记录有用的信息. 有一种数据结构能够帮助我们在每次”未排定的部分”里快速选择出当前最小的元素. 这种数据结构就是堆, 而根据其衍生出的堆排序就是选择排序的优化排序算法. 我们将在后面介绍.</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h4><p>插入排序的基本思想就是<strong>将一个元素插入一个有序数组中, 使之称为更长的有序数组</strong>. 具体来说, 我们要从第二个数开始, 一次将这个数插入到它之前已经排好序的部分, 这样每一次都能得到比上一次更长的有序数组, 直到数组整体有序.</p>
<h4 id="将一个元素插入一个有序数组的两种方式"><a href="#将一个元素插入一个有序数组的两种方式" class="headerlink" title="将一个元素插入一个有序数组的两种方式"></a>将一个元素插入一个有序数组的两种方式</h4><p>以<code>[6,5,3,1,8,7,2,4]</code>为例进行讲解.</p>
<h5 id="方法一-逐个交换到前面合适的位置"><a href="#方法一-逐个交换到前面合适的位置" class="headerlink" title="方法一: 逐个交换到前面合适的位置"></a>方法一: 逐个交换到前面合适的位置</h5><p>第一种插入的方式是: <code>1</code>应该放置在下表为<code>0</code>的位置, 通过和它前面的那些元素依次交换, 最终<code>1</code>被交换到下标为<code>0</code>的位置, 然后前四个数字有序.</p>
<p>由于每一次数组里不同元素的交换, 需要进行<code>3</code>次赋值操作. 实际上, 有赋值操作次数更少的方法, 见方式二.</p>
<h5 id="方法二-暂存当前变量-将钱买你的若干元素逐个向后赋值"><a href="#方法二-暂存当前变量-将钱买你的若干元素逐个向后赋值" class="headerlink" title="方法二: 暂存当前变量, 将钱买你的若干元素逐个向后赋值"></a>方法二: 暂存当前变量, 将钱买你的若干元素逐个向后赋值</h5><p>第<code>2</code>种插入的方式是: 先将<code>2</code>赋值给一个临时的变量, 然后将<code>2</code>之前比<code>2</code>严格大的所有元素从后向前依次赋值, 最后一定会空出<code>1</code>个位置出来, 这个空出来的位置就是<code>2</code>应该放置的位置, 我们将<code>2</code>赋值回去.</p>
<h4 id="插入排序的代码实现"><a href="#插入排序的代码实现" class="headerlink" title="插入排序的代码实现"></a>插入排序的代码实现</h4><h5 id="第一版实现"><a href="#第一版实现" class="headerlink" title="第一版实现"></a>第一版实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] changeSort1(<span class="type">int</span>[] arr ) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                cache = arr[j];</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                arr[j-<span class="number">1</span>] = cache;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>时间复杂度: $O(N^2)$</li>
<li>空间复杂度: $O(1)$</li>
</ol>
<h5 id="第二版实现"><a href="#第二版实现" class="headerlink" title="第二版实现"></a>第二版实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序的总结"><a href="#插入排序的总结" class="headerlink" title="插入排序的总结"></a>插入排序的总结</h4><p>插入排序与选择排序一样, 也是应用了减而治之的思想, 每一次插入的操作我们让”未排定的部分”减少一个元素, 让”已经排序的部分”增加一个元素.</p>
<p>与选择排序不同的是, 插入排序比较的方式是从后向前依次看到的元素与插入的元素进行比较, 这一步操作不用比较玩它前面所有的元素, 即<strong>插入排序内层循环可以提前终止</strong>, 这一点是插入排序非常重要的性质.</p>
<p>如果待排序的数组是”接近有序”的数组或元素个数较少的数组, 插入排序就可以很快完成排序内容. 举一个极端的例子: 对于一个已经排好序的数组, 插入排序只需执行一次就直接跳出, 不会继续浪费时间. 由此, 在最理想的情况下, 插入排序的最好时间复杂度可以降低到$O(N)$.</p>
<p>下面我们介绍”哨兵技巧”.</p>
<h4 id="哨兵-Sentinel"><a href="#哨兵-Sentinel" class="headerlink" title="哨兵(Sentinel)"></a>哨兵(Sentinel)</h4><p>在以上两版代码中, 在内层循环中都有<code>j &gt; 0</code>这个判断条件. 但是, 有一种插入排序的写法, 即先找到整个数组中最小的两个元素, 将它交换到数组的第一个位置, 后面的逻辑就可以去掉<code>j &lt; 0</code>. 这种技巧被称作”哨兵”, 即放置一个元素, 通常是边界位置, 起到”站岗放哨”的作用, 它能够帮助我们:</p>
<ol>
<li>回避边界条件</li>
<li>减少分类讨论</li>
</ol>
<h3 id="循环常量"><a href="#循环常量" class="headerlink" title="循环常量"></a>循环常量</h3><p>使用循环常量这个概念可以帮助我们理解和证明算法的有效性. 有的算法虽然直观, 但是要证明算法的有效性, 就需要借助循环不变量这个概念.</p>
<p>此外, 循环不变量还能够帮助我们写出正确的代码, 特别是对于边界条件的讨论. 有的时候把循环不变量作为注释写在代码里, 可以帮助我们理清代码的逻辑, 也有助于他人理解我们的代码.</p>
<h4 id="什么是循环常量"><a href="#什么是循环常量" class="headerlink" title="什么是循环常量"></a>什么是循环常量</h4><p>循环常量是一种语言描述, 描述了在循环过程中, 我们所设计的变量保持不变的性质. 其中: </p>
<ol>
<li>“量”: 表示了一个或者若干个变量;</li>
<li>“循环”+”常”: 在若干个变量在循环的过程中, 保持了它们各自的性质.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-19T06:29:11.000Z" title="2022/6/19 14:29:11">2022-06-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-27T12:13:52.663Z" title="2022/6/27 20:13:52">2022-06-27</time></span><span class="level-item">3 hours read (About 25884 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/">Java核心技术卷1</a></h1><div class="content"><h2 id="Java程序设计概述"><a href="#Java程序设计概述" class="headerlink" title="Java程序设计概述"></a>Java程序设计概述</h2><h2 id="Java程序设计环境"><a href="#Java程序设计环境" class="headerlink" title="Java程序设计环境"></a>Java程序设计环境</h2><h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做<code>String</code>. 每一个用双引号括起来的字符串都是<code>String</code>类的一个实例.</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p><code>String</code>类的<code>substring()</code>方法可以从一个较大的字符串中提取出一个字串. 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>substring()</code>方法的第二个参数表示<strong>不想复制</strong>的第一个位置. 这里, 我们想要复制第0、1和2个字符.</p>
<p><code>substring()</code>的工作方式有一个优点: 容易计算字符串的长度. 字符串<code>s.substring(a, b)</code>的长度就是$b-a$.</p>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>与绝大多数的程序设计语言一样, Java允许使用<code>+</code>号连接(拼接)两个字符串.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">expletive</span> <span class="operator">=</span> <span class="string">&quot;Expletive&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">PG13</span> <span class="operator">=</span> <span class="string">&quot;deleted&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> expletive + PG13;</span><br></pre></td></tr></table></figure>

<p>上述代码讲”Expletivedeleted”赋值给了变量<code>message</code>.</p>
<p>当讲一个字符串与一个非字符串的值进行拼接时, 后者被转换成了字符串. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">rating</span> <span class="operator">=</span> <span class="string">&quot;PG&quot;</span> + age;</span><br></pre></td></tr></table></figure>

<p>此处, <code>rating</code>被赋值为<code>13</code>.</p>
<p>如果需要把多个字符串放在一起, 并用一个定界符分隔, 则可以使用静态<code>join()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot; / &quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们会得到内容为<code>S / M / L / XL</code>的字符串.</p>
<h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p><code>String</code>类中没有提供可用于<strong>修改</strong>字符串的方法. 如果硬要修改, 可以把不需要修改的部分复制出来, 然后使用拼接的方法建立新的字符串.</p>
<p>不可变字符串的最大优点就是<strong>实现了字符串的共享</strong>. 字符串变量总是指向内存中的一块区域, 不论怎样复制字符串变量, 其所指向的内容都是相同的.</p>
<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>可以使用<code>equals()</code>方法检测两个字符串是否相等. 对于表达式<code>s.equals(t)</code>: 如果字符串<code>s</code>与字符串<code>t</code>相等, 则返回<code>true</code>; 反之则返回<code>false</code>. 需要注意的是, <code>s</code>和<code>t</code>既可以是字符串变量, 也可以是字符串字面量. 例如, <code>&quot;Hello&quot;.equals(greeting)</code>表达式是合法的.</p>
<p>想要在不区分大小写的条件下判断表达式是否合法, 我们可以使用<code>equalsIgnoreCase()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="空串与null串"><a href="#空串与null串" class="headerlink" title="空串与null串"></a>空串与<code>null</code>串</h4><p>空串<code>&quot;&quot;</code>是长度为零的字符串. 可以调用一下代码检查一个字符串是否为空:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>而<code>null</code>串是一种特殊的<code>String</code>变量, 它表示没有任何对象与该变量关联. 可用<code>if (str == null)</code>判断一个字符串是否为<code>null</code>.</p>
<h4 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h4><h4 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a><code>String</code> API</h4><h4 id="阅读联机API文档"><a href="#阅读联机API文档" class="headerlink" title="阅读联机API文档"></a>阅读联机API文档</h4><h4 id="构件字符串"><a href="#构件字符串" class="headerlink" title="构件字符串"></a>构件字符串</h4><p>有时需要较短的字符串构建字符串, 例如案件或来自文件中的单词. 采用字符串连接的方式达到此目的效率比较低, 因为每次连接字符串都要创建一个新的<code>String</code>对象, 费时又占空间. 使用<code>StringBuilder</code>类就可以避免这个问题的发生.</p>
<p>如果需要用许多小段的字符串构件一个字符串, 那么应该按照下列步骤进行. 首先, 构建一个空的字符串构建器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>当每次需要添加一部分时, 就调用<code>append()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br></pre></td></tr></table></figure>

<p>在需要构件字符串时就调用<code>toString()</code>方法, 将可以得到一个<code>String</code>对象, 其中包含了构建器中的字符序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">completedString</span> <span class="operator">=</span> builder.toString();</span><br></pre></td></tr></table></figure>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><p>想要通过控制台进行输入, 首先需要构造一个<code>Scanner</code>对象, 并与”标准输入流”<code>System.in</code>关联.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用<code>Scanner</code>类的各种方法实现输入操作了. 如使用<code>nextLine()</code>方法将读取一行的内容做输入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();</span><br></pre></td></tr></table></figure>

<p>使用<code>nextLine()</code>的原因是输入行中有可能包含空格. 如果想要读取一个单词(以空白符作为分隔符), 就调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> in.next();</span><br></pre></td></tr></table></figure>

<p>要是想读取下一个整数, 就调用<code>nextInt()</code>方法; 如果想读取下一个浮点数, 就调用<code>nextDouble()</code>方法.</p>
<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h4 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h4><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a><code>for each</code>循环</h4><p>Java有一种功能很强的循环结构, 可以用来依次处理数组中的每个元素(其他类型的元素几何也可)而不必为指定下标值而分心. 这种增强的<code>for</code>循环结构的格式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement</span><br></pre></td></tr></table></figure>

<h4 id="数值初始化以及匿名数组"><a href="#数值初始化以及匿名数组" class="headerlink" title="数值初始化以及匿名数组"></a>数值初始化以及匿名数组</h4><p>在Java中, 提供了一种创建数组对象并同时赋予初始值的简化书写形式. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] smallPrimes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>甚至还可以初始化一个匿名的数组:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">14</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这种表示法将创建一个新数组并利用括号中提供的值进行初始化, 数值的大小就是初始值的个数. 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallPrimes = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">13</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这是下列语句的简写形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anonymous = &#123;<span class="number">123</span>, <span class="number">123</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">312</span>&#125;;</span><br><span class="line">smallPrimes = anonymous;</span><br></pre></td></tr></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p>在Java中, 允许将一个<strong>数组变量</strong>拷贝给另一个<strong>数组变量</strong>. 此时, <strong>两个变量将引用同一个数组</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] luckyNumbers = smallPrimes;</span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>如果希望将一个数组的所有值<strong>拷贝</strong>到一个新的数组中去, 就需要使用<code>Array</code>类的<code>copyOf</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>其中, 第二个参数是新数组的长度. 这个方法通常用来增加数组的大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luckyNumbers = Arrays.copyOf(luckyNumbers, <span class="number">2</span> * luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>如果数组元素是数值型, 那么多余的元素将被赋值为<code>0</code>; 如果数组元素是布尔型, 则将赋值为<code>false</code>. 相反, 如果长度小于原始数组的长度, 则只拷贝最前面的数组元素.</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>每一个Java应用程序都有一个带<code>String arg[]</code>参数的<code>main()</code>方法. 这个参数表明<code>main()</code>方法将接收一个字符串数组, 也就是命令行参数.</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>想要对数值型数组进行排序, 可以使用<code>Arrays</code>类中的<code>sort()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>

<p>这个方法使用了优化的快速排序算法.</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组将使用多个下标访问数组元素, 它适用于表示表格或更加复杂的排列形式. 在Java中, 声明一个二维数组相当简单. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[][] balances = <span class="keyword">new</span> <span class="title class_">double</span>[NYEARS][NRATES];</span><br></pre></td></tr></table></figure>

<p>如果知道数组元素, 就可以不调用<code>new</code>, 而可以直接使用简化的书写形式对多维数组进行初始化. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] magicSquare = &#123;</span><br><span class="line">    &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">123</span>, <span class="number">34</span>&#125;,</span><br><span class="line">    &#123;<span class="number">123</span>, <span class="number">312</span>, <span class="number">43</span>, <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="number">124</span>, <span class="number">634</span>, <span class="number">345</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">845</span>, <span class="number">235</span>, <span class="number">542</span>,<span class="number">54</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦数组被初始化, 就可以利用两个方括号访问每个元素.</p>
<p>注意, <code>for each</code>循环语句不能自动处理二维数组的每一个元素. 它是按照行, 也就是一位数组处理的. 想要访问二维数组<code>a</code>的所有元素, 则需要使用两个嵌套的循环, 如下图所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">double</span>[] row : a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> value : row)</span><br><span class="line">        statements;</span><br></pre></td></tr></table></figure>

<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><p>我们总是说”Java的多维数组”, 但实际上Java中没有多维数组, 只有一维数组. 多维数组实际上是”数组的数组”, 我们从前面数组<code>magicSquare[]</code>的声明方式就可以看出来.</p>
<p>由此, 我们就可以声明各列长度不一的数组.</p>
<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>想要使用OOP(面向对象程序设计)就需要清楚对象的三种主要特性:</p>
<ol>
<li>对象的行为: 可以对对象施加哪些操作, 或者可以对对象施加哪些方法?</li>
<li>对象的状态: 当施加方法时, 对象如何响应?</li>
<li>对象的标识: 如何辨别具有相同行为与状态的不同对象?</li>
</ol>
<h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p>类之间最常见的关系有三: <strong>依赖</strong>、<strong>聚合</strong>以及<strong>继承</strong>.</p>
<h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>依赖是一种最明显而又最常见的关系. 比如, <code>Order</code>类使用<code>Account</code>类是因为<code>Order</code>对象需要访问<code>Account</code>对象查看信用; 但是<code>Item</code>类不依赖于<code>Account</code>类, 这是因为<code>Item</code>对象于客户账户无关. 总而言之, 如果一个类的方法操纵另一个类的对象, 我们就说一个类依赖于另一个类.</p>
<p>我们应该尽可能地将相互依赖的类减至最少, 用软件工程的术语来说, 就是让类之间的耦合度最小.</p>
<h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p>聚合也是一种相对具体且易于理解的关系. 例如, 一个<code>Order</code>对象包含一些<code>Item</code>对象. 聚合关系意味着类<code>A</code>的对象包含类<code>B</code>的对象.</p>
<h5 id="继承-后面会详细论述"><a href="#继承-后面会详细论述" class="headerlink" title="继承(后面会详细论述)"></a>继承(后面会详细论述)</h5><p>继承是一种用于表示特殊于一般关系的.</p>
<h3 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h3><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>Java总是采用<strong>按值调用</strong>, 即方法得到的是所有参数值的一个拷贝, 无法修改传递给它的任何参数变量的内容.</p>
<p>但是, 由于一个引用变量与其拷贝指向的都是一个对象, 我们可以很方便的利用方法改变对象的值.</p>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>如果在构造器中没有显示地为域赋予初值, 那么就会被自动地赋一个默认值: 数值为<code>0</code>、布尔值为<code>null</code>. 然而, 如果不明确地为域进行初始化, 就会影响程序代码的可读性.</p>
<h4 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h4><p>通过重载类的构造器方法, 可以采用多种形式设置类的实例域的初始状态. 为确保不管如何调用构造器, 每个实例域都可以被设置一个有意义的初值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在执行构造器之前, 先执行赋值操作. 当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时, 这种方式特别有用.</p>
<p>初始值不一定是常量值. 在下面的例子中, 可以调用方法对域进行初始化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> assignId();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">assignId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h4><p>在编写很小的构造器时, 如何为参数命名是个问题. 通常用单个字符命名参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s)</span> &#123;</span><br><span class="line">    name = n;</span><br><span class="line">    salary = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样做有一个缺陷: 只有阅读代码才能够了解参数<code>n</code>和参数<code>s</code>的含义.</p>
<p>有些程序员会在每个参数前面加上一个前缀”a”:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Emplyee</span><span class="params">(String aName, <span class="type">double</span> aSalary)</span> &#123;</span><br><span class="line">    name = aName;</span><br><span class="line">    salary = aSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就比较清晰, 每个读者第一眼就能够看懂参数的含义.</p>
<p>还有一种基于如下事实的常用技巧: 参数变量用同样的名字将实例域<em>屏蔽</em>起来. 例如, 如果将参数命名为<code>salary</code>, <code>salary</code>将引用这个参数, 而不是实例域. 但是, 可以采用<code>this.salary</code>的形式访问实例域. <code>this</code>指隐式参数, 也就是所构造的对象. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h4><p>关键字<code>this</code>引用方法的隐式参数. 然而, 这个关键字还有另外一个含义.</p>
<p>如果<em>构造函数</em>的第一个语句形如<code>this(...)</code>, 则这个构造函数将调用同一个类的另一个构造函数. 下面是一个典型的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// calls Employee(String name, double salary)</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId, s);</span><br><span class="line">    nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>new Employee(60000)</code>时, <code>Employee(double)</code>构造函数将调用<code>Employee(String, double)</code>构造函数.</p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><h4 id="对象析构域finalize方法"><a href="#对象析构域finalize方法" class="headerlink" title="对象析构域finalize方法"></a>对象析构域<code>finalize</code>方法</h4><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类、父类和子类"><a href="#类、父类和子类" class="headerlink" title="类、父类和子类"></a>类、父类和子类</h3><h4 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h4><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>父类中的方法并不一定完全适合子类. 我们以<code>Employee</code>类和<code>Manager</code>类为例展开论述一下该问题.</p>
<p><code>Manager</code>类中有一个<code>getSalary()</code>方法, 可以返回薪水和奖金的总和. 但是其父类<code>Employee</code>类中的<code>getSalary()</code>方法做不到这一点. 所以, 我们需要写一个方法覆盖(override)掉父类中的这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>究竟应该如何实现这个方法呢? 看起来似乎很简单, 只需要返回<code>salary</code>和<code>bonus</code>的和就可以了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法并不能运行. 这是因为<code>Manager</code>类的<code>getSalary()</code>方法不能直接访问父类的私有域. 也就是说, 尽管每个<code>Manager</code>对象都拥有一个名为<code>salary</code>的域, 但是在<code>Manager</code>类的<code>getSalary()</code>方法中并不能够直接访问<code>salary</code>. 只有<code>Employee</code>类的方法才能够访问私有部分. 如果<code>Manager</code>类的方法一定要访问私有域, 就必须借助于公有的接口, <code>Employee</code>类中的公有方法<code>getSalary()</code>方法就是这样的一个接口.</p>
<p>现在我们再用<code>getSalary()</code>方法试一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法还是不能运行. 问题出在<code>getSalary()</code>方法上: <code>Manager</code>类也有一个<code>getSalary()</code>方法, 也就是正在执行的这个方法. 如果我们真的这么写了的话, 整个程序就会陷入无限的自我调用中, 最终程序崩溃.</p>
<p>所以, 当我们想要调用父类的某个方法(这里是<code>getSalary()</code>方法)时, 我们需要告诉编译器, 我们需要的是<strong>父类的</strong>方法. 这一需求可以通过关键字<code>super</code>实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.getSalary();</span><br></pre></td></tr></table></figure>

<p>如此, 我们调用的就不是<code>Manager</code>类中的、而是<code>Employee</code>类中的<code>getSalary()</code>方法. 以下是<code>Manager</code>类中<code>getSalary()</code>方法的正确编写方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类中, 我们可以增加域、增加方法或覆盖父类中的方法, 但是不可能删除所继承的任何域和方法.</p>
<h4 id="子类构造函数"><a href="#子类构造函数" class="headerlink" title="子类构造函数"></a>子类构造函数</h4><h4 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>有一个用来哦按段是否应该设计继承关系的简单规则, 即”IS-A”规则. 它侧面表明了<strong>每个子类对象同时也是其父类的对象</strong>.</p>
<p>“IS-A”规则的另一种表述法是<strong>置换法则</strong>. 它表明<strong>程序中出现父类对象的任何地方都可以用子类对象置换</strong>.</p>
<p>例如, 可以将一个子类的对象赋给父类变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br></pre></td></tr></table></figure>

<p>在Java中, 对象变量是<strong>多态</strong>的. 一个<code>Employee</code>变量既可以引用一个<code>Employee</code>类对象, 也可以引用一个<code>Employee</code>类的任何子类对象. 在下面的程序中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br></pre></td></tr></table></figure>

<p>, 变量<code>staff[0]</code>与<code>boss</code>引用同一个对象. 但编译器将<code>staff[0]</code>看作<code>Employee</code>对象. 这意味着, 我们可以这样调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>但是不能这样调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>因为<code>staff[0]</code>是一个<code>Employee</code>类引用变量, 不能调用不属于<code>Employee</code>类的方法<code>getBonus()</code>.</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><h4 id="阻止继承-final类和方法"><a href="#阻止继承-final类和方法" class="headerlink" title="阻止继承: final类和方法"></a>阻止继承: <code>final</code>类和方法</h4><p>有时候, 可能希望阻止人们利用某个类定义子类. 不允许扩展的类的类被称为<code>final</code>类. 如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是<code>final</code>类. 例如, 假设希望组织人们定义<code>Executive</code>类的子类, 我们就可以在定义这个类的时候使用<code>final</code>修饰符声明. 声明格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Executive</span> <span class="keyword">extends</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的特定方法也可以被声明为<code>final</code>. 如果这样做, 子类就不能覆盖这个方法(<code>final</code>类中的所有方法自动地称为<code>final</code>方法). 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将方法或类声明为<code>final</code>主要目的是: 确保它们不会在子类中改变语义. 例如, <code>Calendar</code>类中的<code>getTime()</code>和<code>setTime()</code>方法都生命为<code>final</code>. 这表明<code>Calendar</code>类的设计者负责实现<code>Date</code>类与日历状态之间的转换, 而不允许子类处理这些问题. 同样地, <code>String</code>类也是<code>final</code>类. 这意味着任何人都不能定义<code>String</code>类的子类.</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>就像primitive基本类型数据的类型转换一样, 不同类的引用变量之间也可以进行类型转换, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> (Manager) staff[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>我们进行类型转换的唯一原因为: <strong>在暂时忽视对象的实际类型之后, 使用对象的全部功能</strong>. 例如, 在<code>managerTest</code>类中, 由于某些项是普通雇员, 所以<code>staff</code>数组必须是<code>Employee</code>对象的数组. 我们需要将数组中引用经理的元素复原成<code>Manager</code>类, 以便能够访问新增加的所有变量.</p>
<p>在Java中, 每个对象变量都属于一个类型. 将一个值存入变量时, 编译器将检查该操作是否合法. 将一个子类对象赋给一个父类引用变量, 这是合法的; 将一个父类对象赋给一个子类引用变量, 这就是不合法的. 我们需要养成如下的良好习惯: <strong>在进行类型转换之前, 先查看一下是否能够成功地转换</strong>. 这个过程十分简单, 只需要使用<code>instanceof</code>操作符就可以实现. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">    boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果检查不通过, 编译器就不会进行这个转换. 综上所述:</p>
<ol>
<li>只能在继承层次内进行类型转换;</li>
<li>在将父类转换成子类之前, 应该使用<code>instanceof</code>进行检查.</li>
</ol>
<p>需要注意的是, 如果<code>x</code>为<code>null</code>, 在进行<code>instanceof</code>时只会返回<code>false</code>, 并不会产生任何异常.</p>
<p>实际上, 通过类型转换调整对象的类型并不是一种好的做法, 应将类型转换限制在仅在需要调用子类中特有的的方法时进行. 但是, 在出现这种情况时, 我们首先需要做的就是检查父类设计, 在父类中添加需要的方法, 这才是比较正确的选择.</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>我们常说, 最好将类中的实例变量标记为<code>private</code>, 而方法标记为<code>public</code>. 任何声明为<code>private</code>的内容对其他类都是不可见的, 就连自己的子类也不能访问父类的私有域.</p>
<p>然而, 在某些时候, 我们希望父类中的某些方法允许被子类访问, 或者允许子类的方法访问父类中的某个域. 为此, 我们需要将这些方法或域标记为<code>protected</code>. 例如, 如果将超类<code>Employee</code>中的<code>hireDay</code>声明为<code>protected</code>, 而非<code>private</code>, 其子类<code>Manager</code>中的方法就可以直接访问它.</p>
<p>不过, 就算标记了<code>protected</code>, 子类<code>Manager</code>也只能访问<code>Manager</code>对象中的<code>hireDay()</code>方法, 而不能访问其他<code>Employee</code>对象中的<code>hireDay()</code>, 对于被标记了<code>protected</code>的其他域也有相同的结论.</p>
<p>在实际应用中应谨慎使用<code>protected</code>属性. 假设需要将设计的类提供给其他程序员使用, 而这个类中设置了一些保护域, 由于其他程序员可以由这个类再派生出新类, 并访问其中的受保护域, 则如果需要对这个类的实现进行修改, 就需要通知所有使用这个类的程序员. 这与OOP的数据封装原则相悖.</p>
<p>受保护的方法更具有实际意义. 如果需要限制某个方法的使用, 就可以将它声明为<code>protected</code>. 这表明子类(可能很熟悉祖先类)得到信任, 可以正确地使用这个方法, 而其他类则不行. 这种方法的最好例子就是<code>Object</code>类中的<code>clone</code>方法, 我们会在后面的相关章节展开论述.</p>
<p>归纳一下Java用于控制可见性的四个修饰符:</p>
<ol>
<li>仅对本类可见: <code>private</code>;</li>
<li>对所有类可见: <code>public</code>;</li>
<li>对包和所有子类可见: <code>protected</code>;</li>
<li>对本包可见: 默认, 无需修饰符.</li>
</ol>
<h3 id="Object-所有类的父类"><a href="#Object-所有类的父类" class="headerlink" title="Object: 所有类的父类"></a><code>Object</code>: 所有类的父类</h3><p><code>Object</code>类是Java类中所有类的始祖, 所有的类都是由它扩展来的. 因此, 了解这个类所提供的所有服务非常重要.</p>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a><code>equals()</code>方法</h4><p><code>Object</code>类中的<code>equals()</code>方法用于检测一个对象是否等于另外一个对象. 在<code>Object</code>类中, 这个方法将判断两个对象是否具有相同的引用: 如果两个对象具有相同的引用, 则它们一定是相等的.</p>
<p>然而, 对于绝大多数类来说, 这种判断是没有意义的. 例如: 采用这种方法判断两个<code>PrintStream</code>对象是否相等就是完全没有意义的. 通常需要的是判断两个对象的状态是否相等. 如果两个对象的状态是相等的, 就认为这两个对象是相等的.</p>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>如果隐式和显式的参数不属于同一个类, <code>equals()</code>方法将会如何处理呢? 这是一个很有争议的问题.</p>
<p>Java语言规范要求<code>equals()</code>方法具有下面的特性:</p>
<ol>
<li>自反性: 对于任何非空引用<code>x</code>, <code>x.equals(x)</code>应该返回<code>true</code>;</li>
<li>对称性: 对于任何<code>x</code>和<code>y</code>, 当且仅当<code>y.equals(x)</code>返回<code>true</code>, <code>x.equals(y)</code>也应该返回<code>true</code>;</li>
<li>传递性: 对于任何<code>x</code>、<code>y</code>和<code>z</code>, 如果<code>x.equals(y)</code>返回<code>true</code>, <code>y.equals(z)</code>返回<code>true</code>, <code>x.equals(z)</code>也应该返回<code>true</code>;</li>
<li>一致性: 如果<code>x</code>和<code>y</code>引用的对象没有发生变化, 反复调用<code>x.equals(y)</code>应该返回同样的结果;</li>
<li>对于任何非空引用<code>x</code>, <code>x.equals(null)</code>应返回<code>false</code>.</li>
</ol>
<p>这些规则是比较合理的, 因为其避免了类库实现者在数据结构中定位一个元素时还要考虑调用<code>x.equals(y)</code>, 还是调用<code>y.equals(x)</code>的问题.</p>
<p>但是, 但就对称性而言, 当比较两者不属于同一个类时, 我们需要仔细考虑一下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.equals(m);</span><br></pre></td></tr></table></figure>

<p>这里的<code>e</code>是一个<code>Employee</code>对象, <code>m</code>是一个<code>Manager</code>对象, 并且两个对象具有相同的姓名、薪水和雇佣日期. 如果在<code>Employee.equals()</code>中使用<code>instanceof</code>进行检测, 则返回<code>true</code>. 然而, 当我们反过来调用时,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.equals(e);</span><br></pre></td></tr></table></figure>

<p>根据对称性, 我们也需要返回<code>true</code>. 这就使得<code>Manager</code>类的<code>equals()</code>方法必须能够用自己与任何一个<code>Employee</code>对象进行比较, 忽视了自己所拥有的特有信息. 这无疑是不合理的.</p>
<p>本书认为:</p>
<ol>
<li>如果子类能够拥有自己的相等的概念, 则对称性要求强制采用<code>getClass()</code>进行检测;</li>
<li>如果由父类决定相等的概念, 那么就可以使用<code>instanceof</code>进行检测, 这样可以在不同的对象之间进行相等的比较.</li>
</ol>
<p>同时, 本书给出一个比较合理的编写<code>equals()</code>方法的建议:</p>
<ol>
<li>显示参数命名为<code>otherObject</code>, 稍后需要将他转换成另一个叫做<code>other</code>的变量;</li>
<li>检测<code>this</code>与<code>otherObject</code>是否引用同一个对象;</li>
<li>检测<code>otherObject</code>是否为<code>null</code>, 如果为<code>null</code>, 则返回<code>false</code>;</li>
<li>比较<code>this</code>与<code>otherObject</code>是否属于同一个类;</li>
<li>将<code>otherObject</code>转换为相应的类类型变量;</li>
<li>对所有需要比较的域进行比较. 如果所有的域都匹配, 就返回<code>true</code>; 反之, 则返回<code>false</code>.</li>
</ol>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h4><p>哈希值(Hash Code)是由对象导出的一个整型值, 无规律可言. 这使得两个不同对象的哈希值基本不会相等.</p>
<p><code>String</code>类使用下列算法计算哈希值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length(); i++) &#123;</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>hashCode()</code>方法定义在<code>Object</code>类中, 因此每个对象都有一个默认的哈希值, 其值为该对象的存储地址. 请看下面的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">System.out.println(s.hashCode() + <span class="string">&quot; &quot;</span> + sb.hashCode());</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(t);</span><br><span class="line">System.out.println(t.hashCode() + <span class="string">&quot; &quot;</span> + tb.hashCode());</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th>哈希值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>s</code></td>
<td>2524</td>
</tr>
<tr>
<td align="center"><code>sb</code></td>
<td>460141958</td>
</tr>
<tr>
<td align="center"><code>t</code></td>
<td>2524</td>
</tr>
<tr>
<td align="center"><code>tb</code></td>
<td>1163157884</td>
</tr>
</tbody></table>
<p>我们可以发现, 字符串<code>s</code>和<code>t</code>拥有相同的哈希值, 这是因为字符串的哈希值是由内容导出的; 但是字符串缓冲<code>sb</code>和<code>tb</code>却有着不同的哈希值, 这是因为<code>StringBuilder</code>类总没有定义<code>hashCode()</code>方法, 故调用的实际上是<code>Object</code>类的默认<code>hashCode()</code>方法, 获得的即为其自身的存储地址.</p>
<p>如果重新定义<code>equals()</code>方法, 我们就必须重新定义<code>hashCode()</code>方法, 以便用户可以将对象插入到哈希表中(具体内容会在后面详细论述).</p>
<p><code>hashCode()</code>方法应该返回一个整型数值(可以为负), 并合理地组合实例域的哈希值, 以便能够让各个不同的对象产生的哈希值更加均匀. 例如下面就是<code>Employee</code>类的<code>hashCode()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()</span><br><span class="line">        + <span class="number">11</span> * <span class="keyword">new</span> <span class="title class_">Double</span>(salary).hashCode()</span><br><span class="line">        + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法还有改进的空间. 首先, 最好使用<code>null</code>安全的<code>Object.hashCode()</code>. 如果其参数为<code>null</code>, 这个方法会直接返回0, 否则返回对参数调用<code>hashCode()</code>的结果.</p>
<p>其次, 可以使用静态方法<code>Double.hashCode()</code>方法来避免创建<code>Double</code>对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> * Object.hashCode(name)</span><br><span class="line">        + <span class="number">11</span> * Double.hashCode(salary)</span><br><span class="line">        + <span class="number">13</span> * Object.hashCode(hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还有改进的空间</strong>. 需要组合多个哈希值时, 可以调用<code>Objects.hash()</code>并提供多个参数. 这个方法会对各个参数调用<code>Object.hashCode()</code>, 并组合这些哈希值. 如此, <code>Employee.hashCode()</code>方法可以被简单地写为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a><code>toString()</code>方法</h4><p>在<code>Object</code>中还有一个重要的方法, 即<code>toString()</code>方法. 它用于返回表示对象值的字符串. 下面是一个典型的例子: <code>Point</code>类的<code>toString()</code>方法将返回下面这样的字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Point[x=<span class="number">10</span>,y=<span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>绝大多数的<code>toString()</code>方法都遵循这样的格式: 类的名字, 随后是一对方括号括起来的域值. 下面是<code>Employee</code>类中的<code>toString()</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">         + <span class="string">&quot;, hireDay=&quot;</span> + hireDay</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上, 该方法还有改进空间. 最好通过掉调用<code>getClass().getName()</code>方法获得类名的字符串, 而不要将类名硬加到<code>toString()</code>方法中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()</span><br><span class="line">         + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">         + <span class="string">&quot;, hireDay=&quot;</span> + hireDay</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计子类的程序员也应该定义自己的<code>toString()</code>方法, 并将子类域的描述添加进去. 如果父类中使用了<code>getClass().getName()</code>, 那么子类只要调用<code>super.toString()</code>方法就可以了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString()</span><br><span class="line">             + <span class="string">&quot;[bonus=&quot;</span> + bonus</span><br><span class="line">             + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toString()</code>方法如此常见的原因为: 只要对象域一个字符串通过操作符”<code>+</code>“连接起来, Java编译器就会自动调用<code>toString()</code>方法, 以便获得这个对象的字符串描述. 此外, 对于任意对象<code>x</code>, 使用<code>println(x)</code>方法就会直接调用<code>x.toString()</code>, 并打印输出得到的字符串.</p>
<h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>如何动态调整数组大小一直是一个让程序员头疼的问题. 幸好, 在Java中, 有一个名为<code>ArrayList</code>的类, 能够很好地解决这个问题.</p>
<p><code>ArrayList</code>类是一个采用类型参数(type parameter)的泛型类(generic class). 为了指定数组列表保存的元素对象类型, 需要用一对尖括号将类名括起来加在后面. 下面的代码声明和构造了一个保存<code>Employee</code>类对象的数组列表:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>既然两边都使用<code>Employee</code>, 重复输入多少有些繁琐, 故在Java SE 7中, 可省去右侧的类型参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>使用<code>add()</code>方法可以将元素添加到数组列表中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(...));</span><br></pre></td></tr></table></figure>

<p><code>ArrayList</code>类最大的优点在于其可以自动调整内部数组的大小. 但是, 如果已经清楚或能够估计出数组可能储存的元素数量, 我们就可以在填充数组之前调用<code>ensureCapacity()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.ensureCapacity(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法将分配一个包含100个对象的内部数组. 然后调用100次<code>add()</code>, 而不用重新分配空间.</p>
<p>另外, 还可以将初始容量传递给<code>ArrayList</code>构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>size()</code>方法将返回<code>ArrayList</code>中包含的<strong>实际元素数量</strong>.</p>
<p>此外, 一旦确定<code>ArrayList</code>的大小不再发生变化, 就可以调用<code>trimToSize()</code>方法. 这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目, 垃圾回收器也会回收多余的存储空间.</p>
<h4 id="访问数组列表元素"><a href="#访问数组列表元素" class="headerlink" title="访问数组列表元素"></a>访问数组列表元素</h4><p>想要访问或改变<code>ArrayList</code>元素, 需要使用<code>get</code>或<code>set</code>方法. 比如改变第<code>i</code>个元素的内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.set(i, harry);</span><br></pre></td></tr></table></figure>

<p>只有<code>i</code>小于或等于<code>ArrayList</code>大小时才能调用<code>set()</code>方法.</p>
<p>此外, 当没有泛型类时, 原始的<code>ArrayList</code>类提供的<code>get()</code>方法别无选择, 只能返回<code>Object</code>对象. 从这类<code>ArrayList</code>中调用出来的对象需要进行类型转换:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> (Employee) staff.get(i);</span><br></pre></td></tr></table></figure>

<h4 id="类型化域原始数组列表的兼容性"><a href="#类型化域原始数组列表的兼容性" class="headerlink" title="类型化域原始数组列表的兼容性"></a>类型化域原始数组列表的兼容性</h4><p>在我们自己的代码中, 我们可能更愿意使用类型参数来增加安全性. 在本节中, 我们会了解如何与没有使用类型参数的遗留代码交互操作.</p>
<p>假设有下面这个遗留下来的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(ArrayList list)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将一个类型化的数组传递给<code>update()</code>方法, 而不需要进行任何类型转换; 也可以将下面的<code>staff</code>对象传递给<code>updates()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = ...;</span><br><span class="line">employeeDB.update(staff);</span><br></pre></td></tr></table></figure>

<p>但是实际上, 这样调用说不上安全. 在<code>update()</code>方法中, 添加到<code>ArrayList</code>中的不一定是<code>Employee</code>对象. 编译器并不会发现这个问题, 但是在对这些元素进行检索的时候就会报错. 相反地, 将一个原始<code>ArrayList</code>赋给一个类型化<code>ArrayList</code>就会得到一个警告.</p>
<p>此外, 就算使用了类型转换也并不能避免出现警告:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query);</span><br></pre></td></tr></table></figure>

<p>我们只能受到一个警告信息, 提醒我们类型转换有误.</p>
<p>这是Java中不尽如人意的参数化类型的限制所带来的结果. 处于兼容性的考虑, 编译器在对类型转换进行检查之后, 如果没有发现违反规则的现象, 就将所有的类型化数组 列表转换成原始<code>ArrayList</code>对象. 在程序运行时, 所有的<code>ArrayList</code>都是一样的, 即没有虚拟机中的类型参数. 因此, 在执行将<code>ArrayList</code>转化为<code>ArrayList&lt;Employee&gt;</code>的操作时, 编译器将执行相同的运行时检查.</p>
<p>此时我们无需多做什么, 只要在与剩下的代码进行交叉操作时, 研究一下比那一起的警告提示, 并确保这些警告不会造成太严重的后果就可以了. 一旦确保不会造成严重后果, 可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>标注来标记这个变量能够接收类型转换,  如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query);</span><br></pre></td></tr></table></figure>

<h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><p>有时需要将<code>int</code>这样的基本类型转换为对象. 每个primitive主数据类型都有一个包装用的类, 名为包装器(wrapper), 且这些包装类都放在<code>Java.lang</code>这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示:</p>
<table>
<thead>
<tr>
<th>primitive主数据类型名称</th>
<th>包装类名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
</tbody></table>
<p>对象包装器是不可变的, 即一旦构造了包装器, 就不允许改变包装在其中的值. 同时, 对象包装类还被标记为<code>final</code>, 无法被继承.</p>
<p>此外, 还有一个很有用的特性, 使得向<code>ArrayList&lt;Integer&gt;</code>中添加<code>int</code>元素的过程更加方便. <code>list.add(3)</code>将被自动地转换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>这种转换被称为自动装箱(autoboxing).</p>
<p>相反地, 将一个<code>Integer</code>对象赋值给一个<code>int</code>值时, 就会进行自动拆箱, 即将<code>int n = list.get(n)</code>翻译成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i).intValue();</span><br></pre></td></tr></table></figure>

<p>甚至在算数表达式中自动拆装箱也是成立的. 比如, 下面的这个表达式是合法的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<p>大多数情况下, 容易有一种假象, 即基本类型与它们的对象包装器是一样的, 只是它们的相等性不同. 大家知道, <code>==</code>运算符也可以应用于对象包装器对象, 只不过检测的是对象是否指向同一个存储区域, 因此, 下面的比较通常不会成立:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>的确相等表达式有时会成立, 但是我们的程序不能建立在这种<em>可能</em>上. 如果真的要判断两个<code>Integer</code>对象是否相等的话, 还是需要使用<code>equals()</code>方法.</p>
<p>还有几点有关自动装箱的事情需要注意的. 首先, 由于包装类引用可以为<code>null</code>, 所以自动装箱有可能会抛出一个<code>NullPointerException</code>异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span>*n);</span><br></pre></td></tr></table></figure>

<p>另外, 如果在一个条件表达式中混用<code>Integer</code>和<code>Double</code>类型, <code>Integer</code>值就会拆箱, 提升为<code>double</code>, 并在此装箱为<code>Double</code>.</p>
<p>最后, 自动拆装箱是<strong>编译器</strong>认可的, 和JVM没有什么关系. 编译器在生成的字节码中添加一些必要的方法调用, 而虚拟机只是忠实地执行这些字节码罢了.</p>
<h4 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h4><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>下面是一个典型的枚举类的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br></pre></td></tr></table></figure>

<p>此声明定义了一个有着四个实例的类, 在此尽量不要构造新对象. 因此, 在比较两个枚举类型的值时直接使用<code>==</code>即可.</p>
<p>如有需要, 可以在枚举类中添加一些构造器、方法和域. 当然, 构造器只在构造枚举常量时被调用. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;<span class="built_in">this</span>.abbreviation = abbreviation;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;<span class="keyword">return</span> abbreviation;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的枚举类都是<code>Enum</code>类的子类. 它们继承了这个类的许多方法, 其中最有用的就是<code>toString()</code>方法. 这个方法能够返回枚举常量名. 例如, <code>Size.SMALL.toString()</code>将返回字符串”<code>SMALL</code>“.</p>
<p><code>toString()</code>的逆方法是静态方法<code>valueOf()</code>. 例如, 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Enum.valueOf(Size.class, <span class="string">&quot;SMALL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将会把<code>s</code>设置为<code>Size.SMALL</code>.</p>
<p>每个枚举类都有一个静态的<code>values</code>方法, 它将返回一个包含全部枚举值的数组. 例如, 如下调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size[] values = Size.values()</span><br></pre></td></tr></table></figure>

<p>将返回包含元素<code>Size.SMALL</code>, …和<code>Size.EXTRA_LARGE</code>的数组.</p>
<p><code>ordinal()</code>方法返回<code>enum</code>生命中枚举常量的位置, 索引从零开始计数.</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li>将公共操作和域放在父类;</li>
<li>不要使用受保护的域;</li>
<li>使用继承实现”IS-A”关系</li>
<li>除非所有继承的方法都有意义, 否则不要使用继承</li>
<li>在覆盖方法时, 不要改变预期的行为</li>
<li>使用多态, 而非类型信息</li>
<li>不要过多地使用反射</li>
</ol>
<h2 id="接口、lambda表达式域内部类"><a href="#接口、lambda表达式域内部类" class="headerlink" title="接口、lambda表达式域内部类"></a>接口、lambda表达式域内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>在Java程序设计语言中, 接口不是类, 而是对类的一组需求描述. 这些类要遵从接口描述的统一格式进行定义.</p>
<p>我们经常听到服务提供商这样说: “如果类遵从某个特定接口, 那么就旅行这项服务”. 下面给出一个具体的示例: <code>Arrays</code>类中的<code>sort()</code>方法承诺可以对对象数组进行排序, 但要求对象所述的类必须实现了<code>Comparable</code>接口.</p>
<p>下面是<code>Comparable</code>接口的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是说, 任何实现<code>Comparable</code>接口的类都需要包含<code>comparaTo()</code>方法, 并且这个方法的参数必须是一个<code>Object</code>对象, 返回一个整型数值.]</p>
<p>接口中的所有方法自动地属于<code>public</code>. 因此, 在接口中声明方法时, 不必提供关键字<code>public</code>.</p>
<p>当然, 接口中还有一个没有明确说明的附加要求: 在调用<code>x.compareTo(y)</code>的时候, 这个<code>compareTo()</code>方法必须确实比较两个对象的内容, 并返回比较的结果. 当<code>x</code>小于<code>y</code>时, 返回一个负数; 当<code>x</code>等于<code>y</code>时, 返回<code>0</code>; 否则返回一个正数.</p>
<p>上面这个接口只有一个方法, 而有些接口可能包含多个方法. 稍后可以看到, 在接口中还可以定义常量. 然而, 更为重要的是要知道接口不能提供哪些功能. 接口绝不能含有实例域——提供实例域和方法实现的任务应交由实现接口的那个类来完成.</p>
<p>现在, 假设希望使用<code>Arrays</code>类的<code>sort()</code>方法对<code>Employee</code>对象数组进行排序, <code>Employee</code>类就必须实现<code>Comparable</code>接口.</p>
<p>为了让类实现一个接口, 通常需要下面两个步骤:</p>
<ol>
<li>将类声明为实现给定的接口;</li>
<li>对接口中的所有方法进行定义.</li>
</ol>
<p>要将类声明为实现某个接口, 需要使用关键字<code>implements</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br></pre></td></tr></table></figure>

<p>当然, 这里的<code>Employee</code>类需要提供<code>compareTo()</code>方法. 假设希望根据雇员的薪水进行比较. 一下是<code>compareTo()</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) o;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里, 我们使用了静态方法<code>Double.compare()</code>方法. 如果第一个参数小于第二个参数, 它会返回一个负值; 如果二者相等则返回<code>0</code>; 否则返回一个正值.</p>
<p>需要注意的是: 在接口声明中, 没有将<code>compareTo()</code>方法声明为<code>public</code>, 这是因为接口中的所有方法都默认为<code>public</code>. 不过, 在实现接口时, 我们需要将方法声明为<code>public</code>; 否则, 编译器将认为这个方法的访问属性为<code>default</code>, 之后编译器就会给出视图提供更严格的访问权限的警告信息.</p>
<p>此外, 我们还可以更进一步, 为泛型<code>Comparable</code>接口提供一个类型参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, o.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要提一嘴的是, 对<code>Object</code>参数进行强制类型转换的行为现在已经不常见了.</p>
<p>综上所述, 我们已经看到, 要让一个类使用排序服务必须让它实现<code>compareTo()</code>方法. 这是很有必要的, 因为需要向<code>sort()</code>方法提供对象的比较方式. 但是, 为什么不直接在<code>Employee</code>类中直接提供一个<code>compareTo()</code>方法, 而必须实现<code>Compareable</code>接口呢?</p>
<p>原因在于<strong>Java是一种强类型语言</strong>. 在调用方法的时候, 编译器将会检查这个方法是否存在. 在<code>sort()</code>方法中可能存在下面这样的语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i].compareTo(a[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// rearrange a[i] and a[j]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为此, 编译器就必须确认<code>a[i]</code>中一定有<code>compareTo()</code>方法. 如果<code>a</code>是一个<code>Comparable</code>对象的数组, 就可以确保拥有<code>compareTo()</code>方法, 因为每个实现<code>Comparable</code>接口的类都必须提供这个方法的定义.\</p>
<h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><p>接口不是类, 尤其不能使用<code>new</code>运算符实例化一个接口. 但我们可以声明接口的引用变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable x;</span><br></pre></td></tr></table></figure>

<p>接口引用变量必须引用实现了接口的类的对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Employee</span>(...) <span class="comment">// Employee implements Comparable</span></span><br></pre></td></tr></table></figure>

<p>接下来, 如同使用<code>instanceof</code>检查一个对象是否属于某个特定类一样, 也可以使用<code>instance</code>检查一个对象是否实现了某个特定的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>域可以建立类的继承关系一样, 接口也可以被扩展. 这里与允许存在多条从具有较高通用性的接口到较高专用性接口的链. 例如, 假设有一个称为<code>Moveable</code>的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 可以以它为基础扩展一个叫做<code>Powered</code>的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在接口中不能包含实例域或静态方法, 但可以包含常量. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">SPEED_LIMIT</span> <span class="operator">=</span> <span class="number">95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与接口中的方法都自动被设置为<code>public</code>一样, 接口中的域将被自动设为<code>public static final</code>.</p>
<p>有些接口中只定义了常量, 没有定义方法. 这样有助于在实现了该类接口的类中方便地调用常量. 但这样应用接口似乎有些偏离了接口概念的初衷, 不推荐这样使用.</p>
<p>尽管每个类都只能有一个超类, 但是可以同时实现多个接口. 这为定义类的行为提供了极大的灵活性.</p>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>在本节中, 我们将重点论述抽象类与接口的区别.</p>
<p>我们在前面提出过一个疑问: 为什么Java要引入接口的概念? 为什么不将<code>Comparable</code>直接设计成如下所示的抽象类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, <code>Employee</code>类再直接继承这个抽象类, 并提供<code>compareTo()</code>方法的实现呢?</p>
<p>主要原因是每个类只能继承一个类. 如果<code>Employee</code>类已经继承了一个类, 我们就不能再让它继承其他类; 但每个类可以实现多个接口, 如此就足够了.</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在Java SE 8中, 允许在接口中增加静态方法. 理论上讲, 没有任何理由认为这是违法的——它只是有悖于接口作为抽象规范的初衷.</p>
<p>目前为止, 通常的做法都是将静态方法放在伴随类中. 在标准库中有着各式各样的接口和实用工具类, 如<code>Collection</code>&#x2F;<code>Collections</code>或<code>Path</code>&#x2F;<code>Paths</code>.</p>
<p>以<code>Paths</code>类为例, 其中只包含两个工厂方法. 可以由一个字符串序列构造一个文件或目录的路径, 如<code>Path.get(&quot;jdk 1.8.0&quot;, &quot;jre&quot;, &quot;bin&quot;)</code>. 在Java SE 8中, 可以为<code>Path</code>接口增加以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">get</span><span class="params">(String first, String... more)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystem.getDefault().getPath(first, more);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来, <code>Paths</code>类就不是必要的了.</p>
<p>不过, 将整个<code>Java</code>库都以这种方式重构也是不太可能的. 但在实现我们自己的接口时, 不需要为实用工具另外提供一个伴随类.</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个默认实现. 必须用<code>default</code>修饰符标记这样一个方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话, 默认方法并没有太大的用处, 因为最终每个<code>Comparable</code>的每一个实际实现都要覆盖掉这个默认方法. 但在某些情况下, 默认方法会发挥它的作用. 例如, 在Java事件处理中, 如果希望在发生鼠标点击事件时得到通知, 就要实现一个包含五个方法的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大多数情况下, 我们都只关心其中的一两个事件类型. 在Java SE 8中, 可以将所有方法都声明为默认方法. 这些默认方法什么都不做:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseListener</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来, 我们就只需要实现我们关心的方法就可以了.</p>
<p>默认方法的另一个重要用法为”<strong>接口演化</strong>“(interface evolution). 以<code>Collection</code>接口为例, 这个接口作为Java的一部分已经有很多年了. 假设我们很久以前写了一个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span> <span class="keyword">implements</span> <span class="title class_">Collection</span></span><br></pre></td></tr></table></figure>

<p>后来, 我们又在Java SE 8中为该接口增加了一个<code>stream</code>方法. 如果这个<code>stream</code>方法不是一个默认方法, 则<code>Bag</code>类就不能编译, 因为他没有实现这个新方法. 为接口增加以恶非默认方法不能保证”源代码兼容”(source compatible).</p>
<p>不过, 假设不重新编译一个类, 而是使用原先的一个JAR文件, 这个类依旧能够正常加载. 不过, 如果程序在一个<code>Bag</code>实例上调用<code>stream</code>方法, 就会出现一个<code>AbstractMethodError</code>.</p>
<p>将方法实现一个默认方法就可以解决这两个问题. 此外, 如果没有重新编译而直接加载这个类, 并在一个<code>Bag</code>实例上调用<code>stream</code>方法, 将调用<code>Collection.stream()</code>方法.</p>
<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>如果现在一个接口中将一个方法定义为默认方法, 然后又在父类或另一个接口中定义了同样的方法, 会发生什么情况? 对于这种情况, Java有着如下规定:</p>
<ol>
<li>父类优先: 如果父类提供了一个具体方法, 同名而且有相同参数类型的默认方法会被忽略;</li>
<li>接口冲突: 如果一个父接口提供了一个默认方法, 另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法, 必须覆盖这个方法来解决冲突.</li>
</ol>
<p>我们来研究一下第二个规则. 考虑另一个包含<code>getName()</code>方法的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个类同时实现了这两个接口会怎么样呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Named &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类会继承<code>Person</code>和<code>Named</code>接口提供的两个不一致的<code>getName()</code>方法. 我们只需要在<code>Student</code>类中提供一个<code>getName()</code>方法. 在这个方法中, 可以选择两个冲突方法中的一个, 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Named &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们假设<code>Named</code>接口没有为<code>getName()</code>提供默认实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code>类会从<code>Person</code>接口继承默认方法吗? 不会的. Java更强调一致性. 两个接口是如何冲突的并不重要, 如果至少有一个接口提供了一个实现, 编译器就会报告错误, 而我们就必须解决这个二义性.</p>
<p>如果两个接口都没有为共享方法提供默认实现, 那么就与Java SE 8之前的情况一样, 不存在冲突. 实现类可以有两个选择: 实现这个方法, 或者干脆不实现. 如果是后一种情况, 这个类本身就是抽象的.</p>
<p>现在来讨论另外一种情况: 一个类继承了父类, 同时又实现了一个接口, 并从父类和接口继承了相同的方法. 例如, 假设<code>Person</code>是一个类, <code>Student</code>定义为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Named</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下, 编译器只会考虑父类方法, 所有接口的默认方法都将被忽略. 这就是”类优先”原则.</p>
<p>“类优先”原则有助于确保程序与Java SE 7间的兼容性. 如果为一个接口增加默认方法, 这对于这个默认方法之前能够正常工作的代码不会有任何影响.</p>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><p>在接下来的三节中, 我们将学习接口的另外一些示例, 并从中进一步学习接口的实际使用.</p>
<h4 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h4><p>回调(callback)是一种常见的程序设计模式. 在这种模式中, 可以指出某个特定事件发生时应该采取的动作. 例如, 可以指出在按下鼠标或选择某个菜单项时应该采取什么行动. 然而, 由于我们还没有将接口部分介绍完, 所以我们只能讨论一些与上述功能类似且并简化的版本.</p>
<p>在<code>java.swing</code>包中有一个<code>Timer</code>类. 它可以在到达给定的时间间隔时发出通告. 例如, 加入程序中有一个时钟, 就可以请求每秒钟获得一个通告, 以便更新时钟的表盘.</p>
<p>在构造定时器时, 我们需要设置一个时间间隔, 并告知计时器, 当达到时间间隔时需要做些什么操作.</p>
<p>如何告知定时器做什么呢? 在Java中, 我们将某个类的对象传递给定时器, 然后定时器调用这个对象的方法. 由于对象可以携带一些附加的信息, 所以传递一个对象比传递一个函数要灵活的得多.</p>
<p>当然, 定时器需要知道调用哪一个方法, 并要求传递的对象所属的类实现了<code>java.awt.event</code>包的<code>ActionListener</code>接口. 下面是这个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当达到指定的时间间隔时, 定时器就调用<code>actionPerformed()</code>方法.</p>
<p>假设希望每隔10秒钟打印一条信息”At the tone, the time is …”, 然后响一声, 就应该定义一个实现<code>ActionListener</code>接口的类, 然后将需要执行的语句放在<code>actionPerformed()</code>方法中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来, 构造这个类的一个对象, 并将它传递给<code>Timer</code>构造器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br></pre></td></tr></table></figure>

<p>其中, <code>Timer</code>构造器的第一个参数是发出通告的时间间隔, 单位为毫秒; 第二个参数是监听器对象.</p>
<p>最后, 启动定时器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>于是, 我们就编写了一个每隔一秒显示一次当前时间并振铃的程序.</p>
<p>在下面的程序中, 我们给出了定时器和监听器的操作行为. 在定时器启动后, 程序将弹出一个消息对话框, 并等待用户点击OK按钮来终止程序的执行. 在程序等待用户操作的同时, 每隔10秒钟显示一次当前的时间.</p>
<p>需要注意的是, 该程序除了导入<code>javax.swing.*</code>和<code>java.util.*</code>外, 还通过类名导入了<code>javax.swing.Timer</code>. 这就消除了<code>javax.swing.Timer</code>与<code>java.util.Timer</code>之间的二义性, 其中, 后者是一个与本例无关的类, 主要负责调度后台任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerPrinter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit program&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimerPrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a><code>Comparator</code>接口</h4><p>在<a href="#%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5">先前</a>我们已经了解了如何对一个<code>ArrayList</code>排序, 前提是这些对象是实现了<code>Comparable</code>接口的类实例.</p>
<p>现在假设我们希望按长度递增的顺序对字符串进行排序, 而不是按字典顺序进行排序. 由于我们不可能对<code>String</code>类做出任何修改, 故我们需要另辟蹊径.</p>
<p><code>Array.sort()</code>方法还有第二个版本, 以一个数组和一个比较器(comparator)作为参数. 比较器是实现了<code>Comparator</code>接口的类的实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要按照长度比较字符串, 则可以定义一个以如下方式实现<code>Comparator&lt;String&gt;</code>的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体完成比较时, 我们需要建立一个实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i], words[j] &gt; <span class="number">0</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>该方法与<code>words[i].compareTo(words[j])</code>做比较. 这个<code>compare</code>方法要在比较器对象上调用, 而不是在字符串对象本身上调用.</p>
<h4 id="对象克隆——Cloneable接口"><a href="#对象克隆——Cloneable接口" class="headerlink" title="对象克隆——Cloneable接口"></a>对象克隆——<code>Cloneable</code>接口</h4><p>鸽了.</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="为什么引入lambda表达式"><a href="#为什么引入lambda表达式" class="headerlink" title="为什么引入lambda表达式"></a>为什么引入lambda表达式</h4><p>lambda表达式是一个可传递的代码块, 可以在以后执行一次或多次.</p>
<p>在<a href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83">前面的章节中</a>我们已经了解了如何按指定时间间隔完成工作. 将这个工作放在<code>ActionListener</code>的<code>actionPerformed()</code>方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在想要反复执行这个代码时, 可以构造<code>Worker</code>类的一个实例, 然后将这个实例提交到一个<code>Timer</code>对象. 这里的重点是<code>actionPerformed()</code>方法包含希望以后执行的代码.</p>
<p>或者可以考虑如何用一个定制比较器完成排序. 如果想按长度而不是默认的字典顺序对字符串排序, 可以向<code>sort()</code>方法传入一个<code>Comparator</code>对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Arrays.sort(string, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure>

<p><code>comparator()</code>方法并不会被立即调用. 实际上, 在数组完成排序之前, <code>sort()</code>方法会一直调用<code>compare()</code>方法, 只要元素的顺序不正确就会重新排列元素. 将比较元素所需的代码段放在<code>sort()</code>方法中, 这个代码与其余的排序逻辑继承.</p>
<p>这两个例子有一些二共同点, 即都是将一个代码块传递到某个对象(一个定时器, 或者一个<code>sort()</code>方法). 这个代码块会在将来某个时间调用.</p>
<p>到目前为止, 在Java中传递一个代码段并不容易, 不能直接传递代码段, 毕竟Java是一种面向对象的语言. 所以必须构造一个对象, 这个对象的类需要有一个方法能包含所需的代码. 但是, lambda表达式解决了这个问题.</p>
<h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h4><p>再考虑上一节讨论的例子. 在<code>compare()</code>方法中, 我们需要实现计算:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p><code>first</code>和<code>second</code>是什么? 它们都是字符串. Java是一种类型语言, 所以我们还需要指定它们的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">    -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>这就是我们编写的第一个lambda表达式. lambda表达式就是一个代码块, 以及必须传入代码的变量规范. 其编写规范为: 参数, 箭头(<code>-&gt;</code>)以及一个表达式. 如果代码要完成的计算无法放在一个表达式中, 就可以像写方法一样, 把这些代码放在<code>&#123;&#125;</code>中, 并包含显式的<code>return</code>语句. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()&gt;) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 如果一个lambda表达式只在某些分支中返回一个值, 而在另外一些分支不返回值, 这是不合法的.</p>
</blockquote>
<p>即使lambda表达式没有参数, 仍然要提供空括号, 就像无参数方法一样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以推导出一个lambda表达式的参数类型, 则可以忽略其类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>在这里, 编译器可以推导出<code>first</code>和<code>second</code>必然是字符串, 因为这个lambda表达式将赋给一个字符串比较器.</p>
<p>如果方法只有一个参数, 而且这个参数的类型可以推到得出, 那么甚至还可以忽略小括号:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">    System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<p>无需指定lambda表达式的返回类型. lambda表达式的返回类型总是会由上下文推导得出. 例如, 下面的表达式可以在需要<code>int</code>类型结果的上下文中使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>下面程序中的程序显示了如何在一个比较器和一个动作监听器中使用lambda表达式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] planets = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>,</span><br><span class="line">                                         <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>,</span><br><span class="line">                                         <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted in dictionary order:&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(planets);</span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by length:&quot;</span>);</span><br><span class="line">        Arrays.sort(planets, (first, second) -&gt; first.length() - second.length());</span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        </span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">100</span>, event -&gt; System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit program&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>lambda表达式与接口是兼容的. 对于哪些只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个lambda表达式. 这种接口称为函数式接口(function interface).</p>
<p>为了展示如何转换为函数式接口, 下面考虑<code>Arrays.sort()</code>方法. 它的第二个参数需要一个<code>Comparator</code>实例, <code>Comparator</code>就是只有一个方法的接口, 所以可以提供一个lambda表达式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, (first, second) - &gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>

<p>在底层, <code>Arrays.sort()</code>方法会接收实现了<code>Comparator&lt;String&gt;</code>的某个类的对象. 在这个对象上调用<code>compare()</code>方法会执行这个lambda表达式的体. 这些对象和类的管理完全取决于具体实现, 与使用传统的内联类相比, 这样可能会高效许多. 我们可以将lambda表达式看作是一个函数, 而不是一个对象; 另外要接收lambda表达式可以传递到函数式接口, 这让lambda表达式很有吸引力. 具体的实现语法很简单, 下面就是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与使用实现了<code>ActionListener</code>接口的类相比, 这个代码的可读性要好得多.</p>
<p>实际上, 这就是Java中lambda表达式的上限了.</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>有时, 可能已经有现成的方法可以完成我们想要传递到其他代码的某个动作. 例如, 假设我们希望只要出现一个定时器事件就打印这个事件对象. 当然, 为此也可以调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure>

<p>但是, 如果直接把<code>println()</code>方法传递到<code>Timer</code>构造函数就好了. 实现方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br></pre></td></tr></table></figure>

<p>表达式<code>System.out::println</code>是一个方法引用(method reference), 它等价于lambda表达式<code>x -&gt; System.out.println(x)</code>.</p>
<h4 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h4><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h4><h4 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈<code>Comparator</code></h4><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是定义在另一个类中的类. 为什么需要使用内部类呢? 其主要原因有以下三点:</p>
<ol>
<li>内部类方法可以访问该定义所在的作用域中的数据, 包括私有的数据;</li>
<li>内部类可以对同一个包中的其他类隐藏起来;</li>
<li>当想要定义一个回调函数且不想编写大量代码时, 使用匿名(anonymous)内部类比较便捷.</li>
</ol>
<h4 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h4><p>内部类的语法比较复杂, 故我们选择用一个简单但不太实用的例子说明内部类的使用方法. 下面将进一步分析<code>TimerTest</code>示例, 并抽象出一个<code>TalkingClock</code>类. 构造一个语音时钟时需要提供两个参数: 发布通告的间隔和开关铃声的标志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkingClock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkingClock</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 并不是每一个<code>TalkingClock</code>对象中都有一个<code>TimePrinter</code>实例域. 只有在<code>TalkingClock</code>类中的方法构造了后它才存在.</p>
<p>下面是<code>TimePrinter</code>类的详细内容. 需要注意一点: <code>actionPerformer()</code>方法在发出铃声之前检查了<code>beep</code>标志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerPrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ActionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令人惊讶的事情发生了: 按理来说, <code>TimePrinter</code>类没有实例域或者名为<code>beep</code>的变量, 但<code>TimePrinter</code>中的方法还是调用了这个变量. 但真正令人惊讶的是, <strong>正是</strong><code>beep</code><strong>引用创建了</strong><code>TalkingClock</code><strong>对象中</strong><code>TimePrinter</code><strong>的域</strong>. 内部类既可以访问自身的数据域, 也可以访问创建它的外围类对象的数据域.</p>
<p>为了能够实现这个功能, 内部类的对象中总有一个隐式引用, 它指向了创建它的外部类对象.</p>
<p>外围类的的引用在构造函数中设置. 编译器修改了所有的内部类的构造函数, 添加一个外围类引用的参数. 因为<code>TimePrinter</code>类没有定义构造器, 所以编译器为这个类生成了一个默认的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TimerPrinter</span><span class="params">(TalkingClock clock)</span> &#123;</span><br><span class="line">    outer = clock;  <span class="comment">// 这里的outer是为了讲解方便而设置的引用. 实际编写的程序中没有这个东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面讨论一下内部类的访问权限问题. 如果有一个常规的<code>TimePrinter</code>类, 它需要调用<code>TalkingClock</code>类的公用方法访问变量<code>beep</code>; 但要是使用了内部类, 我们就不需要提供能够被公开访问的方法了.</p>
<p>下面是一个测试内部类的完整程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">innerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TalkingClock</span> <span class="variable">clock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TalkingClock</span>(<span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line">        clock.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit Program?&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkingClock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkingClock</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interval = interval;</span><br><span class="line">        <span class="built_in">this</span>.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>如果想要在内部类中调用外部类引用, 我们需要使用的语法还是有些复杂的. 表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.<span class="built_in">this</span></span><br></pre></td></tr></table></figure>

<p>表示外围类引用. 例如, 可以像下面这样编写<code>TimePrinter</code>内部类的<code>actionPerformed()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TalkingClock.<span class="built_in">this</span>.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来, 可以采用下列语法格式更加明确地编写内部对象的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>(construcion parameters)</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="built_in">this</span>.<span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br></pre></td></tr></table></figure>

<p>在这里, 最新构造的<code>TimePrinter</code>对象的外围类引用被设置为创建内部类对象的方法中的<code>this</code>引用. 这是一种最常见的情况. 通常, <code>this</code>限定词是多余的. 不过, 可以通过显式地命名将外围类引用设置为其他的对象. 比如, 如果<code>TimePrinter</code>是一个公有内部类, 对于任意的<code>TalkingClock</code>都可以构造一个<code>TimePrinter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TalkingClock</span> <span class="variable">jabberer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TalkingClock</span>(<span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line">TalkingClock.<span class="type">TimePrinter</span> <span class="variable">listener</span> <span class="operator">=</span> jabberer.<span class="keyword">new</span> <span class="title class_">TimerPrinter</span>();</span><br></pre></td></tr></table></figure>

<p>需要注意, 在外围类的作用域之外, 可以这样引用内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部类中声明的所有静态域都必须是<code>final</code>. 原因很简单: 我们希望一个静态域只有一个实例, 但对于每个外部对象, 大家会分别有一个单独的内部类实例. 如果这个域不是<code>final</code>的的话, 他可能就不是唯一的.<br>内部类中不能有<code>static</code>方法. 我们也不知道Java语言的设计者为何做出这种限制, 但是遵循就好了.</p>
</blockquote>
<h4 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h4><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><h4 id="由外部方法访问变量"><a href="#由外部方法访问变量" class="headerlink" title="由外部方法访问变量"></a>由外部方法访问变量</h4><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>本章的最后讨论一下代理(proxy). 利用代理可以在运行时创建一个实现了一组给定接口的新类. 这种功能只有在无法确定需要实现哪个接口时才有必要使用.</p>
<h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><p>人总会遇到错误的. 如果一个用户在运行程序期间遭遇了因程序错误或种种外部因素而导致的数据丢失, 他就有可能不会再使用这个程序了. 为了避免这类事情的发生, 至少应该做到以下几点:</p>
<ol>
<li>向用户通告错误;</li>
<li>保存所有的工作结果;</li>
<li>允许用户以妥善的形式退出程序.</li>
</ol>
<p>我们接下来就来学习如何做到这几点.</p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>大家都希望程序在出现错误时, 它能够采取一些理智的行为. 如果由于出现错误而使得欧协操作没有完成, 程序应该:</p>
<ol>
<li>返回到一种安全状态, 并能够让用户执行一些其他的命令;</li>
<li>允许用户保存所有操作的结果, 并以妥善的方式终止程序.</li>
</ol>
<p>讲真, 这并不容易. 毕竟检测(或引发)错误条件的代码通常举例那些能够让数据恢复到安全状态、或者能够保存用户的操作结果, 并正常推出程序的代码很远. 异常处理的任务就是将控制权从错误产生的位置转移到能够处理这种情况的错误处理器. 为了能够在程序中处理异常情况, 我们需要研究一下程序中可能出现的错误和问题, 以及哪类问题需要关注.</p>
<ol>
<li>用户输入错误: 除了那些不可避免的键盘输入错误外, 有些用户喜欢各行其是, 不遵循程序的要求. 例如, 假设有一个用户请求连接一个URL, 而语法却不正确. 在程序代码中应该对此进行检查, 如果没有检查, 网络层就会给出警告.</li>
<li>设备错误: 硬件并不总是那么충!성!, 也会时不时出问题;</li>
<li>物理限制: 磁盘满了, 可用存储空间已被用完;</li>
<li>代码错误: 程序方法有可能无法正确执行.</li>
</ol>
<p>对于方法中的一个错误, 传统的做法是返回一个特殊的错误码, 由调用方法分析; 但并不是在任何情况下都能够返回一个错误码的,  有可能无法明确地将有效数据与无效数据加以区分. 一个返回整型的方法就不能简单地通过返回-1表示错误, 因为-1很可能是一个完全合法的结果.</p>
<p>在Java中, 如果某个方法不能够采用正常的途径完成它的任务, 就可以通过另外一个路径退出方法. 在这种情况下, 方法并不返回任何值, 而是抛出(throw)一个封装了错误信息的对象, 方法本身也会立刻退出, 而调用这个方法的代码也无法继续执行. 取而代之的是异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler).</p>
<h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>在Java中, 异常对象都是<code>Throwable</code>类的子类. 甚至, 如果Java的内置类不够用, 用户还可以创建自己的异常类. 但需要注意的是, 虽然所有的异常都是从<code>Throwable</code>继承而来, 但是它们在下一层就立即分解为两个分支: <code>Error</code>和<code>Exception</code>.</p>
<p><code>Error</code>类层次结构描述了Java运行时系统的内部错误和资源耗尽错误. 应用程序不应该抛出这种类型的对象. 如果出现了这样的内部错误, 除了通告给用户并安全中止程序, 程序自己也做不了其他的事情了. 这种情况很少见.</p>
<p>在设计Java程序时, 需要关注<code>Exception</code>层次结构. 这个层次结构又再次分解为两个分支: 一个分支派生于<code>RuntimeException</code>, 另一个分支包含其他异常. 划分两个分支的规划是: 又程序错误导致的异常属于<code>RuntimeException</code>, 而程序本身没有问题, 但由于像I&#x2F;O错误这类问题导致的异常属于其他异常.</p>
<p>派生于<code>RuntimeException</code>的异常包含下面几种情况:</p>
<ol>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问<code>null</code>指针</li>
</ol>
<p>非<code>RuntimeException</code>的异常包括:</p>
<ol>
<li>试图在文件尾部后面读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找<code>Class</code>对象, 但这个字符串表示的类根本不存在.</li>
</ol>
<p>Java将派生于<code>Error</code>类或<code>RuntimeException</code>类的所有异常称为<strong>非受查</strong>(unchecked)异常, 并将其他所有的异常称为<strong>受查</strong>(checked)异常. 这是两个很有用的术语, 我们在后面还会频繁地用到它们.</p>
<h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>方法应该在其首部声明所有可能抛出的异常. 这样可以从首部反映出这个方法可能抛出哪类受查异常. 以<code>FileInputStream</code>类的一个构造函数的声明为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>

<p>这个声明表示这个构造函数将根据给定的<code>String</code>参数产生一个<code>FileInputStream</code>对象, 但也可能抛出一个<code>FileNotFouundException</code>异常. 如果该构造函数真的抛出了该类异常, 系统就会开始搜索异常处理器, 以便知道如何处理<code>FileNotFouundException</code>对象.</p>
<p>并不需要将所有有可能抛出的异常都进行声明. 至于何时应该使用<code>throws</code>声明异常, 何种异常值得被<code>throws</code>, 有如下四个标准可供参考:</p>
<ol>
<li>调用一个抛出受查异常的方法;</li>
<li>程序运行中发现错误, 并且利用<code>throws</code>语句抛出一个受查异常;</li>
<li>程序出现错误;</li>
<li>JVM和运行时的库出现的内部错误.</li>
</ol>
<p>如果出现前两种情况之一, 则必须告知调用该方法的程序员有可能抛出异常, 因为任何一个抛出异常的方法都有可能是一个死亡陷阱. 如果没有处理器捕获这个异常, 当前执行的现成就会结束.</p>
<p>对于那些可能被他人使用的Java方法, 应该根据<strong>异常规范</strong>(exception specification), 在方法的首部声明这个方法可能抛出的异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法有可能抛出多个受查异常类型, 那么就必须在方法的首部列出所有的异常类, 每个异常类之间用逗号隔开, 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundExceptoin, EOFException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 不需要声明Java的内部错误, 即从<code>Error</code>继承的错误. 任何程序代码都有抛出那些异常的潜能, 我们也无法控制它们.</p>
<p>同样地, 也不应该声明从<code>RuntimeException</code>继承的那些非受查异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawImage</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException &#123;   <span class="comment">// bad style</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些运行时错误完全在我们的控制之下. 如果特别关注数组下标引发的错误, 就应该将更多的时间花费在编写正确的程序上, 而不是等着程序运行出错.</p>
<p>总而言之, 一个方法必须声明所有可能抛出的<strong>受查异常</strong>, 而非受查异常要么不受控制(<code>Error</code>), 要么应当在编写过程中避免(<code>RuntimeException</code>). 如果方法没有声明所有可能发生的受查异常, 编译器就会报错.</p>
<p>当然, 从前面的示例中也可以知道: 除了声明异常, 我们还可以捕获异常. 这样会使异常不被抛到方法之外, 也不需要<code>throws</code>规范. 稍后我们就会了解到如何决定一个异常是被捕获, 还是被抛出让其他的处理器进行处理.</p>
<blockquote>
<p>注意: 如果在子类中覆盖了父类的一个方法, 子类方法中声明的受查异常不能比父类方法声明的异常更加通用(也就是说, 子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常). 这也意味着, 如果父类方法没有抛出任何受查异常, 子类方法也不能抛出任何受查异常.</p>
</blockquote>
<p>如果类中的一个方法声明将会抛出一个异常, 而这个异常是某个特定类的实例时, 则这个方法就有可能抛出一个这个类的异常, 或者这个类的任意一个子类的异常.</p>
<h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p>假设在程序代码中发生了一些很糟糕的事情: 一个名为<code>readData()</code>的方法正在读取一个首部具有下列信息的文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-length: <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>然而, 在读到733个字符之后文件就结束了. 我们认为这是一种不正常的情况, 希望抛出一个异常. 我们接下来就来研究一下如何抛出这个异常.</p>
<p>首先, 我们需要决定应该抛出什么类型的异常. 在阅读Java API文档之后我们会发现, 将上述异常归结为<code>IOException</code>下的<code>EOFException</code>是一种很好的选择. 文档将该类异常介绍为: “在输入过程中, 遇到了一个未预期的EOF(注: EOF, 即’End of File’, 指文件结尾)后的信号”. 下面是抛出异常的语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EOFException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>下面将这些代码放在一起:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">readDate</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext()) &#123;    <span class="comment">// EOF enountered</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>EOFException</code>类中还有含有一个字符串参数的构造器. 这个构造器可以更加细致的描述异常出现的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gripe</span> <span class="operator">=</span> <span class="string">&quot;Content-length: &quot;</span> + len + <span class="string">&quot;, Received: &quot;</span> + n;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(gripe);</span><br></pre></td></tr></table></figure>

<p>综上, 我们可以看出, 对于一个已经存在的异常类, 将其抛出非常容易, 只需:</p>
<ol>
<li>找到一个合适的异常类;</li>
<li>创建这个类的一个对象;</li>
<li>将对象抛出</li>
</ol>
<p>即可. 一旦方法抛出了异常, 这个方法就不可能返回到调用者, 我们也就不必为返回的默认值或错误代码担忧.</p>
<h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>如果标准异常类库中没有能够充分描述我们问题的异常, 我们就只能自己创建处于我们自己的异常. 我们需要做的是定义一个继承了<code>Exception</code>的类, 或者继承自<code>Exception</code>子类的类. 习惯上, 定义的类应该包含两个构造函数: 一个是默认的构造器, 另一个则是带有详细描述信息的构造类(如父类<code>Throwable</code>的<code>toString()</code>方法, 其能偶打印出输入的详细信息, 对我们进行调试工作十分有用).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以抛出自己定义的异常类型了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowTest</span> &#123;</span><br><span class="line">    String <span class="title function_">readDate</span><span class="params">(BufferedReader in)</span> <span class="keyword">throws</span> FileFormatException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &lt; len) </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileFormatException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>有些代码必须捕获异常, 而这需要进行周密的计划. 接下来我们就来介绍如何捕获异常.</p>
<h4 id="小·捕获异常"><a href="#小·捕获异常" class="headerlink" title="小·捕获异常"></a>小·捕获异常</h4><p>如果某个异常在发生时没有在任何地方进行捕获, 那程序就会中止执行, 并在控制台上打印出异常信息; 对于图形界面程序也有类似的过程.</p>
<p>想要捕获一个异常, 必须设置<code>try/catch</code>语句块. 最简单的<code>try</code>语句块如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    codes;</span><br><span class="line">    more codes;</span><br><span class="line">    more more codes;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="built_in">this</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>try</code>语句块中的任何代码抛出了一个在<code>catch</code>子句中说明的异常类, 那么</p>
<ol>
<li>程序将跳过<code>try</code>语句块的其余代码;</li>
<li>程序将执行<code>catch</code>子句中的处理器代码.</li>
</ol>
<p>如果在<code>try</code>语句块中的代码没有抛出任何异常, 程序将跳过<code>catch</code>子句.</p>
<p>如果方法中的任何代码抛出了一个在<code>catch</code>子句中没有声明的异常类型, 那么方法也会立刻退出.</p>
<p>下面是一个演示捕获异常的处理过程, 下面给出一个读取数据的典型代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// balabala</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然, 我们也可以不<code>catch</code>这个异常, 将异常扔给方法的使用者处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read1</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// balabalabala</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说, 我们应该捕获那些知道如何处理的异常, 而将那些不知道如何处理的异常继续进行传递. 但是, 如果编写一个覆盖父类的方法, 而这个方法有没有抛出异常, 则这个方法就只能捕获自己内部的异常.</p>
<h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><p>可在<code>try</code>语句块中捕获多个异常类型, 并针对不同类型的异常做出不同的处理.</p>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>在<code>catch</code>子句中可以再抛出一个异常, 这样做的目的是改变异常的类型. 如果开发了一个供其他程序员使用的子系统, 那么, 用于表示子系统故障的异常类型可能会产生多种解释. <code>ServletException</code>就是这样一个异常类型的例子. 执行<code>servlet</code>的代码可能不想知道发生错误的细节原因, 但希望明确地知道<code>servlet</code>是否有问题.</p>
<p>下面给出了捕获异常并将它再次抛出的基本方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the database</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里, <code>ServletException</code>用带有异常信息文本的构造函数来构造. 不过, 还有一种更好的处理方式, 并将原始异常设置为新异常的”原因”:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the database</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">se</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此, 在捕获到异常时, 就可以使用下面这条语句重新得到原始异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> se.getCause();</span><br></pre></td></tr></table></figure>

<p>强烈建议使用这种包装技术. 这样就能够让用户抛出子系统中的高级异常, 而不会丢失原始异常的细节.</p>
<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><p><code>finally</code>子句中的代码总是会被执行, 不论是否有异常被捕获. 这是一项很有用的语法, 尤其是在编写数据库程序的时候, 其能够确保与数据库的连接能够被恰当的关闭.</p>
<p>在下列代码中, 不论如何程序都会在最后关闭文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(...);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code>语句可以只有<code>finally</code>子句, 而没有<code>catch</code>子句.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论如何, <code>finally</code>子句中的代码都会被执行. 但是, 如果<code>try</code>子句中的代码抛出了一个异常, 必须有另外的<code>catch</code>将他捕获.</p>
<p>事实上, 我们认为在需要关闭资源时, 用这种方式使用<code>finally</code>子句是一种不错的选择.</p>
<blockquote>
<p>强烈建议解耦合<code>try/catch</code>和<code>try/finally</code>语句块. 这样可以提高代码的清晰度. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      in.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部的<code>try</code>语句块只有一个职责, 就是确保关闭输入流; 外部的<code>try</code>语句块也只有一个职责, 就是确保报告出现的错误. 这种方法除表达清晰外还有一个优点, 就是可以报告<code>finally</code>子句中出现的错误.</p>
<p>还需注意的是, 如果<code>try</code>和<code>finally</code>子句中均有<code>return</code>语句, 则<code>finally</code>子句中的<code>return</code>将覆盖掉<code>try</code>中的返回值.</p>
</blockquote>
<h4 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的<code>try</code>语句</h4><p>对于担心因关闭资源报错而丢失更有价值的异常信息的朋友们来说, Java提供了一个很有用的快捷方式. <code>AutoCloseable</code>接口中有一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>

<p>带资源的<code>try</code>语句(try-with-resources)的最简形式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>try</code>块退出时, 程序会自动调用<code>res.close()</code>. 下面是一个典型的例子, 我们读取了一个文件中的所有单词:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管这个块是正常退出了, 又或是发现了一个异常, 程序都会调用<code>in.close()</code>方法, 就好像使用了<code>finally</code>块一样.</p>
<p>还可以指定多个资源. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">     <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;out.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要是需要关闭资源, 我们就应该尽可能地使用带资源的<code>try</code>语句.</p>
<h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹(stack trace)是一个方法调用过程的列表, 它包含了程序执行过程中方法调用的特定位置. 我们在前面就已经见到它, 其在Java程序正常终止时就会显示出来.</p>
<p>可以调用<code>Throwable</code>类的<code>printStackTrace()</code>方法访问堆栈轨迹的文本描述信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out));</span><br><span class="line"><span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> out.toString();</span><br></pre></td></tr></table></figure>

<p>还有一种更加灵活的<code>getStackTrace()</code>方法, 它会得到<code>StackTraaceElement</code>对象的一个数组, 并可以在我们的程序中分析这个对象数组. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StackTraceElement</code>类中含有能够获得文件名和当前执行的代码行号的方法. 同时, 其还含有能够获得类名和方法名的方法. <code>toString()</code>方法将产生一个格式化的字符串, 其中包含所获得的信息.</p>
<p>静态的<code>Thread.getAllStackTrace()</code>方法能够产生所有线程的堆栈轨迹. 下面给出使用这个方法的具体方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line"><span class="keyword">for</span> (Thread t : map.keySet()) &#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个打印堆栈轨迹的例子: 如果计算<code>factorial(3)</code>, 将会打印下列内容:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">3</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">factorial(<span class="number">2</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">factorial(<span class="number">1</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">return <span class="number">1</span></span><br><span class="line">return <span class="number">2</span></span><br><span class="line">return <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stackTrace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;Enter n: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        </span><br><span class="line">        factorial(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factorial(&quot;</span> + n + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">        StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement f : frames) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;return &quot;</span> + r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><p>下面是几个使用异常机制的几个技巧.</p>
<h4 id="异常处理不能代替简单的测试"><a href="#异常处理不能代替简单的测试" class="headerlink" title="异常处理不能代替简单的测试"></a>异常处理不能代替简单的测试</h4><p>以退栈操作为例: 使用<code>isEmpty()</code>方法检测一个栈是否为空所需的时间远小于”尝试进行退栈操作却发现栈为空后抛出异常再捕获”的时间. <strong>只在异常情况下使用异常机制</strong>.</p>
<h4 id="不要过分地细化异常"><a href="#不要过分地细化异常" class="headerlink" title="不要过分地细化异常"></a>不要过分地细化异常</h4><h4 id="利用异常层次结构"><a href="#利用异常层次结构" class="headerlink" title="利用异常层次结构"></a>利用异常层次结构</h4><p>不要只抛出<code>RuntimeException</code>异常. 应该寻找更加适当的子类或创建自己的异常类.</p>
<p>不要只捕获<code>Thowable</code>异常, 否则, 会使程序代码更难读、更难维护. 考虑受查异常与非受查异常的区别. 已检查异常本来就很庞大, 不要为逻辑错误抛出这些异常.</p>
<p>将一种异常转换成另一种更加适合的异常时不要犹豫. 例如, 在解析某个文件中的一个整数时, 捕获’NumberFormatException’异常, 然后将它转换成<code>IOException</code>或<code>MySubsystemException</code>的子类.</p>
<h4 id="不要压制异常"><a href="#不要压制异常" class="headerlink" title="不要压制异常"></a>不要压制异常</h4><p>在Java中, 往往强烈地倾向于关闭异常. 如果编写了一个调用另一个方法的方法, 那么另一个方法就会时刻提醒编译器其有可能抛出异常, 不论这个可能性是大是小. 如果这个要抛出的异常根本无关紧要, 我们就可以关闭这个异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// codes threatening to throw checked exceptions</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// shut down</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此就可以顺利编译我们的代码了. 如果运行顺利, 那就运行顺利😅; 如果抛出异常, 它也会被自动忽略. 如果认为异常十分重要, 就应该在<code>catch</code>子块中为其进行处理.</p>
<h4 id="尽早抛出出现的异常"><a href="#尽早抛出出现的异常" class="headerlink" title="尽早抛出出现的异常"></a>尽早抛出出现的异常</h4><p>在用无效的参数调用一个方法时, 返回一个虚拟的数值, 还是抛出一个异常, 哪种处理方式更好? 例如, 在栈空时, <code>Stack.pop()</code>方法是返回一个<code>null</code>, 还是抛出一个异常? 我们认为: 在出错的地方抛出一个<code>EmptyStackException</code>异常要比在后面抛出一个<code>NullPointerException</code>异常更好.</p>
<h4 id="不要羞于传递异常"><a href="#不要羞于传递异常" class="headerlink" title="不要羞于传递异常"></a>不要羞于传递异常</h4><p>有些异常应当被传递给更高层次的使用者 ,不要羞于传递它们.</p>
<h3 id="断言的使用"><a href="#断言的使用" class="headerlink" title="断言的使用"></a>断言的使用</h3><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志API能够很好地帮助我们观察程序的运行过程. 记录日志API有着如下优点:</p>
<ol>
<li>可以很容易地取消全部日志记录, 或者仅仅取消某个级别的日志, 而且打开和关闭这个操作也很容易;</li>
<li>可以很简单地禁止日志记录的输出, 因此将这些日志代码留在程序中的开销很小;</li>
<li>日志记录可以被定向到不同的处理器, 用于在控制台中显示, 用于存储在文件中等;</li>
<li>日志记录器和处理器都可以对记录进行过滤. 过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项;</li>
<li>日志记录可以采用不同的方式格式化, 例如纯文本或XML;</li>
<li>应用程序可以使用多个日志记录器, 它们使用类似包名的这种具有层次结构的名字, 例如<code>com.mycompany.myapp</code>;</li>
<li>在默认情况下, 日志系统的配置由配置文件控制. 如果需要的话, 应用程序可以替换这个配置.</li>
</ol>
<h4 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h4><p>要生成简单的日志记录, 我们可以使用全局日志记录器(global logger)并调用其<code>info()</code>方法 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">&quot;File-&gt;Open menu item selected&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在<code>main()</code>方法开始的地方(或者其他适当的地方)调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().serLevel(Level.OFF);</span><br></pre></td></tr></table></figure>

<p>则所有的日志均会被取消.</p>
<h4 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h4><h4 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h4><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h4 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h4><h4 id="日志记录说明"><a href="#日志记录说明" class="headerlink" title="日志记录说明"></a>日志记录说明</h4><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p>泛型程序设计(generic programming)意味着编写的代码可以被很多不同类型的对象使用.</p>
<p>实际上, 在Java添加泛型类之前, 其中已经有了一个<code>ArrayList</code>类. 下面我们来看一下泛型程序设计的机制是如何演变的, 并进一步体会泛型对于用户和实现者来说的意义.</p>
<h4 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h4><p>在Java中增加泛型类之前, 泛型程序设计是利用继承实现的. <code>ArrayList</code>类只维护一个<code>Object</code>引用的数组:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有两个问题. 在获取一个值时必须进行强制类型转换是其一; 无法对保存进<code>ArrayList</code>的对象进行错误检查是其二.</p>
<p>但是泛型能够解决这两个问题, 因为其提供了一个更好的解决方案: 类型参数(type parameters). <code>ArrayList</code>类有一个类型参数用来指示元素的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>这让我们一看就知道这个<code>ArrayList</code>中装的是<code>String</code>对象.</p>
<blockquote>
<p>在Java SE 7及以后的版本中, 构造函数可以省略泛型类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>编译器也可以知道, 从此类<code>ArrayList</code>中提取出来的元素均应为<code>String</code>对象.</p>
<p>此外, 编译器还知道<code>ArrayList&lt;String&gt;</code>中的<code>add()</code>方法中有一个类型为<code>String</code>的参数. 这比使用<code>Object</code>类型的参数安全一些.</p>
<p>这就是类型参数的魅力: 让程序具有更好的可读性和安全性.</p>
<h4 id="谁想成为泛型程序员"><a href="#谁想成为泛型程序员" class="headerlink" title="谁想成为泛型程序员"></a>谁想成为泛型程序员</h4><p>实际上, 泛型的编写工作非常困难. 绝大多数程序员只是应用泛型这一工具, 而对泛型是如何实现的知之甚少. 后面将通过定义一个简单的泛型类向大家简单介绍泛型的编写方式和运作机制. 如果想要深入理解泛型, 还需要进一步阅读其他书籍.</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>一个泛型类(generic class)就是具有一个或多个类型变量的类. 本节使用一个简单的<code>Pair</code>类作为例子. 对于这个类来说, 我们只关注泛型, 对数据储存问题持无关心态度. 下面是<code>Pair</code>类的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        second = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pair</code>类引入了一个类型变量<code>T</code>, 用尖括号(<code>&lt;&gt;</code>)括起来, 并放在类名的后面. 泛型类可以有多个类型变量. 例如, 可以定义<code>Pair</code>类, 其中第一个域和第二个域使用不同的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> lcass Pair&lt;T, U&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T first;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型变量使用大写形式, 且比较短. 这是很常见的. 在Java库中, 通常使用变量<code>E</code>表示集合的元素类型, <code>K</code>和<code>V</code>分别表示表的关键字与值的类型. <code>T</code>(需要时还可用临近的字母<code>U</code>和<code>S</code>)表示”任意类型”.</p>
</blockquote>
<p>使用具体的类型替换类型变量就可以实例化泛型类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;</span><br></pre></td></tr></table></figure>

<p>可以将结果想象成带有构造器的普通类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;()</span><br><span class="line">Pair&lt;String&gt;(String, String)</span><br></pre></td></tr></table></figure>

<p>和方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFirst</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">String <span class="title function_">getSecond</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serFirst</span><span class="params">(String)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(String)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说, <strong>泛型类可看作普通类的工厂</strong>.</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面已经介绍了如何定义一个泛型类. 实际上, 还可以定义一个带有类型参数的简单方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArralAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在普通类中定义的, 而不是在泛型类中定义的. 然而, 这是一个泛型方法, 可以从尖括号和类型变量中看出这一点. 注意, 类型变量放在修饰符(这里是<code>public static</code>)的后面, 返回类型的前面.</p>
<p>泛型方法可以定义在普通类中, 也可以定义在泛型类中.</p>
<p>当调用一个泛型方法时, 在方法名前的尖括号中放入具体的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下(实际上也是大多数情况下), 方法调用中可以省略<code>&lt;String&gt;</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过偶尔也会出现一些问题, 比如下面这个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会委婉地指出, 解释这段代码有两种合法方法. 编译器通过将参数打包为一个<code>Double</code>和两个<code>Integer</code>对象, 然后共同寻找这些类的共同父类, 结果找到了两个符合条件的类: <code>Number</code>和<code>Comparable</code>接口, 其本身也是一个泛型类型. 解决方法就是将所有的参数写为<code>double</code>值.</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时, 类或方法需要对类型变量加以约束. 下面是一个典型的例子. 我们需要计算数组中的最小元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">smallest</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们真的这么写代码的话, 编译器会报错. 原因在于我们不能保证泛型<code>&lt;T&gt;</code>都实现了<code>Comparable</code>接口. 我们可以通过对类型变量<code>T</code>设置限定(bound)实现这一点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>事实上, <code>Comparable</code>接口本身就是一个泛型类型. 后面会具体讨论如何在<code>Comparable</code>接口中适当的使用类型参数.</p>
<p>现在, 泛型的<code>min</code>方法就只能被实现了<code>Comparable</code>接口的类的数组调用.</p>
<p>或许各位或有些奇怪——在此为什么使用关键字<code>extends</code>而不是<code>implements</code>? 毕竟, <code>Comparable</code>是一个接口. 实际上, <code>&lt;T extends BoundingType&gt;</code>表示<code>T</code>应该是绑定类型的<strong>子类型</strong>(subtype). <code>T</code>和绑定类型既可以是类, 也可以是接口. 选择关键字<code>extends</code>的原因是更接近子类的概念, 并且Java的设计者也不打算在语言中再添加新的关键字.</p>
<p>一个类型变量或通配符可以有多个限定, 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>限定类型用<code>&amp;</code>分隔, 而逗号用来分割类型变量.</p>
<p>在Java的继承中, 可以根据需要拥有多个接口超类型, 但限定中至多有一个类. 如果用一个类作为限定, 它必须是限定列表中的第一个.</p>
<p>下面重新编写了一个泛型方法<code>minmax</code>, 用于计算泛型数组的最大值和最小值, 并返回<code>Pair&lt;T&gt;</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LocalDate[] birthdays = &#123;</span><br><span class="line">                LocalDate.of(<span class="number">1906</span>, <span class="number">12</span>, <span class="number">9</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1815</span>, <span class="number">12</span>, <span class="number">10</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1903</span>, <span class="number">12</span>, <span class="number">3</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1900</span>, <span class="number">6</span>, <span class="number">22</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays);</span><br><span class="line">        System.out.println(<span class="string">&quot;min = &quot;</span> + mm.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + mm.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; Pair&lt;T&gt; <span class="title function_">minmax</span><span class="params">(T[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><ol>
<li>不能用基本类型实例化类型参数</li>
<li>运行时类型查询只适用于原始类型</li>
<li>不能创建参数化类型的数组</li>
<li><code>Varargs</code>警告</li>
<li>不能实例化类型变量</li>
<li>不能构造泛型数组</li>
<li>泛型类的静态上下文中类型变量无效</li>
<li>不能抛出或捕获泛型类的实例</li>
<li>可以消除对受查异常的检查</li>
<li>注意擦除后的冲突</li>
</ol>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>考虑一个类和子类, 如<code>Employee</code>和<code>Manager</code>, 那么<code>Pair&lt;Manager&gt;</code>和<code>Pair&lt;Employee&gt;</code>的一个子类吗? 不是的. 无论<code>S</code>与<code>T</code>之间有什么关系, 通常<code>Pair&lt;S&gt;</code>和<code>Pair&lt;T&gt;</code>之间都不会有什么联系.</p>
<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><p>固定的泛型类型系统使用起来并没有那么令人愉快, 这一点类型系统的研究人员已经知道一段时间了. Java的设计者设计了一种巧妙且安全的”解决方案”: 通配符类型. 我们接下来就来认识一下它.</p>
<h4 id="通配符的概念"><a href="#通配符的概念" class="headerlink" title="通配符的概念"></a>通配符的概念</h4><p>通配符类型中, 允许类型参数变化. 例如, 通配符类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt;</span><br></pre></td></tr></table></figure>

<p>表示任何泛型<code>Pair</code>类型, 其类型参数应为<code>Employee</code>的子类, 如<code>Pair&lt;Manager&gt;</code>, 但不是<code>Pair&lt;String&gt;</code>.</p>
<p>假设要编写一个打印雇员对的方法, 像这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">second</span> <span class="operator">=</span> p.getSecond();</span><br><span class="line">    System.out.println(first.getName() + <span class="string">&quot; and &quot;</span> + second.getName() + <span class="string">&quot; are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述, 不能将<code>pair&lt;Manager&gt;</code>传递给这个方法. 解决方法便是使用通配符类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span><br></pre></td></tr></table></figure>

<p>类型<code>Pair&lt;Manager&gt;</code>是<code>Pair&lt;? extends Employee&gt;</code>的子类型.</p>
<h4 id="通配符的父类型限定"><a href="#通配符的父类型限定" class="headerlink" title="通配符的父类型限定"></a>通配符的父类型限定</h4><p>通配符限定于类型变量限定十分类似, 但是, 还有以恶个附加的能力, 即可以指定一个父类型限定(supertype bound), 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="built_in">super</span> Manager</span><br></pre></td></tr></table></figure>

<p>这个通配符限制为<code>Manager</code>的所有父类型(已有的<code>super</code>关键字十分准确地描述了这种联系).</p>
<p>为什么要这样做呢? 带有超类型限定的通配符只能为方法提供参数, 而不能使用返回值.</p>
<p>下面是一个典型的示例: 有一个经理的数组, 并且想把奖金最高和最低的经理放在一个<code>Pair</code>对象中. <code>Pair</code>的类型是什么? 在这里, <code>Pair&lt;Employee&gt;</code>是合理的, <code>Pair&lt;Object&gt;</code>也是合理的. 下面的方法将可以接收任何适当的<code>Pair</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="built_in">super</span> Manager&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (max.getBonus() &gt; a[i].getBonus()) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直观地讲, 带有超类型的通配符可以像泛型对象写入, 带有子类型限定的通配符可以从泛型对象读取.</p>
<p>下面 是超类型限定的另一种应用. <code>Comparable</code>接口本身就是一个泛型类型. 声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此, 类型变量指示了<code>other</code>参数的类型. 例如, <code>String</code>类实现<code>Comparable&lt;String&gt;</code>, 它的<code>compareTo()</code>方法就被声明为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span></span><br></pre></td></tr></table></figure>

<p>通过在接口中使用泛型, 我们就避免了在使用<code>Object</code>类时出现的强制类型转换问题.</p>
<p>由于<code>Comparable</code>是一个泛型类型, 或许可以将<code>ArrayAlg</code>类的<code>min</code>方法做得更好一些? 可以这样声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure>

<p>看起来, 这样写比只使用<code>T extends Comparable</code>更彻底, 并且对许多类来讲, 工作得更好.</p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>还可以使用无限定的通配符, 例如<code>Pair&lt;?&gt;</code>. 乍看起来, 这好像与原始的<code>Pair</code>类型一样. 实际上, 有很大的不同. 类型<code>Pair&lt;?&gt;</code>有以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? getFirst()</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(?)</span></span><br></pre></td></tr></table></figure>

<p><code>getFirst()</code>的返回值只能赋给一个<code>Object</code>. <code>setFirst()</code>方法不能被调用, 甚至不能用<code>Object</code>调用. <code>Pair&lt;?&gt;</code>和<code>Pair</code>的不同在于: 可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setObject()</code>方法.</p>
<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><p>反射允许我们在运行时分析任意的对象. 如果对象是泛型类的实例, 关于泛型类型参数则得不到太多信息, 因为它们会被擦除. 在下面的小节中, 可以了解利用反射可以获得泛型类的什么信息.</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><h4 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h4><p>与现代的数据结构类库的常见情况一样, Java集合类库也将接口与实现分离. 首先, 我们看一下队列(queue)这一数据结构是如何分离的.</p>
<p>队列接口指出可以在队列的尾部添加元素, 在队列的头部删除元素, 并且可以查找队列中元素的个数. 当需要收集对象, 并按照”先进先出”的规则检索对象时就应该使用队列.</p>
<p>队列接口的最简形式可能会类似于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Quece</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有说明队列是如何实现的. 队列通常有两种实现方法: 一种是使用循环数组; 另一种是使用链表. 每一个实现都可以通过一个实现了<code>Queue</code>接口的类表示.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;    <span class="comment">// not an actual library class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    CircularArrayQueue(<span class="type">int</span> capacity) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;   <span class="comment">// not an actual library class</span></span><br><span class="line">    <span class="keyword">private</span> link head;</span><br><span class="line">    <span class="keyword">private</span> link tail;</span><br><span class="line"></span><br><span class="line">    LinkListQueue() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在程序中使用队列时, 一旦构建了集合就不需要知道究竟使用了哪种实现. 因此, 只有在构建集合对象时, 使用具体的类才有意义. 可以使用接口类型存放集合的引用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>利用这种方法, 一旦改变了想法, 就可以轻松地使用另外一种不同的实现. 只需要对程序的一个地方做出修改, 即调用构造器的地方. 如果觉得<code>LinkedListQueue</code>是个更好的选择, 就可以将代码修改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>为什么选择这种实现, 而不选择另一种实现呢? 接口本身并不能说明哪种实现的效率究竟如何. 循环数组比链表要高效, 因此多数人优先选择循环数组. 然而, 通常这样做也需要付出一定的代价.</p>
<p>循环数组是一个有限集合, 容量有限; 如果程序中要收集的对象数量没有上限, 则最好使用链表来实现.</p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h4><p>在Java类库中, 集合类的基本接口是<code>Collection</code>接口. 这个接口有两个基本方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这两个方法外, 还有几个方法, 稍后会继续介绍.</p>
<p><code>add()</code>方法用于向集合中添加元素. 如果添加元素确实改变了结合, 就返回<code>true</code>; 反之, 则返回<code>false</code>. 例如, 如果试图向集合中添加一个对象, 而这个对象在集合中已经存在, 这个添加请求就没有实效, 因为集合中不允许有重复的对象.</p>
<p><code>iterator()</code>方法用于返回一个实现了<code>Iterator</code>接口的对象. 可以使用这个迭代器对象依次访问集合中的元素.</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>Iterator</code>接口包含四个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consermer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反复调用<code>next()</code>方法, 可以逐个访问集合中的每个元素. 不过在调用之前, 还是需要使用<code>hasNext()</code>方法来检验是否可以继续执行<code>next()</code>方法. 如果想要查看集合中的所有元素, 就请求一个迭代器, 并在<code>hasNext()</code>返回<code>true</code>时反复地调用<code>next()</code>方法. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>for each</code>循环可以更加简练地表示同样的循环操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : c) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将<code>for each</code>循环简单地翻译为带有迭代器的循环.</p>
<p><code>for each</code>循环可以与任何实现了<code>Iterable</code>接口的对象一起工作, 这个接口只有一个抽象方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Collection</code>接口扩展了<code>Iterable</code>接口. 因此, 对于标准类库中的任何集合都可以使用<code>for each</code>循环.</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>数组的储存方式为在连续的存储位置上存放对象引用, 而<strong>链表</strong>则将对象存放在独立的结点中. 每个节点还存放着序列中下一个节点的引用. 在Java程序设计语言中, 所有链表实际上都是双向链接的, 即每个节点还存放着向前驱节点的引用.</p>
<p>由此, 从链表中间删除一个元素是一件很轻松的事情, 仅需要更新被删除元素附近的链接即可.</p>
<p>在下面的代码示例中, 先添加三个元素, 然后再将第二个元素删除:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> staff.iterator();</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> iter.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> iter.next();</span><br><span class="line">iter.remove();</span><br></pre></td></tr></table></figure>

<p>但是, 链表与泛型集合之间的最大区别, 就是链表是一个<strong>有序集合</strong>. 这意味着每个队形的位置十分重要.</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-12T13:12:09.000Z" title="2022/6/12 21:12:09">2022-06-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-19T06:29:31.430Z" title="2022/6/19 14:29:31">2022-06-19</time></span><span class="level-item">2 hours read (About 21150 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/12/java/">Java学习笔记</a></h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Java的工作方式"><a href="#Java的工作方式" class="headerlink" title="Java的工作方式"></a>Java的工作方式</h3><p>Java的目标是写出一个能在任何设备上运行的应用程序.</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>编写源代码文件.</p>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关.</p>
<h4 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机(JVM)"></a>Java虚拟机(JVM)</h4><p>通过Java虚拟机可以读取和执行字节码.</p>
<h3 id="要做的事"><a href="#要做的事" class="headerlink" title="要做的事"></a>要做的事</h3><p>编写源代码文件, 用javac编译程序, 并在某个Java虚拟机上执行编译过的字节码.</p>
<h3 id="Java的程序结构"><a href="#Java的程序结构" class="headerlink" title="Java的程序结构"></a>Java的程序结构</h3><p><strong>类</strong>存放在<strong>源文件</strong>中; <strong>方法</strong>存放在<strong>类</strong>中; <strong>语句</strong>存放在<strong>方法</strong>中.</p>
<h4 id="什么是源文件"><a href="#什么是源文件" class="headerlink" title="什么是源文件"></a>什么是源文件</h4><p>源文件(扩展名为<code>.java</code>)带有类的定义. 类用来表示程序的一个组件. 先程序或许只会有一个类. 类的内容必须包在花括号里面.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildInvite</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Frame</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Party at Tim&#x27;s!&quot;</span>);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;You bet&quot;</span>);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Shoot me&quot;</span>);</span><br><span class="line">        <span class="type">Panel</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">        p.add(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h4><p>类中带有一个或多个方法. 方法必须在类的内部声明.</p>
<h4 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h4><p>在方法的花括号中编写方法应该执行的指令. 方法代码是由一组语句所组成的, 可以把方法想象成是一个函数或过程.</p>
<h3 id="剖析类"><a href="#剖析类" class="headerlink" title="剖析类"></a>剖析类</h3><p>当Java虚拟机启动执行时, 它会寻找你在命令列所制定的类. 然后它会锁定一个向下面这样一个特定的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着Java虚拟机就会执行<code>main</code>方法在花括号间的所有指令. 每个Java程序可能会有很多类, 但是<code>main()</code>函数只能有一个.</p>
<h3 id="编写带有main-的类"><a href="#编写带有main-的类" class="headerlink" title="编写带有main()的类"></a>编写带有<code>main()</code>的类</h3><p>在Java中的所有东西都会属于某个类, 而<code>main()</code>是程序的七点. 不管有多少个类, 一定都会有一个<code>main()</code>来作为程序的起点.</p>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MyFirstApp.java</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><h3 id="main-中的常见方法"><a href="#main-中的常见方法" class="headerlink" title="main()中的常见方法"></a><code>main()</code>中的常见方法</h3><h4 id="声明、设定、调用方法等普通语句"><a href="#声明、设定、调用方法等普通语句" class="headerlink" title="声明、设定、调用方法等普通语句"></a>声明、设定、调用方法等普通语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dirk&quot;</span>;</span><br><span class="line">x = x * <span class="number">17</span>;</span><br><span class="line">System.out.print(<span class="string">&quot;x is &quot;</span> + x);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="comment">// 注释</span></span><br></pre></td></tr></table></figure>

<h4 id="反复做某事"><a href="#反复做某事" class="headerlink" title="反复做某事"></a>反复做某事</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x = x + <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x is now &quot;</span> + x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在适当条件下做某件事"><a href="#在适当条件下做某件事" class="headerlink" title="在适当条件下做某件事"></a>在适当条件下做某件事</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x must be 10&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x isn&#x27;t 10&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">3</span>) &amp; (name.equals(<span class="string">&quot;Dirk&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Gently&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;this line runs no matter what&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="重复与循环"><a href="#重复与循环" class="headerlink" title="重复与循环"></a>重复与循环</h3><p>Java中有三种循环结构: while循环、do-while循环和for循环. 我们先从while循环介绍起.</p>
<p>循环的关键在于条件测试. 在Java中, 条件测试的结果是<code>boolean</code>值——不是<code>true</code>就是<code>false</code>.</p>
<p>可以用<strong>比较运算符</strong>来执行简单的<code>boolean</code>值测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环能够顺利运行</span></span><br><span class="line">    <span class="comment">// 因为x确实大于3</span></span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> z= <span class="number">27</span>;</span><br><span class="line"><span class="keyword">while</span> (z == <span class="number">17</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环不能顺利运行</span></span><br><span class="line">    <span class="comment">// 因为z不等于17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他语言不同, Java中的<code>integer</code>与<code>boolean</code>两种类型并不相容, 故不能写出形如<code>while (i) &#123;...&#125;</code>之类的代码.</p>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>在Java中<code>if</code>与<code>while</code>循环都是<code>boolean</code>测试, 但功能不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x must be 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This runs no matter what&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以在程序中加入<code>else</code>条件, 实现真正的条件选择.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x must be 3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is NOT 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This runs no matter what&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开始编写程序——专家术语生成器"><a href="#开始编写程序——专家术语生成器" class="headerlink" title="开始编写程序——专家术语生成器"></a>开始编写程序——专家术语生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] wordListOne = &#123;&#125;;</span><br><span class="line">        String[] wordListTwo = &#123;&#125;;</span><br><span class="line">        String[] wordListThree = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">oneLength</span> <span class="operator">=</span> wordListOne.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">twoLength</span> <span class="operator">=</span> wordListTwo.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threeLength</span> <span class="operator">=</span> wordListThree.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rand1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * oneLength);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rand2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * twoLength);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rand3</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * threeLength);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">phrase</span> <span class="operator">=</span> wordListOne[rand1] + <span class="string">&quot; &quot;</span> + wordListTwo[rand2] + <span class="string">&quot; &quot;</span> + wordListThree[rand3];</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;What we need is a &quot;</span> + phrase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String数组"><a href="#String数组" class="headerlink" title="String数组"></a><code>String</code>数组</h4><p>编写该程序的第一步是创建出三个<code>String</code>数组, 也即保存术语的容器. 数组的声明和创建是很简单的, 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] pets = &#123;<span class="string">&quot;Fido&quot;</span>, <span class="string">&quot;Zeus&quot;</span>, <span class="string">&quot;Bin&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>每个元素放在引号中, 彼此间应以逗号隔开.</p>
<h4 id="数组长度获取"><a href="#数组长度获取" class="headerlink" title="数组长度获取"></a>数组长度获取</h4><p>为了在每个数组中能够随机地跳出一个单字, 我们需要得知每个数组的大小. 我们可以直接”询问”数组其长度:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> pets.length;</span><br></pre></td></tr></table></figure>

<p>执行后, <code>x</code>的值为3.</p>
<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>我们需要三个随机数. Java本身有一组立即可用的数学方法. <code>random()</code>方法会返回<strong>介于0和1之间</strong>的值, 所以我们呢需要将此值乘以数组的元素数量, 之后再取证.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">24.6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="组合字符串"><a href="#组合字符串" class="headerlink" title="组合字符串"></a>组合字符串</h4><p>我们可以用”<code>+</code>“运算符将字符串对象连接在一起. 使用索引数字可以将数组中的元素提取出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> pets[<span class="number">0</span>]; <span class="comment">// &quot;Fido&quot;</span></span><br><span class="line">s = s + <span class="string">&quot;&quot;</span> + <span class="string">&quot;is a dog!&quot;</span>; <span class="comment">// &quot;Fido is a dog!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="输出到屏幕"><a href="#输出到屏幕" class="headerlink" title="输出到屏幕"></a>输出到屏幕</h4><p>最后, 我们将结果输出到命令列上即可.</p>
<h2 id="拜访对象村"><a href="#拜访对象村" class="headerlink" title="拜访对象村"></a>拜访对象村</h2><p>我们要离开过程化的世界, 开始建立自己的对象.</p>
<h3 id="以对象来思考"><a href="#以对象来思考" class="headerlink" title="以对象来思考"></a>以对象来思考</h3><p>当我们设计类时, 要记得<strong>对象是靠类的模型塑造出来的</strong>, 即:</p>
<ol>
<li>对象是已知的事物</li>
<li>对象会执行的动作</li>
</ol>
<p>其中, <strong>对象本身已知的事物</strong>被称为<strong>实例变量(instance variable)</strong>, <strong>对象可以执行的动作</strong>被称为<strong>方法(methods)</strong>.</p>
<p>总而言之, <strong>类是对象的蓝图</strong>.</p>
<h3 id="创建你的第一个对象"><a href="#创建你的第一个对象" class="headerlink" title="创建你的第一个对象"></a>创建你的第一个对象</h3><p>要做到”会运用对象”, 我们需要两个类, 一个是被操作与对象的类, 另一个是用来测试该类的类. 后者常被命名为”受测类名称” + <code>TestDrive</code>.</p>
<h4 id="编写类"><a href="#编写类" class="headerlink" title="编写类"></a>编写类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    String breed;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ruff! Ruff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写测试用类"><a href="#编写测试用类" class="headerlink" title="编写测试用类"></a>编写测试用类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Dog源代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在测试用类中建立对象并存取对象的变量和方法"><a href="#在测试用类中建立对象并存取对象的变量和方法" class="headerlink" title="在测试用类中建立对象并存取对象的变量和方法"></a>在测试用类中建立对象并存取对象的变量和方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Dog源代码</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();  <span class="comment">// 建立并存取Dog对象</span></span><br><span class="line">        d.size = <span class="number">40</span>;        <span class="comment">// 调用Dog类的方法</span></span><br><span class="line">        d.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快离开main"><a href="#快离开main" class="headerlink" title="快离开main"></a>快离开<code>main</code></h3><p>真正的Java程序只会让对象与对象交互. 在Java程序中, <code>main()</code>有两种用处:</p>
<ol>
<li>测试真正的类</li>
<li>启动你的Java应用程序</li>
</ol>
<p>这里用一个例子展示Java程序如何”预览”以及对象和对象间如何互动.</p>
<h4 id="猜数字游戏"><a href="#猜数字游戏" class="headerlink" title="猜数字游戏"></a>猜数字游戏</h4><p>该游戏涉及到<code>game</code>与<code>player</code>两个对象. 其中, <code>game</code>会产生介于0~9之间的随机数字, 而3个player对象会猜测该数字.</p>
<p>类: <code>GuessGame.class</code>、<code>Player.class</code>和<code>GameLauncher.class</code>.</p>
<p>程序逻辑:</p>
<ol>
<li><code>GameLauncher</code>这个类带有<code>main()</code>方法, 是应用程序的入口点.</li>
<li><code>main()</code>中会创建出<code>GuessGame</code>对象, 并调用它的<code>startGame()</code>方法</li>
<li><code>startGame()</code>方法是游戏的起点. 它会创建三个<code>player</code>对象, 然后挑出要猜测的随机数字. 它会要求<code>player</code>猜测并检测结果, 过程会被列出来.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuessGame</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuessGame</span>();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guess</span><span class="params">()</span> &#123;</span><br><span class="line">        number = (<span class="type">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m guessing &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startGame</span><span class="params">()</span> &#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        p2 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        p3 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p1isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p2isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p3isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">targetNumber</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m thinking of a number between 0 and 9 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Number to guess is &quot;</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player one guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player two guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player three guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;We have a winner!&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player One got it right? &quot;</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player Two got it right? &quot;</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player Three got it right? &quot;</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Game is over.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Players will have to try again.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认识变量"><a href="#认识变量" class="headerlink" title="认识变量"></a>认识变量</h2><p>变量有两种: <strong>primitive主数据类型</strong>和<strong>引用</strong>.</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>为了让类型安全能够发挥作用, 我们必须声明所有变量的类型, 制定他是一个<code>int</code>类型或是一个<code>Dog</code>类型. 变量有两种: primitive主数据类型与对象引用. 其中, primitive主数据类型用来保存基本类型的值, 包括整数、布尔类型和浮点数等; 而对象引用保存的是对象的引用.</p>
<h3 id="primitive主数据类型"><a href="#primitive主数据类型" class="headerlink" title="primitive主数据类型"></a>primitive主数据类型</h3><p>primitive主数据类型有着不同的大小与名称, 如四种大小不同的整数类型<code>long</code>, <code>int</code>, <code>short</code>和<code>byte</code>.</p>
<h3 id="避开关键字"><a href="#避开关键字" class="headerlink" title="避开关键字"></a>避开关键字</h3><p>Java中的变量命名规则如下:</p>
<ol>
<li>名称必须以字母、下划线或$符号开头, 不能用数字开头</li>
<li>除了第一个字符, 变量名称的其他位置上都可以用数字</li>
<li>避开Java保留字</li>
</ol>
<h3 id="变量与对象"><a href="#变量与对象" class="headerlink" title="变量与对象"></a>变量与对象</h3><p>我们已经指导如何声明primitive主数据类型变量. 但是非primitive主数据类型的变量又该如何处理呢? 有以下要点:</p>
<ol>
<li>事实上没有”对象变量”这样的东西存在</li>
<li>只有**引用(reference)**到对象的变量</li>
<li>对象引用变量保存的是<strong>存取对象的方法</strong></li>
<li>它并不是对象的容器, 而是类似指向对象的指针, 或者可以说是地址.</li>
</ol>
<p>对象的声明、创建于幅值有三个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<h4 id="声明一个引用变量"><a href="#声明一个引用变量" class="headerlink" title="声明一个引用变量"></a>声明一个引用变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog</span><br></pre></td></tr></table></figure>

<p>要求Java虚拟机分配空间给引用变量, 并将变量命名为myDog.</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>要求Java虚拟机分配堆空间给新建立的<code>Dog</code>对象.</p>
<h4 id="连接对象和引用"><a href="#连接对象和引用" class="headerlink" title="连接对象和引用"></a>连接对象和引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>将新的<code>Dog</code>赋值给<code>myDog</code>这个引用变量.</p>
<h3 id="生活在垃圾处理堆上"><a href="#生活在垃圾处理堆上" class="headerlink" title="生活在垃圾处理堆上"></a>生活在垃圾处理堆上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="type">Book</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br></pre></td></tr></table></figure>

<p>声明两个<code>Book</code>的引用变量并创建两个<code>Book</code>对象, 然后将<code>Book</code>对象赋值给引用变量. 现在这两个<code>Book</code>对象储存在堆上.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br></pre></td></tr></table></figure>

<p>声明新的<code>Book</code>引用变量, 但不床啊金新的<code>Book</code>对象而将变量<code>c</code>的值赋值给变量<code>d</code>. 这表示”将<code>c</code>的字节组合拷贝给变量<code>d</code>“. 此时的<code>c</code>和<code>d</code><strong>引用到同一对象</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = b;</span><br></pre></td></tr></table></figure>

<p>将变量<code>b</code>的值拷贝给变量<code>c</code>. 此时, <code>b</code>和<code>c</code>两者都引用相同的对象.</p>
<h3 id="堆上的生与死"><a href="#堆上的生与死" class="headerlink" title="堆上的生与死"></a>堆上的生与死</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="type">Book</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br></pre></td></tr></table></figure>

<p>声明两个<code>Book</code>的引用变量并创建两个<code>Book</code>对象, 然后将<code>Book</code>对象赋值给引用变量. 现在这两个<code>Book</code>对象生活在堆上.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure>

<p>将变量<code>c</code>的值赋给变量<code>b</code>. 两个变量带有相同的值. 此时, 对象1被抛弃且能够作垃圾收集器(GC).</p>
<p>此时, 对象1已经没有引用, 称为无法存取的变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>将<code>null</code>值赋给<code>c</code>. 这代表它不再引用任何事物, 但还是可以被制定引用其他<code>Book</code>的引用变量.</p>
<p>对象2还引用到, 随意不能够作垃圾收集器.</p>
<h3 id="数组犹如杯架"><a href="#数组犹如杯架" class="headerlink" title="数组犹如杯架"></a>数组犹如杯架</h3><ol>
<li>声明一个<code>int</code>数组变量.<br><code>int[] nums;</code></li>
<li>创建大小为七的数组, 并将它赋值给之前声明为<code>int[]</code>的变量<code>nums</code>.<br><code>nums = new int[7];</code></li>
<li>赋予<code>int</code>数组的每一个元素一个<code>int</code>值.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">4</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">6</span>] = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数组也是对象"><a href="#数组也是对象" class="headerlink" title="数组也是对象"></a>数组也是对象</h4><p>数组能够让人使用位置索引来快速、随机地存取其中的元素.</p>
<p>注意, 在Java中, 一旦数组被声明出来, 我们就只能在其中装入所声明类型的元素.</p>
<h4 id="创建Dog数组"><a href="#创建Dog数组" class="headerlink" title="创建Dog数组"></a>创建<code>Dog</code>数组</h4><p>首先声明一个<code>Dog</code>数组变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog[] pets;</span><br></pre></td></tr></table></figure>

<p>创建大小为7的<code>Dog</code>数组, 并赋值给钱买你所声明出的<code>Dog[]</code>类型变量<code>pets</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">7</span>];</span><br></pre></td></tr></table></figure>

<p>创建新的<code>Dog</code>对象并将它们赋值给数组的元素.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pets[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">pets[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>如何存取<code>Dog</code>数组中的<code>Dog</code>对象? 我们只需要数组索引(位置)就可以操作 特定对象了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog[] myDogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">3</span>];</span><br><span class="line">myDogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">myDogs[<span class="number">0</span>].name = <span class="string">&quot;Fido&quot;</span>;</span><br><span class="line">myDogs[<span class="number">0</span>].bark();</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog1.bark();</span><br><span class="line">        dog1.name = <span class="string">&quot;Bart&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Dog[] myDogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        myDogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDogs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDogs[<span class="number">2</span>] = dog1;</span><br><span class="line"></span><br><span class="line">        myDogs[<span class="number">0</span>].name = <span class="string">&quot;Fred&quot;</span>;</span><br><span class="line">        myDogs[<span class="number">1</span>].name = <span class="string">&quot;Marge&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;last dog&#x27;s name is &quot;</span>);</span><br><span class="line">        System.out.println(myDogs[<span class="number">2</span>].name);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; myDogs.length) &#123;</span><br><span class="line">            myDogs[x].bark();</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says Ruff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法操作实例变量"><a href="#方法操作实例变量" class="headerlink" title="方法操作实例变量"></a>方法操作实例变量</h2><p>类所描述的是<strong>对象知道什么</strong>与<strong>执行什么</strong>. 任一类的每个实例都带有相同的方法, 但是方法可以根据实例变量的值来表现不同的行为. 我们可以通过给对象传值的方法控制对象的具体行为.</p>
<h3 id="传值给方法"><a href="#传值给方法" class="headerlink" title="传值给方法"></a>传值给方法</h3><p>程序中有两种参数, 即</p>
<ol>
<li>实参(argument)</li>
<li>形参(parameter)</li>
</ol>
<p>它们的主要区别在于: <strong>方法会运用形参, 调用的一方会传入实参.</strong></p>
<p>实参是传给方法的值; 当它传入方法后就成了形参.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">d.bark(<span class="number">3</span>);  <span class="comment">// 此处的&quot;3&quot;即为实参</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot; says Ruff!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(<span class="type">int</span> numOfBarks)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (numOfBarks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ruff&quot;</span>);</span><br><span class="line">        numOfBarks = numOfBarks - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从方法中获得返回值"><a href="#从方法中获得返回值" class="headerlink" title="从方法中获得返回值"></a>从方法中获得返回值</h3><p>方法可以有返回值, 也可以没有返回值. 被设定为<code>void</code>的方法无返回值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以指定一个方法的返回值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">giveSecret</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法声明有返回值, 就必须返回所声明类型的值.</p>
<h3 id="同时向方法传入多个参数"><a href="#同时向方法传入多个参数" class="headerlink" title="同时向方法传入多个参数"></a>同时向方法传入多个参数</h3><p>方法可以有多个参数. 在声明时需用逗号分开, 传入的时候也是用逗号分开, 并以正确数量、类型和顺序来传递参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestStuff</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStuff</span>();</span><br><span class="line">    t.takeTwo(<span class="number">12</span>, <span class="number">34</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">takeTwo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line">    System.out.println(<span class="string">&quot;Total is &quot;</span> + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将变量当作参数传入, 只要类型相符就可以.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    t.takeTwo(foo, bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">takeTwo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line">    System.out.println(<span class="string">&quot;Total is &quot;</span> + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java是<strong>通过值传递的</strong>, 也就是说<strong>通过拷贝传递</strong>.</p>
<h3 id="运用参数于返回类型"><a href="#运用参数于返回类型" class="headerlink" title="运用参数于返回类型"></a>运用参数于返回类型</h3><p><code>Getter</code>和<code>Setter</code>可让你执行<code>get</code>和<code>set</code>. <code>Getter</code>的目的只有一个, 就是返回实例变量的值; 而<code>Setter</code>的目的就是取用一个参数来设定实例变量的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElectricGuitar</span> &#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">int</span> numOfPickups;</span><br><span class="line">    <span class="type">boolean</span> rockStarUsesIt;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String aBrand)</span> &#123;</span><br><span class="line">        brand = aBrand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNumOfPickups</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfPickups;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNumOfPickups</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        numOfPickups = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">getRockStarUsesIt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rockStarUsesIt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRockStarUsesIt</span><span class="params">(<span class="type">boolean</span> yesOrNo)</span> &#123;</span><br><span class="line">        rockStarUsesIt = yesOrNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>在介绍封装前, 我们需要先介绍<strong>暴露</strong>, 即可以通过圆点运算符存取对象中的变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">27</span>;</span><br></pre></td></tr></table></figure>

<p>如此简单的存取方法可能会因使用者的不当操作导致实例变量被不当赋值, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;  <span class="comment">// 现实中哪有身高为0的猫呢</span></span><br></pre></td></tr></table></figure>

<p>所以我们需要创建<code>Setter</code>这个方法给所有的实例变量, 并寻求某种方法强制其他程序都必须通过<code>Setter</code>来设定变量而不是直接的存取.</p>
<p>注: 对封装优点的具体解释可以看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors">这里</a>.</p>
<p>有了<code>Setter</code>, 我们就可以防止<code>Cat</code>被设定成无法接收的高度.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> ht)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ht &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        height = ht;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h3><p>如何隐藏数据呢: 答案是使用公有与私有这两个存取修饰符(access modifier).</p>
<p>以下就是封装的基本原则: <strong>将你的实例变量标记为私有的(private), 并提供公有的(public)<code>getter</code>与<code>setter</code>来控制存取动作</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GoodDog</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodDog</span>();</span><br><span class="line">        one.setSize(<span class="number">70</span>);</span><br><span class="line">        <span class="type">GoodDog</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodDog</span>();</span><br><span class="line">        two.setSize(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog one: &quot;</span> + one.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog two: &quot;</span> + two.getSize());</span><br><span class="line">        one.bark();</span><br><span class="line">        two.bark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">14</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Ruff! Ruff!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yip! Yip!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中对象的方法"><a href="#数组中对象的方法" class="headerlink" title="数组中对象的方法"></a>数组中对象的方法</h3><p>数组中的对象就如同其他的对象一样, 唯一的差别就是: 数组中的对象需要用索引取得而已.</p>
<h3 id="声明与初始化实例变量"><a href="#声明与初始化实例变量" class="headerlink" title="声明与初始化实例变量"></a>声明与初始化实例变量</h3><p>实例变量永远都会有默认值. 如果我们没有明确的赋值给实列变量, 或者没有调用<code>setter</code>, 实例变量还是会有值.</p>
<table>
<thead>
<tr>
<th>实例变量类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>intergers</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>floating points</code></td>
<td><code>0.0</code></td>
</tr>
<tr>
<td><code>booleans</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>references</code></td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h3 id="实例变量与局部变量之间的差别"><a href="#实例变量与局部变量之间的差别" class="headerlink" title="实例变量与局部变量之间的差别"></a>实例变量与局部变量之间的差别</h3><h4 id="实例变量是声明在类内而不是方法中"><a href="#实例变量是声明在类内而不是方法中" class="headerlink" title="实例变量是声明在类内而不是方法中"></a>实例变量是声明在类内而不是方法中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">15.2</span>;   <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String breed;           <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="comment">// more code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量是声明在方法中的"><a href="#局部变量是声明在方法中的" class="headerlink" title="局部变量是声明在方法中的"></a>局部变量是声明在方法中的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddThing</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> a + b;  <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量在使用前必须初始化"><a href="#局部变量在使用前必须初始化" class="headerlink" title="局部变量在使用前必须初始化"></a>局部变量在使用前必须初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;  <span class="comment">// 无法编译</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的比较-primitive主数据类型或引用"><a href="#变量的比较-primitive主数据类型或引用" class="headerlink" title="变量的比较(primitive主数据类型或引用)"></a>变量的比较(primitive主数据类型或引用)</h3><p>如果我们想要知道两个primitive主数据类型是否相等, 只需要使用<code>==</code>运算符即可; 如果我们想要知道两个引用变量是否引用到堆上的同一个对象, 也是使用同样的方法即可. 但如果想要知道两个对象是否真的相等, 则需要使用<code>equals()</code>这个方法, 且相等的意义也需要视对象的类型而定.</p>
<h2 id="编写程序——以战舰游戏为例"><a href="#编写程序——以战舰游戏为例" class="headerlink" title="编写程序——以战舰游戏为例"></a>编写程序——以战舰游戏为例</h2><p>我们可以通过设计一个战舰游戏来讲解如何编写一个”真正的”Java程序.</p>
<p><strong>游戏目标</strong>: 以最少的猜测次数打掉计算机所安排的达康公司(Dot Com)网站. 计算机会根据你的表现来评分.</p>
<p><strong>初始设置</strong>: 程序启动后, 计算机会在虚拟的$7 \times 7$方格上安排三个达康网站. 安排完成后, 游戏会要求你开始猜坐标.</p>
<p><strong>进行游戏</strong>: 因为我们还没偶学到图形接口的程序设计, 所以这一版会在命令栏上进行. 计算机会提示你输入所猜测的位置(格子), 输入应为”A3”或”C5”等. 计算机会反馈命中”Hit”、脱靶”Miss”或击沉”Sunk”等回应. 当清楚所有的达康后, 计算机会列出得分情况.</p>
<h3 id="高层设计"><a href="#高层设计" class="headerlink" title="高层设计"></a>高层设计</h3><p>我们需要类和方法, 但是具体需要哪些类和方法呢? 我们需要通过明晰游戏流程来获得这些信息.</p>
<ol>
<li>玩家启动游戏<ol>
<li>计算机创建3个达康网站</li>
<li>将此3个达康网站停在虚拟战场上</li>
</ol>
</li>
<li>游戏开始, 重复下列操作直到全歼达康网站<ol>
<li>提示玩家输入坐标</li>
<li>检查命中情况</li>
</ol>
</li>
<li>游戏结束, 根据猜测次数打分</li>
</ol>
<h3 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h3><p>乍一看, 本程序需要两个类, 即<code>Game</code>类和<code>DotCom</code>类. 但是我们先编写一个简单的一维版游戏, 并将其命名为”Simple Dot Com Game”.</p>
<h3 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h3><p>当我们在创建Java的类以当作”学习经验”时, 程序会像下面这样:</p>
<ol>
<li>找出类应该做的事情</li>
<li>列出实例变量和方法</li>
<li>编写方法的伪码</li>
<li>编写方法的测试用程序</li>
<li>实现类</li>
<li>测试方法</li>
<li>除错或重新设计</li>
</ol>
<h4 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h4><p>伪码大致上包括三部分: <strong>实例变量的声明</strong>、<strong>方法的声明</strong>和<strong>方法的逻辑</strong>. 伪码最重要的部分是方法的逻辑, 因为它定义出会发生”什么事”. 这个部分会在稍后真正编写程序代码时转译成”如何”发生.</p>
<h4 id="为SimpleDotCom编写测试码"><a href="#为SimpleDotCom编写测试码" class="headerlink" title="为SimpleDotCom编写测试码"></a>为<code>SimpleDotCom</code>编写测试码</h4><p>在开始编写方法之前, 我们需要先写出测试方法用的程序代码. 这一概念来自极限编程方法论(XP), 该方法论帮助程序员更快写出程序代码.</p>
<p>我们首先写出<code>SimpleDotCom</code>对象的测试码. 对于该类而言, 我们关心的只有<code>checkYourself()</code>方法, 但为了让该方法正确运行, 我们还需要实现<code>setLocationCells()</code>方法以便让<code>checkYourself()</code>方法正确执行. 对于<code>checkYourself()</code>方法来说, 有如下几个部分需要进行测试:</p>
<ol>
<li><code>SimpleDotCom</code>对象的初始化</li>
<li>赋值位置(带有三个<code>int</code>的数组, 如<code>&#123;2,3,4&#125;</code>)</li>
<li>创建代表玩家猜想的字符串</li>
<li>传入伪造的玩家猜测以调用<code>checkYourself()</code>方法</li>
<li>列出结果以观察结果是否正确</li>
</ol>
<p><code>SimpleDotCom</code>的测试码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">dot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        dot.setLocationCells(locations);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userGuess</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> dot.checkYourself(userGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testResult</span> <span class="operator">=</span> <span class="string">&quot;failed&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">&quot;hits&quot;</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">&quot;passed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(testResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkYourself-方法"><a href="#checkYourself-方法" class="headerlink" title="checkYourself()方法"></a><code>checkYourself()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotCom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkYourself</span><span class="params">(String stringGuess)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> Integer.parseInt(stringGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;miss&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cell : locationCells) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123;</span><br><span class="line">                result = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line"></span><br><span class="line">                numOfHits++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHits == locationCells.length) &#123;</span><br><span class="line">            result = <span class="string">&quot;kill&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDotCom与SimpleDotComTester的最终版本"><a href="#SimpleDotCom与SimpleDotComTester的最终版本" class="headerlink" title="SimpleDotCom与SimpleDotComTester的最终版本"></a><code>SimpleDotCom</code>与<code>SimpleDotComTester</code>的最终版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">dot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        dot.setLocationCells(locations);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userGuess</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> dot.checkYourself(userGuess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotCom</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] locationCells;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfHits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocationCells</span><span class="params">(<span class="type">int</span>[] locs)</span> &#123;</span><br><span class="line">        locationCells = locs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkYourself</span><span class="params">(String stringGuess)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> Integer.parseInt(stringGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;miss&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cell : locationCells) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123;</span><br><span class="line">                result = <span class="string">&quot;hits&quot;</span>;</span><br><span class="line">                numOfHits++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHits == locationCells.length) &#123;</span><br><span class="line">            result = <span class="string">&quot;kill&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="游戏的main-方法"><a href="#游戏的main-方法" class="headerlink" title="游戏的main()方法"></a>游戏的<code>main()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numOfGuesses</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">GameHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameHelper</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">theDotCom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAlive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (isAlive == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">guess</span> <span class="operator">=</span> helper.getUserInput(<span class="string">&quot;enter a number&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">&quot;kill&quot;</span>)) &#123;</span><br><span class="line">                isAlive = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;You took &quot;</span> + numOfGuesses + <span class="string">&quot; guesses&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后一个类-GameHelper"><a href="#最后一个类-GameHelper" class="headerlink" title="最后一个类: GameHelper"></a>最后一个类: <code>GameHelper</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInput</span><span class="params">(String prompt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputLine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.print(prompt + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IOException: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于for循环"><a href="#关于for循环" class="headerlink" title="关于for循环"></a>关于<code>for</code>循环</h3><h4 id="基础for循环"><a href="#基础for循环" class="headerlink" title="基础for循环"></a>基础<code>for</code>循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会以如下方式解读这行代码:</p>
<ol>
<li>创建变量<code>i</code>并赋值为<code>0</code></li>
<li>只要<code>i</code>小于<code>100</code>就重复执行</li>
<li>在每趟城府过程最后把<code>i</code>加<code>1</code></li>
</ol>
<h4 id="加强版的for循环"><a href="#加强版的for循环" class="headerlink" title="加强版的for循环"></a>加强版的<code>for</code>循环</h4><p>自Java 5.0开始, Java就有了一种加强版的<code>for</code>循环, 能够很容易地逐个运行数组或其他集合(collection)的元素.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String name:nameArray) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会以如下方式解读这行代码:</p>
<ol>
<li>创建名称为<code>name</code>的<code>String</code>变量</li>
<li>将<code>nameArray</code>的第一个元素值赋给<code>name</code></li>
<li>执行重复的内容</li>
<li>赋值给下一个元素<code>name</code></li>
<li>重复执行直至所有元素都被运行为止</li>
</ol>
<h2 id="认识Java的API"><a href="#认识Java的API" class="headerlink" title="认识Java的API"></a>认识Java的API</h2><h3 id="ArrayList的操作"><a href="#ArrayList的操作" class="headerlink" title="ArrayList的操作"></a><code>ArrayList</code>的操作</h3><p>创建:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Egg&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Egg&gt;();</span><br></pre></td></tr></table></figure>

<p>加入元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Egg</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Egg</span>();</span><br><span class="line">myList.add(s);</span><br></pre></td></tr></table></figure>

<p>再加入元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Egg</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Egg</span>();</span><br><span class="line">myList.add(b);</span><br></pre></td></tr></table></figure>

<p>查询大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">theSize</span> <span class="operator">=</span> myList.size();</span><br></pre></td></tr></table></figure>

<p>查询特定元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isIn</span> <span class="operator">=</span> myList.contains(s);</span><br></pre></td></tr></table></figure>

<p>查询特定元素的位置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> myList.indexOf(b);</span><br></pre></td></tr></table></figure>

<p>判断几何是否为空:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> myList.isEmpty();</span><br></pre></td></tr></table></figure>

<p>删除元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myList.remove(s);</span><br></pre></td></tr></table></figure>

<h3 id="使用函数库-Java-API"><a href="#使用函数库-Java-API" class="headerlink" title="使用函数库(Java API)"></a>使用函数库(Java API)</h3><p>在Java的API中, 类被包装在包中. 要使用API中的类, 我们必须知道他被放在哪个包中.</p>
<p>在使用API时, 我们必须知名程序代码中所用到的类的完整名称, 如<code>java.util.ArrayList</code>; 同时, 必须告诉Java使用的到底是哪个<code>ArrayList</code>. 你可以每次使用的时候都把包名打完整, 也可以直接<code>import</code>, 省时省力:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h3 id="继承的运行方式"><a href="#继承的运行方式" class="headerlink" title="继承的运行方式"></a>继承的运行方式</h3><p>在设计继承时, 我们将共同的程序代码放在某个类中, 然后告诉其他的类, 说此类是它们的父类. 当某个类集成了另一个类的时候, 也就是子类继承自父类. 用Java的方式说, 这是”子类继承父类”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> worksAtHospital;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamliyDoctor</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> makesHouseCalls;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveAdvice</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Surgeon</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeIncision</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承层次的设计——以设计动物仿真程序为例"><a href="#继承层次的设计——以设计动物仿真程序为例" class="headerlink" title="继承层次的设计——以设计动物仿真程序为例"></a>继承层次的设计——以设计动物仿真程序为例</h3><p>假设要设一个仿真系统程序, 可以让用户设定将一群动物丢到某种环境中以观察会发生什么事情.</p>
<p>我们已经被告知一部分会用的动物(狮子、河马、老虎、狗、猫和狼), 但是并不知道以后还会有多少中动物会被加进来. 每一个动物都会用一个对象来表示, 且动物会在环境中活动, 执行任何被设计的行为.</p>
<p>我们首先要辨别出所有动物都有的、抽象的共同特征, 然后以这些共同特征设计出能够让所有动物加以扩充的类.</p>
<h4 id="找出具有共同属性和行为的对象"><a href="#找出具有共同属性和行为的对象" class="headerlink" title="找出具有共同属性和行为的对象"></a>找出具有共同属性和行为的对象</h4><p>狮子、河马、老虎、狗、猫和狼间各有什么异同? 这些类型又有什么相关性?</p>
<h4 id="设计代表共同状态与行为的类"><a href="#设计代表共同状态与行为的类" class="headerlink" title="设计代表共同状态与行为的类"></a>设计代表共同状态与行为的类</h4><p>我们有五个实例变量:</p>
<ol>
<li><code>picture</code>: 动物JPEG图像的名称</li>
<li><code>food</code>: 此动物所吃的食物</li>
<li><code>hunger</code>: 代表饥饿程度的<code>int</code>值</li>
<li><code>boundaries</code>: 代表动物活动范围区域的长宽</li>
<li><code>location</code>: 动物在活动区域中的X与Y坐标</li>
</ol>
<p>还有四个方法:</p>
<ol>
<li><code>makeNoise()</code>: 动物发出声音的行为程序</li>
<li><code>eat()</code>: 动物遇到事物时的行为程序</li>
<li><code>sleep()</code>: 睡眠的行为程序</li>
<li><code>roam()</code>: 不再进食或睡眠时的行为程序</li>
</ol>
<p>由于六个动物都是动物, 我们可以用<code>Animal</code>作为共同父类的名称.</p>
<h4 id="决定子类是否需要让某项行为有特定不同的运作方式"><a href="#决定子类是否需要让某项行为有特定不同的运作方式" class="headerlink" title="决定子类是否需要让某项行为有特定不同的运作方式"></a>决定子类是否需要让某项行为有特定不同的运作方式</h4><p>再仔细考虑后, 我们认为, <code>eat()</code>和<code>makeNoise()</code>应该由各个子类自行覆盖.</p>
<h4 id="通过寻找使用共同行为的子类来找出更多抽象化的机会"><a href="#通过寻找使用共同行为的子类来找出更多抽象化的机会" class="headerlink" title="通过寻找使用共同行为的子类来找出更多抽象化的机会"></a>通过寻找使用共同行为的子类来找出更多抽象化的机会</h4><p>我们观察到<code>Wolf</code>和<code>Dog</code>间、<code>Lion</code>、<code>Tiger</code>和<code>Cat</code>间有某些共同的行为.</p>
<h4 id="完成类的继承层次"><a href="#完成类的继承层次" class="headerlink" title="完成类的继承层次"></a>完成类的继承层次</h4><p>我们使用全科和猫科动物的分类来做出<code>Canine</code>和<code>Feline</code>两个类. 每个类中都有各自的<code>roam()</code>方法.</p>
<h4 id="调用哪个方法"><a href="#调用哪个方法" class="headerlink" title="调用哪个方法?"></a>调用哪个方法?</h4><p>当调用对象引用的方法时, 我们会调用到与该对象类型最接近的方法.</p>
<h4 id="子类能够继承哪些东西"><a href="#子类能够继承哪些东西" class="headerlink" title="子类能够继承哪些东西?"></a>子类能够继承哪些东西?</h4><p>子类可以继承父类的成员, 但父类可以通过<strong>存取权限</strong>决定子类是否能够继承某些特定的成员. 此处只介绍如下所示的四种存取权限, 其限制程度从左到右依次降低:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">default</span> <span class="keyword">protected</span> <span class="keyword">public</span></span><br></pre></td></tr></table></figure>

<p><code>private</code>类型的成员不会被继承, 而<code>public</code>类型的成员会被继承.</p>
<h4 id="使用继承的几个条件"><a href="#使用继承的几个条件" class="headerlink" title="使用继承的几个条件"></a>使用继承的几个条件</h4><ol>
<li>当某个类比其父类更具有特定意义时使用继承</li>
<li>在行为程序(实现程序代码)应该被多个相同基本类型类所共享时, 应考虑使用继承</li>
<li>继承有时候并不是达成重用行为程序的最佳方式</li>
<li>如果两者间不能通过IS-A测试就不要应用继承关系. 一定要确定子类是父类一种更特定的类型才可以</li>
</ol>
<h4 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h4><p>通过设计继承的过程我们可以累计面向对象的经验. 通过提取出一组类间共同的抽象性, 我们能够排除掉重复的程序代码而将这个部分放在父类中.</p>
<ol>
<li>避免了重复的程序代码</li>
<li>定义出共同的协议</li>
</ol>
<p>继承可以确保某个父型之下的所有类都有父型所持有的全部方法, 也就是说, <strong>我们会通过继承来定义相关类间的共同协议</strong>.</p>
<p>当我们定义出一组类的父型时, 我们可以用子型的任何类来填补任何需要或期待父型的位置.</p>
<h3 id="多态的运行"><a href="#多态的运行" class="headerlink" title="多态的运行"></a>多态的运行</h3><p>若要观察多态是如何运行的, 我们就需要先复习一下一般声明引用和创建对象的方法:</p>
<ol>
<li>声明一个引用变量</li>
<li>创建对象</li>
<li>连接对象和引用</li>
</ol>
<p>重点在于, 引用类型与对象的类型必须相符.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>但是在<strong>多态</strong>下, <strong>引用与对象可以是不同的类型</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p><strong>运用多态时, 引用类型可以是实际对象类型的父类</strong>. 当我们声明一个引用变量时, 任何对该引用变量类型可通过IS-A测试的对象都可以被赋值给该引用. 换句话说, 任何<code>extends</code>过声明引用变量类型的对象都可以被赋值给这个引用变量. 这样我们就可以创建出多态数组一类的东西.</p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明Animal类型的数组</span></span><br><span class="line">Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 但我们可以放任何Animal类的子类进去</span></span><br><span class="line">animals[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animals[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">animals[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">animals[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">animals[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Lion</span>();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 我们可以将数组的元素调出来当作Animal对象来操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">    animals[i].eat();</span><br><span class="line">    animals[i].roam();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数和返回类型也可以多态</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveShot</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PetOwner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Vet</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vet</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">        v.giveShot(d);  <span class="comment">// 执行Dog的makeNoise()</span></span><br><span class="line">        v.giveShot(h);  <span class="comment">// 执行Hippo的makeNoise()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将程序代码编写成使用多态参数的程序, 即将参数声明成父类类型, 我们就可以在运行时传入任何的子类对象; 此外, 在引进新子类后, 我们也不必修改以前的程序.</p>
<p>如果你想<strong>放置某个类被做出子类</strong>, 有三种方法可供选择:</p>
<ol>
<li>进行存取控制</li>
<li>使用<code>final</code>修饰符——它表示这里是继承树的末端, 不能被继承</li>
<li>让类只拥有<code>private</code>的构造程序(constructor)</li>
</ol>
<h3 id="覆盖的规则"><a href="#覆盖的规则" class="headerlink" title="覆盖的规则"></a>覆盖的规则</h3><p>如果想要在子类中覆盖掉父类中的某些方法, 我们需要先遵守以下规则:</p>
<ol>
<li>参数必须相同, 且返回类型必须要兼容</li>
<li>不能降低方法的存取权限</li>
</ol>
<h3 id="方法的重载-Overload"><a href="#方法的重载-Overload" class="headerlink" title="方法的重载(Overload)"></a>方法的重载(Overload)</h3><p>重载的意义是<strong>两个方法的名称相同, 但参数不同</strong>. 这也是其与多态的区别所在.</p>
<p>重载可以有同一方法的多个不同参数版本以方便调用. 它有着下列特点:</p>
<ol>
<li>返回类型可以不同</li>
<li>不能只改变返回类型</li>
<li>可以更改存取权限</li>
</ol>
<p>下面是一个合法的重载范例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloads</span> &#123;</span><br><span class="line">    String uniqueID;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">addNum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUniqueID</span><span class="params">(String theID)</span> &#123;</span><br><span class="line">        uniqueID = theID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUniqueID</span><span class="params">(<span class="type">int</span> ssNumber)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + ssNumber;</span><br><span class="line">        setUniqueID(numString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p><strong>继承只是个开始</strong>. 要使用多态, 我们还需要接口. 我们需要超越简单的继承并前进到只有通过设计与编写接口规格才能达成的适应性与扩展性. 到底<strong>接口</strong>是什么呢? 它是一种<strong>100%纯抽象的类</strong>. 什么是<strong>抽象类</strong>? 它是<strong>无法初始化的类</strong>.</p>
<h3 id="有些类不该初始化"><a href="#有些类不该初始化" class="headerlink" title="有些类不该初始化"></a>有些类不该初始化</h3><p>在前面的章节中, 我们为了介绍继承的概念写了一个仿真动物行为的例子. 在这个例子中, 我们通过继承<code>Animal</code>类建立了具体的动物类, 并以此创建了各动物类的对象. 但是, 如果我们要创建<code>Animal</code>类的对象, 会发生什么呢?</p>
<p>答案是不会发生什么. 但是, 这个世界上毕竟没有叫做”动物”的动物, 我们硬要把它当作对象创建出来也毫无意义; 但是我们又需要<code>Animal</code>类来继承和产生多态. 但是要限制只有它的子类才能被初始化.</p>
<p>在Java中, 通过标记类为抽象类, 编译器就知道这个类不能被初始化, 即被<code>new</code>出来. 具体实施方法就是在类的声明前面加上抽象类关键词<code>abstract</code>即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Canine</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roam</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设计好继承结构后, 我们必须要决定哪些类是抽象的, 哪些又是具体的. 抽象类除了被继承之外, 是没有用途、没有值且没有目的的.</p>
<h3 id="抽象的方法"><a href="#抽象的方法" class="headerlink" title="抽象的方法"></a>抽象的方法</h3><p>除了类之外, 我们也可以将方法标记为<code>abstract</code>的. 抽象的类代表此类必须要被<code>extend</code>过, <strong>抽象的方法代表此方法一定要被覆盖过</strong>.</p>
<p><strong>抽象的方法没有实体</strong>, 所以抽象方法的代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 没有方法体, 直接以分号结束</span></span><br></pre></td></tr></table></figure>

<p>如果我们声明了一个抽象的方法, 我们就必须<strong>将包含这个方法的类表姐为抽象的</strong>.</p>
<p>此外, <strong>我们必须实现所有抽象的方法</strong>.</p>
<h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p>假设我们不知道有<code>ArrayList</code>这种类而想要自行编写维护<code>list</code>的类以保存<code>Dog</code>对象. 在第一轮我们指挥写出<code>add()</code>方法. 我们使用大小为五的简单<code>Dog</code>数组<code>Dog[]</code>来保存新加入的<code>Dog</code>对象. 当<code>Dog</code>对象超过五个时, 我们还是可以调用<code>add()</code>方法, 但是什么都不会发生. 如果没有越界, <code>add()</code>会把<code>Dog</code>装到可用的数组位置中, 然后递增可用索引<code>nextIndex</code>.</p>
<h4 id="自创Dog专用的list"><a href="#自创Dog专用的list" class="headerlink" title="自创Dog专用的list"></a>自创<code>Dog</code>专用的<code>list</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDogList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex &lt; dogs.length) &#123;</span><br><span class="line">            dogs[nextIndex] = d;</span><br><span class="line">            System.out.println(<span class="string">&quot;Dog added at &quot;</span> + nextIndex);</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="还要给Cat用"><a href="#还要给Cat用" class="headerlink" title="还要给Cat用?"></a>还要给<code>Cat</code>用?</h4><p>如果我们发现现在还要写一个给<code>Cat</code>用的<code>list</code>, 我们是另外单独创建一个<code>MyCatList</code>类; 还是创建一个单独的<code>DogAndCat</code>类, 用<code>addCat(Cat c)</code>与<code>addDog(Dog d)</code>来同时处理两个不同的数组实例呢?</p>
<p>都不是. 我们编写一个不同的<code>AnimalList</code>类让它处理<code>Animal</code>所有的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnimalList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex &lt; animals.length) &#123;</span><br><span class="line">            animals[nextIndex] = a;</span><br><span class="line">            System.out.println(<span class="string">&quot;Animal added at &quot;</span> + nextIndex);</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果要为所有类写一个list呢"><a href="#如果要为所有类写一个list呢" class="headerlink" title="如果要为所有类写一个list呢?"></a>如果要为所有类写一个<code>list</code>呢?</h4><p>如果要为所有类写一个这样的<code>list</code>, 我们就需要为所有的类找到一个父类. 但是, 真的有这样的类吗?</p>
<p>实际上是有的, 这个类就是<code>Object</code>类.</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a><code>Object</code>类</h3><p>在Java中, 所有的类都是从<code>Object</code>这个类中继承下来的. <code>Object</code>类是所有类的源头, 是所有类的父亲.</p>
<h4 id="终极对象中都有什么"><a href="#终极对象中都有什么" class="headerlink" title="终极对象中都有什么?"></a>终极对象中都有什么?</h4><ol>
<li><code>equals(Object o)</code>: 检测两个对象是否是”相等”的</li>
<li><code>getClass()</code>: 告诉使用者对象是从哪里被初始化的</li>
<li><code>hashCode()</code>: 返回对象的哈希值</li>
<li><code>toString()</code>: 列出类的名称和一个我们并不关系的数字</li>
</ol>
<h4 id="那么-代价是什么呢"><a href="#那么-代价是什么呢" class="headerlink" title="那么, 代价是什么呢?"></a>那么, 代价是什么呢?</h4><p>在开始以<code>Object</code>类型使用所有适用性参数和返回类型之前, 我们应该考虑到使用<code>Object</code>类型作为引用的一些问题. 此处并不涉及制作出<code>Object</code>类型的实例, 这是在说以<code>Object</code>类型作为引用的其他类型.</p>
<p>当我们将对象装进<code>ArrayList&lt;Dog&gt;</code>中时, 它会被当作<code>Dog</code>来输入与输出; 但若你把它声明成<code>ArrayList&lt;Object&gt;</code>时会怎样? 如果我们创造出一个可以保存任何一种对象的<code>ArrayList</code>, 并尝试将<code>Dog</code>对象取出并赋值给<code>Dog</code>的引用时会发生什么事?</p>
<p>答案是<strong>无法通过编译</strong>. <strong>任何从<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用而不管它原来是什么</strong>.</p>
<p>如果想要将被编译器看作是<code>Object</code>类的<code>Dog</code>对象转回来, 我们可以从<code>Object</code>中拷贝出一个<code>Dog</code>引用, 并将其赋值给<code>Dog</code>引用变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> al.get(index);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) <span class="number">0</span>;</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure>

<p>如果你不能确定他是<code>Dog</code>, 我们可以用<code>instanceof</code>这个运算符来检查. 如果类型抓换错了, 程序会弹出ClassCastException异常并终止程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此, Java中引用变量的类型的重要性可见一斑. 我们只能在引用变量的类确实有该方法时才能够调用它.</p>
<p>但是, 如果我们想要在某个已经继承了一个父类的类中再引入其他类的功能呢? 我们要再继承一个父类的内容吗? 显然是不行的, 因为如果两个父类中有名称相同的方法的话, 子类会不知道究竟应该继承哪一个. 实际上, Java也不支持继承两个父类的方法. Java提供的解决方式为: 接口.</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口(interface)是专为解决上述情况而生的. 它采用的方法也很简单: 将全部的方法都设为抽象的.</p>
<p>由此我们知道, 应该如下定义一个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">beFriendly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现一个接口的话, 应该编写如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Canine</span> <span class="keyword">implements</span> <span class="title class_">Pet</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>相比继承, 接口还有一个特点, 即<strong>不同继承树的类也可以实现相同的接口</strong>. 当我们把一个类当作是多态类型运用时, 相同的类型必定来自同一个继承树; 但当我们用接口来作为多态类型时, 对象就可以来自任何地方了.</p>
<p>此外, <strong>类还可以实现多个接口</strong>, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Pet</span>, Saveable, Paintable &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断应该设计类、子类、抽象类还是接口呢"><a href="#如何判断应该设计类、子类、抽象类还是接口呢" class="headerlink" title="如何判断应该设计类、子类、抽象类还是接口呢"></a>如何判断应该设计类、子类、抽象类还是接口呢</h3><ol>
<li>如果新的类无法对其他的类通过IS-A测试时, 就设计不继承其他类的类;</li>
<li>只要在需要某类的特殊化版本时, 以覆盖或增加新的方法来继承现有的类;</li>
<li>当你需要定义一群子类的模板, 又不想让程序员初始化此模板时, 设计出抽象的类给它们用;</li>
<li>如果想要定义出类可以扮演的角色, 使用接口.</li>
</ol>
<h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><p><code>super</code>关键字能够实现在子类中调用父类方法的功能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Report</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">runReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设计报告</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title class_">Report</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">runReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.runReport();  <span class="comment">// 调用父类方法</span></span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buzzwordCompliance</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h2><h3 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h3><p>在Java中, 内存被分为两种区域: 对象的生存空间<strong>堆</strong>(heap)以及方法调和变量的生存空间<strong>栈</strong>(stack). 注意: 并不是所有变量都生活在栈中. 变量分为实例变量和局部变量. 实例变量是被声明在类而不是方法中的变量, 它们被存储于所述的对象中; 局部变量, 又称栈变量, 被声明在方法中. 只有局部变量(栈变量)被储存在栈中, 其余变量均被储存在堆中.</p>
<h4 id="栈上的方法"><a href="#栈上的方法" class="headerlink" title="栈上的方法"></a>栈上的方法</h4><p>当我们调用一个方法时, 该方法会被放在调用栈的栈顶. 实际被堆上栈的是堆栈块, 它带有方法的状态.</p>
<h4 id="栈上的对象引用"><a href="#栈上的对象引用" class="headerlink" title="栈上的对象引用"></a>栈上的对象引用</h4><p>非primitive变量保存的只是对象的引用, 而不是对象本身. 故只有保存引用的变量自己被放在了栈上; 对象自己是在堆中待着的.</p>
<h4 id="堆上的实例变量"><a href="#堆上的实例变量" class="headerlink" title="堆上的实例变量"></a>堆上的实例变量</h4><p>在我们想要新建一个对象时, Java必须为这个对象在堆上找一个位置. 对象中的实例变量会被存放在其中.</p>
<p>但是, 如果实例变量自己也是个对象呢? 如果对象带有一个其他类的对象呢? 如果对象带有其他对象的引用变量呢?</p>
<p>实际上, Java只会为引用变量留出空间. 至于”另一个对象”, 则需要考虑它是什么时候被创建的: 如果声明了对象却没有被赋值, 则只会留下变量的空间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Antenna ant;</span><br></pre></td></tr></table></figure>

<p>自横刀引用变量被赋值一个新的对象, 堆上才会有这个新对象的空间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Antenna</span> <span class="variable">ant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Antenna</span>();</span><br></pre></td></tr></table></figure>

<h3 id="创建对象详解——构造函数"><a href="#创建对象详解——构造函数" class="headerlink" title="创建对象详解——构造函数"></a>创建对象详解——构造函数</h3><p>我们都知道, 声明对象并赋值有三个步骤: 声明引用变量、创建对象以及连接对象和引用. 但是新对象究竟是如何诞生的呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Duck</span> <span class="variable">myDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br></pre></td></tr></table></figure>

<p>我们在创建<code>Duck</code>对象的时候编写了<code>new Duck()</code>代码. 看上去就像调用了一个叫做<code>Duck()</code>的方法. 但实际上不是的, 我们只是调用了<code>Duck</code>的<strong>构造函数</strong>.</p>
<p>构造函数看起来很像方法, 但实际上并不是. 它会在我们初始化一个对象的时候执行.</p>
<p>我们可以自己编写构造函数, 也可以让编译器帮我们编写一个. 通常, 编译器编写的构造函数是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中我们能够看到构造函数与方法的区别:</p>
<ol>
<li>方法每返回类型, 但是构造函数没有返回类型</li>
<li>构造函数的名称一定要与类的名称相同.</li>
</ol>
<h3 id="构造Duck"><a href="#构造Duck" class="headerlink" title="构造Duck"></a>构造<code>Duck</code></h3><p>构造函数的一项关键特征是它会在对象能够被赋值给引用之前就执行. 在任何人取得对象的遥控器之前, 对象有机会对构造过程给予协助.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在运行后会输出一个Quack. 这证明我们可以借助构造函数干涉对象构件过程.</p>
<h3 id="新建Duck状态的初始化"><a href="#新建Duck状态的初始化" class="headerlink" title="新建Duck状态的初始化"></a>新建<code>Duck</code>状态的初始化</h3><p>大部分的人都是使用构造函数来初始化对象的状态. 也就是说, 设置和给对象的实例变量赋值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">    size = <span class="number">34</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在开发者知道<code>Duck</code>类应该有多大时是没有问题的. 但如果是要由使用<code>Duck</code>的程序员来决定时怎么办? 那我们就需要使用类的<code>set</code>方法来设置了. 但这会让<code>Duck</code>暂时处于没有大小数值的状态(实例变量没有默认值), 且需要两行才能完成赋值, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        d.setSize(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某种对象不应该在状态被初始化之前就使用, 就不要让任何人能够在没有初始化的情况下取得该种对象. 以<code>Duck</code>为例, 让用户先构造出<code>Duck</code>对象再来设定大小是很危险的. 如果用户不知道这件事, 或者干脆忘了要调用<code>set</code>方法, 那<code>Duck</code>对象就会陷入没有大小的混沌状态.</p>
<p>最好的解决办法就是将初始化的程序代码放在构造函数中, 然后将构造函数设定成需要参数的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> duckSize)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">        size = duckSize;</span><br><span class="line">        System.out.println(<span class="string">&quot;Size is &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Duck的产后护理"><a href="#Duck的产后护理" class="headerlink" title="Duck的产后护理"></a><code>Duck</code>的产后护理</h3><h4 id="一定要有不需要参数的构造函数"><a href="#一定要有不需要参数的构造函数" class="headerlink" title="一定要有不需要参数的构造函数"></a>一定要有不需要参数的构造函数</h4><p>还是以<code>Duck</code>为例. 让程序员自己定义<code>Duck</code>的大小固然是好, 但是如果程序员自己也不知道大小, 我们还强迫人家在构造函数里填一个值就未免有些强人所难了. 所以我们需要构件一个不需要参数的构造函数: 一个可以指定<code>Duck</code>的大小, 一个使用默认值而无需指定大小.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> duckSize)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">        size = duckSize;</span><br><span class="line">        System.out.println(<span class="string">&quot;Size is &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">27</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外, 就算一个类不可能提供默认值, 我们也要提供无参数的构造函数.</p>
<h4 id="编译器不是什么时候都会帮你写构造函数的"><a href="#编译器不是什么时候都会帮你写构造函数的" class="headerlink" title="编译器不是什么时候都会帮你写构造函数的"></a>编译器不是什么时候都会帮你写构造函数的</h4><p>在我们写了一个有参数的构造函数后, 编译器就不会再插手构造函数的编写工作. 如果我们还想写一个没有参数的构造函数, 就只能自行编写.</p>
<p>此外, 如果类有一个以上的构造函数, 则参数一定要不一样. 编译器看的是参数的<strong>类型和顺序</strong>, 而不是参数的名字. 我们完全可以编写出参数类型相同但是顺序不同的构造函数.</p>
<h3 id="父类的空间——父类与子类的构造函数"><a href="#父类的空间——父类与子类的构造函数" class="headerlink" title="父类的空间——父类与子类的构造函数"></a>父类的空间——父类与子类的构造函数</h3><p>在创建某个对象时, 对象会取得所有实例变量所需的空间, 其中必然包括一路继承下来的东西. 在创建新对象的同时, <strong>所有继承下来的构造函数都会被执行</strong>.</p>
<p>执行<code>new</code>命令的指令是个大事, 因为它会引起构造函数的连锁反应. 此外, 抽象类也有构造函数. 虽然不能对抽象的类执行<code>new</code>操作, 但是抽象类也是父类, 其构造函数会在具体子类创建时执行.</p>
<p>至于原因: 在构造函数中使用<code>super</code>调用父类的构造函数的部分. 要记得子类可能会根据父类的状态来继承方法(即父类的实例变量). 完整的对象需要同样玩这个的父类核心, 故子类必须调用父类的构造函数. 构造函数在执行的时候, 第一件事就是去执行它的父类的构造函数, 这会向上推到<code>Object</code>这个类为止.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making an Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hippo</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hippo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making a Hippo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHippo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting ...&quot;</span>);</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting ...</span><br><span class="line">Making an Animal</span><br><span class="line">Making a Hippo</span><br></pre></td></tr></table></figure>

<h4 id="如何调用父类的构造函数"><a href="#如何调用父类的构造函数" class="headerlink" title="如何调用父类的构造函数"></a>如何调用父类的构造函数</h4><p>以<code>Duck</code>的构造函数来说, 它不是通过<code>Animal()</code>, 而是通过<code>super()</code>来调用父类<code>Animal</code>的构造函数的, 如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类的构造函数调用<code>super()</code>后, 编译器会将父类的构造函数放在堆栈的最上方. 而父类的构造函数又会调用父类的父类的构造函数, 直到<code>Object</code>类的构造函数为止. 在<code>Object</code>的构造函数运行完毕后, 其子类的构造函数就会一路弹出, 直到最初的构造函数.</p>
<p>如果我们没有调用<code>super()</code>, 编译器就会帮我们在构造函数中加入<code>super()</code>, 以调用父类的构造函数. 但是编译器添加的构造函数一定是没有参数的<code>super()</code>, 就算父类有带参数的构造函数也是这样.</p>
<p>注意, <code>super()</code><strong>只能放在构造函数的第一行上</strong>.</p>
<h4 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h4><p>父类的部分必须在子类创建完成之前就必须完整地成型, 因为子类对象可能需要动用到从父类继承下来的东西. 父类的构造函数必须在子类的构造函数之前结束.</p>
<h4 id="有参数的父类构造函数"><a href="#有参数的父类构造函数" class="headerlink" title="有参数的父类构造函数"></a>有参数的父类构造函数</h4><p>如果父类的构造函数有参数怎么办? 能够传递值进去吗? 如果不行的话, 则没有无参数构造函数的类将不能被继承. 想象这个场景: 所有的动物都有名字. 所以, <code>Animal</code>类有个<code>getName()</code>可以返回<code>name</code>实例变量的值. 此实例变量是被标记为<code>private</code>的, 但<code>Hippo</code>这个子类把<code>getName()</code>这个方法继承下来了. 问题来了: <code>Hippo</code>有<code>getName()</code>这个方法但是没有<code>name</code>实例变量. <code>Hippo</code>要靠<code>Animal</code>的部分来维持<code>name</code>实例变量, 然后从<code>getName()</code>来返回这个值. 但<code>Animal</code>要如何获得这个值呢? 唯一的机会是通过<code>super()</code>来引用父类, 所以要从这里把<code>name</code>的值传进去, 让<code>Animal</code>把它存到私有的<code>name</code>实例变量中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// Every animal has a name.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">// Hippo会继承这个get方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String theName)</span> &#123; <span class="comment">// 有参数的构造函数, 用来设定name</span></span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hippo</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hippo</span><span class="params">(String name)</span> &#123; <span class="comment">// 如果不传给这个构造函数值, 编译器会报错</span></span><br><span class="line">        <span class="built_in">super</span>(name);    <span class="comment">// 传给Animal的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHippo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting ...&quot;</span>);</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>(<span class="string">&quot;Buffy&quot;</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用重载版本——从某个构造函数调用重载版的另一个构造函数"><a href="#调用重载版本——从某个构造函数调用重载版的另一个构造函数" class="headerlink" title="调用重载版本——从某个构造函数调用重载版的另一个构造函数"></a>调用重载版本——从某个构造函数调用重载版的另一个构造函数</h3><p>如果某个重载版的构造函数除了不能处理不同类型的参数之外, 可以处理所有的工作, 那要怎么般? 我们不能让相同的程序代码出现在每个构造函数中, 所以我们可以将程序代码只摆在某个构造函数中(包括对<code>super()</code>的调用). 如此一来, 多有的构造函数就都会有限调用该构造函数, 让他来执行真正的构造函数.</p>
<p>为此, 我们需要使用<code>this()</code>或<code>this(aString)</code>或<code>this(27, x)</code>. 换句话说, <strong><code>this()</code>是对对象本身的调用</strong>. 需要注意的是:</p>
<ol>
<li><code>this()</code>只能出现在构造函数中;</li>
<li><code>this()</code>必须为构造函数的第一句语句;</li>
<li><code>super()</code>和<code>this()</code>不能同时调用.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mini</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mini</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Color.Red);    <span class="comment">// 无参数的构造函数以默认的颜色调用真正的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mini</span><span class="params">(Color c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Mini&quot;</span>);      <span class="comment">// 真正的构造函数</span></span><br><span class="line">        color = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的死亡"><a href="#对象的死亡" class="headerlink" title="对象的死亡"></a>对象的死亡</h3><p>对象的生命周期完全取决于其引用的状态. 如果引用还存在, 则对象也会继续待在堆上; 如果引用”死掉”了, 对象就会被从堆上移除.</p>
<p>那变量又会存在多久呢? 这取决于它是局部变量还是实例变量: 局部变量只存在于声明该变量的方法中; 实例变量的寿命与对象相同.</p>
<h4 id="“life”和”scope”的差别"><a href="#“life”和”scope”的差别" class="headerlink" title="“life”和”scope”的差别"></a>“life”和”scope”的差别</h4><ol>
<li>“life”: 只要变量的堆栈还存在于堆栈上, 局部变量就算或者, 即活到方法执行完毕为止;</li>
<li>“scope’: 局部变量的范围只限于声明它的方法之内. 当此方法调用别的方法时, 该变量还活着, 但不在目前的范围内. 执行其他方法完毕返回时, 范围也就跟着回来.</li>
</ol>
<h4 id="引用变量的死亡"><a href="#引用变量的死亡" class="headerlink" title="引用变量的死亡"></a>引用变量的死亡</h4><p>引用变量的死活判断与primitive主数据类型变量相同. 真正的问题在于: <strong>变量的生命周期如何影响对象的生命周期</strong>?</p>
<p>只要有或者的引用, 对象也就会活着. 如果某个对象的引用已经不在它的范围中, 但该引用还是活着的, 则此对象就会继续活在堆上.</p>
<p>如果对象的唯一引用死了, 对象就会从堆中被踢开. 引用变量会跟随堆栈块一道解散, 被踢开的对象也就此出局, 成为了”可被垃圾回收器回收的”. 有三种方法能够将对象变为可被回收的:</p>
<ol>
<li>对象的引用变量所在的方法被弹出堆栈;</li>
<li>对象的引用变量被复制到其他的对象上;</li>
<li>对象的引用变量被赋了<code>null</code>.</li>
</ol>
<h2 id="数字与静态"><a href="#数字与静态" class="headerlink" title="数字与静态"></a>数字与静态</h2><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a><code>Math</code>方法</h3><p>想要执行<code>Math</code>中的方法并不需要创建<code>Math</code>的实例变量. 实际上我们也创建不出来, 因为它们的都是”静态”的. 我们用到的只有这个类本身.</p>
<h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>Java是面向对象的. 但如果有需求(通常是实用方法), 则不需要类的实例. 关键词<code>static</code>可以标记出不需要实例的方法. 一个静态的方法意味着”一种不依靠实例变量也就不需要对象的行为”.</p>
<h4 id="带有静态方法的含义"><a href="#带有静态方法的含义" class="headerlink" title="带有静态方法的含义"></a>带有静态方法的含义</h4><p>带有静态方法的类一般都不打算被初始化. 这样的类的构造函数一般都被限制为<code>private</code>. 但这并不意味着有一个或多个静态方法的类就不可以被初始化, 毕竟只要有<code>main()</code>的类都算作是有静态方法的类.</p>
<p>由此可知, 我们可以自由地在类中组合静态与非静态方法. 然而任何非静态方法都需要某种实例来操作. 取得新对象的方法也只有通过<code>new</code>或者序列化(deserialization)以及我们暂时设计不到的Java Reflection API. 除此之外, 别无他发. 实际上, 由谁来新建是一个很有意思的问题. 我们会在下面讨论它.</p>
<h4 id="静态方法不能调用非静态变量"><a href="#静态方法不能调用非静态变量" class="headerlink" title="静态方法不能调用非静态变量"></a>静态方法不能调用非静态变量</h4><p>静态的方法实在无关特定类的实例情况下执行的. 因为静态的方法是通过类的名称来调用, 所以静态的方法无法引用到该类的任何实力变量. 在此情况下, 静态的方法也不会知道可以使用哪个实例变量值.</p>
<h4 id="静态方法也不能调用非静态方法"><a href="#静态方法也不能调用非静态方法" class="headerlink" title="静态方法也不能调用非静态方法"></a>静态方法也不能调用非静态方法</h4><p>与非静态变量的情况类似, 静态方法也不能调用非静态方法: 实例不存在, 对应的方法也就不存在.</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>假设我们要在执行过程中计算有多少<code>Duck</code>的实例已经被建立出来, 应该怎么作? 在构造函数中递增某个实例变量的值?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">duckCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码不行, 因为<code>duckCount</code>是个实例变量, 对象与对象间相互不影响, 所以行不通.</p>
<p>但是, 我们可以将<code>duckCount</code>声明为<code>static</code>变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">duckCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样, 所有的<code>duckCount</code>值就都是相等的. 每当我们创建一个<code>duckCount</code>对象时, <code>duckCount</code>就加1, 由此实现数量的统计.</p>
<h4 id="静态变量的起始动作"><a href="#静态变量的起始动作" class="headerlink" title="静态变量的起始动作"></a>静态变量的起始动作</h4><p>静态项目的初始化有两项保证:</p>
<ol>
<li>静态变量会在该类的任何对象创建之前就完成初始化;</li>
<li>静态变量会在该类的任何静态方法执行之前就初始化.</li>
</ol>
<h4 id="静态final变量是常数"><a href="#静态final变量是常数" class="headerlink" title="静态final变量是常数"></a>静态<code>final</code>变量是常数</h4><p>一个被标记为<code>final</code>的变量代表它一旦被初始化之后就不会被改动. 也就是说, 类加载之后静态<code>final</code>变量就一直会维持原值. 以<code>Math.PI</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>此变量被标记为<code>public</code>, 因此可供各方读取;</li>
<li>此变量被标记为<code>static</code>, 因此你不需要<code>Math</code>的实例;</li>
<li>此变量被标记为<code>final</code>, 因为圆周率是不变的.</li>
</ol>
<p>没有其他的方法再可以将一个变量标记为不变的, 但是又约定俗成的命名惯例可以帮助我们这些人类认出来, 即<strong>常熟变量的名称应该要都是大写字母</strong>.</p>
<h4 id="静态final变量的初始化"><a href="#静态final变量的初始化" class="headerlink" title="静态final变量的初始化"></a>静态<code>final</code>变量的初始化</h4><p>有两种方法. 一是在声明的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOO_X</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二是在静态初始化程序中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> BAR_SIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BAR_SIGN = (<span class="type">double</span>) Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有按上述两种方式中的一种为静态<code>final</code>变量初始化的话, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> BAR_SIGN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会报错, 要求你初始化这个变量.</p>
<h3 id="final的其他用法"><a href="#final的其他用法" class="headerlink" title="final的其他用法"></a><code>final</code>的其他用法</h3><p><code>final</code>不只用在静态变量上. 我们也可以用<code>final</code>关键字来修饰非静态的变量, 其中包括实例变量、局部变量以及方法的参数. 他们都代表被修饰的值不能变动. 我们也可以使用<code>final</code>来防止方法的覆盖或创建子类.</p>
<p>总结一下:</p>
<ol>
<li><code>final</code>的变量代表其值不能被修改;</li>
<li><code>final</code>的方法代表该方法不能被覆盖;</li>
<li><code>final</code>的类代表该类不能被继承.</li>
</ol>
<h3 id="primitive主数据类型的包装"><a href="#primitive主数据类型的包装" class="headerlink" title="primitive主数据类型的包装"></a>primitive主数据类型的包装</h3><p>我们有时想要把primitive主数据类型当作对象来处理. 如Java 5.0之前, 我们无法直接将primitive主数据类型装入<code>ArrayList</code>或<code>HashMap</code>中. 但是, 每个primitive主数据类型都有一个包装用的类, 且这些包装类都放在<code>Java.lang</code>这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示:</p>
<table>
<thead>
<tr>
<th>primitive主数据类型名称</th>
<th>包装类名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
</tbody></table>
<p>包装过程如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">iWrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br></pre></td></tr></table></figure>

<p>解包装过程如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">unWrapped</span> <span class="operator">=</span> iWrap.intValue();</span><br></pre></td></tr></table></figure>

<h4 id="autoboxing-不必将primitive主数据类型与对象分得那么清楚"><a href="#autoboxing-不必将primitive主数据类型与对象分得那么清楚" class="headerlink" title="autoboxing: 不必将primitive主数据类型与对象分得那么清楚"></a><code>autoboxing</code>: 不必将primitive主数据类型与对象分得那么清楚</h4><p>从5.0版本开始加入的<code>autoboxing</code>功能能够自动将primitive主数据类型转换成包装过的对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNumsNewWay</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; listOfNumbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    listOfNumbers.add(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> listOfNumbers.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="“无处不在的”autoboxing"><a href="#“无处不在的”autoboxing" class="headerlink" title="“无处不在的”autoboxing"></a>“无处不在的”<code>autoboxing</code></h4><ol>
<li>方法的参数</li>
<li>返回值</li>
<li><code>boolean</code>表达值</li>
<li>数值运算</li>
<li>赋值</li>
</ol>
<h4 id="包装的静态实用方法"><a href="#包装的静态实用方法" class="headerlink" title="包装的静态实用方法"></a>包装的静态实用方法</h4><p>除了一般类的操作外, 包装也有一组实用的静态方法. 我们在之前已经使用过一个: <code>Integer.parseInt()</code>. 这个方法取用<code>Strinig</code>并返回primitive主数据类型值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;420.24&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>).booleanValue(); <span class="comment">// 将String转换为boolean的唯一方法</span></span><br></pre></td></tr></table></figure>

<p>反过来, 我们也可以将primitive主数据类型值转换成<code>String</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">42.5</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">doubleString1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + d;  <span class="comment">// &quot;+&quot;运算符是Java中唯一一个重载过的运算符</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">42.5</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">doubleString2</span> <span class="operator">=</span> Double.toString(d);</span><br></pre></td></tr></table></figure>

<h2 id="异常处理——以创建MIDI音乐播放器为例"><a href="#异常处理——以创建MIDI音乐播放器为例" class="headerlink" title="异常处理——以创建MIDI音乐播放器为例"></a>异常处理——以创建MIDI音乐播放器为例</h2><h3 id="JavaSound-API"><a href="#JavaSound-API" class="headerlink" title="JavaSound API"></a>JavaSound API</h3><p>如果我们想要创建一个MIDI音乐播放器, 我们首先需要知道如何让Java”发生”. JavaSound API解决了这一问题.</p>
<h4 id="Sequencer对象"><a href="#Sequencer对象" class="headerlink" title="Sequencer对象"></a><code>Sequencer</code>对象</h4><p>在我们要能够发出任何声音之前, 必须先要取得<code>Sequencer</code>对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sequencer</span> <span class="variable">sequencer</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">        System.out.println(<span class="string">&quot;We got a sequencer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 上述代码会在执行时报错, 无法通过编译. 为什么呢?</p>
<h3 id="调用有风险的方法"><a href="#调用有风险的方法" class="headerlink" title="调用有风险的方法"></a>调用有风险的方法</h3><p>假设我们调用了一个不是自己写的方法. 该方法在执行某些有风险的任务时可能会出现状况. 我们必须意识到: 该方法是有风险的, 所以, 我们需要写出可以在发生状况时加以处理的程序代码, 未雨绸缪.</p>
<p>Java的异常处理机制是一个简洁且轻量化的例外状况处理方式. 它能够将处理错误状况的程序代码摆在一个容易阅读的为止上.</p>
<p>如何得知某个方法会抛出异常呢? 我们可以在方法的声明中的<code>throws</code>语句中看到.</p>
<p>我们在<code>getSequencer()</code>方法的说明中, 我们看到, <code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常. 编译器需要确定我们知道这种风险的存在, 而告知其的方法便是将有风险的程序代码包含在<code>try/catch</code>块中.</p>
<p><code>try/catch</code>块会告诉编译器你确实知道所调用的方法会有风险, 并且也已经准备好要处理它, 它只会注意你有没有表示你会注意到异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">sequencer</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">&quot;We got a sequencer.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bummer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常也是一种对象"><a href="#异常也是一种对象" class="headerlink" title="异常也是一种对象"></a>异常也是一种对象</h4><p>异常也是一种对象, 且<code>Exception</code>类型的对象可以是任何它的子类的实例, 所以我们<code>catch</code>住的也是对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 危险动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 尝试恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="谁抛出的异常"><a href="#谁抛出的异常" class="headerlink" title="谁抛出的异常?"></a>谁抛出的异常?</h4><p>现在我们只需要知道: 当我们的程序代码调用有风险的方法时, 也就是声明有异常的方法时, 就是该方法把异常丢给你的.</p>
<p>实际上, 两者都有可能是我们自己写的. 但事实上, 谁写的程序其实并不重要; 重要的是在哪个方法抛出异常以及由哪个方法抓住他.</p>
<p>在编写可能会抛出异常的方法时, 它们都必须声明由异常.</p>
<h5 id="有风险、会抛出异常的程序代码"><a href="#有风险、会抛出异常的程序代码" class="headerlink" title="有风险、会抛出异常的程序代码"></a>有风险、会抛出异常的程序代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boid <span class="title function_">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException &#123;</span><br><span class="line">    <span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用该方法的程序代码"><a href="#调用该方法的程序代码" class="headerlink" title="调用该方法的程序代码"></a>调用该方法的程序代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crossFingers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        anObject.takeRisk();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(BadException ex) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aaargh&quot;</span>);</span><br><span class="line">        ex.printStackTrace();   <span class="comment">// 如果无法从异常中恢复, 至少也可以用printStackTrace()来列出有用的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="受检查的与不受检查的异常"><a href="#受检查的与不受检查的异常" class="headerlink" title="受检查的与不受检查的异常"></a>受检查的与不受检查的异常</h4><p>编译器会核对除了<code>RuntimeExceptions</code>之外的每件事. 编译器保证:</p>
<ol>
<li>如果你有抛出异常, 则你一定要使用<code>throw</code>来声明这件事;</li>
<li>如果你调用会抛出异常的方法, 你必须得确认你知道异常的可能性. 将调用包在<code>try/catch</code>块中是一种满足编译器的方法.</li>
</ol>
<p>除了<code>RuntimeExceptions</code>这种特例之外, 编译器会关照<code>Exception</code>所有的子类. 任何继承过<code>RuntimeExceptions</code>的类都不会受编译器关于是否声明它会抛出<code>RuntimeExceptions</code>的检查. 同样的, 也不会管调用方是否认识到可能会在运行期间遇到异常.</p>
<h3 id="异常与流程控制"><a href="#异常与流程控制" class="headerlink" title="异常与流程控制"></a>异常与流程控制</h3><p>当要调用有风险的方法时, 有一两件事可能会发生. 该方法要么成功执行了<code>try</code>块中的内容, 要么将异常丢回调用方的方法.</p>
<h4 id="finally块-无论如何都要执行的部分"><a href="#finally块-无论如何都要执行的部分" class="headerlink" title="finally块: 无论如何都要执行的部分"></a><code>finally</code>块: 无论如何都要执行的部分</h4><p><code>finally</code>块是用来存放不管有没有异常都得执行的程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    turnOvenOn();</span><br><span class="line">    x.bake();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 就算<code>try</code>块或<code>catch</code>块中有<code>return</code>命令, <code>finally</code>还是会执行. 流程会跳到<code>finally</code>块然后再执行<code>return</code>命令.</p>
<h3 id="一次抛出多个异常"><a href="#一次抛出多个异常" class="headerlink" title="一次抛出多个异常"></a>一次抛出多个异常</h3><p>如果有必要的话, 方法可以抛出多个异常. 但该方法的声明必须要含有全部可能的检查异常(若两个或两个以上的异常有共同的父类时, 可以只声明该父类就行).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Laundry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException &#123;</span><br><span class="line">        <span class="comment">// 有可能抛出两个异常的程序代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Laundry</span> <span class="variable">laundry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Laundry</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            laundry.doLaundry();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">            <span class="comment">// 恢复程序代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">            <span class="comment">// 恢复程序代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常也是多态的"><a href="#异常也是多态的" class="headerlink" title="异常也是多态的"></a>异常也是多态的</h3><p>异常除了可以被抛出外与对象无异, 故异常也可以能够以多态的方式来引用. 举例来说, <code>LingerieException</code>对象能够被赋值给<code>ClothingException</code>的引用. <code>PantsException</code>也能够被赋值给<code>Exception</code>的引用. 这样的好处是方法可以不必明确声明每个可能抛出的异常, 只声明父类就可以了. 对于<code>catch</code>块来说, 也可以不用对每个可能的异常做处理, 只要有一个或少数几个<code>catch</code>可以处理所有的异常就足够了.</p>
<h4 id="以异常的父型来声明会抛出的异常"><a href="#以异常的父型来声明会抛出的异常" class="headerlink" title="以异常的父型来声明会抛出的异常"></a>以异常的父型来声明会抛出的异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以所抛出的异常父型来catch异常"><a href="#以所抛出的异常父型来catch异常" class="headerlink" title="以所抛出的异常父型来catch异常"></a>以所抛出的异常父型来<code>catch</code>异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;    <span class="comment">// 可以catch任何ClothingException的子类</span></span><br><span class="line">    <span class="comment">// 解决方案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;    <span class="comment">// 只能catch两种子类</span></span><br><span class="line">    <span class="comment">// 解决方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合理使用父型"><a href="#合理使用父型" class="headerlink" title="合理使用父型"></a>合理使用父型</h4><p>我们固然可以直接在<code>catch</code>中写一个<code>Exception</code>类直接抓取所有的异常, 但如果需要异常的不同做出不同的处理的话, 我们还是需要具体地写一下<code>catch</code>代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(TeeShirtException tex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有catch块时要从小排到大"><a href="#有catch块时要从小排到大" class="headerlink" title="有catch块时要从小排到大"></a>有<code>catch</code>块时要从小排到大</h4><p>如题, 否则小的(在继承树上靠下的)异常就永远无法被正常解决.</p>
<h3 id="实在是不想处理异常"><a href="#实在是不想处理异常" class="headerlink" title="实在是不想处理异常"></a>实在是不想处理异常</h3><h4 id="duck"><a href="#duck" class="headerlink" title="duck"></a>duck</h4><p>如果自己实在是不想处理异常的话, 我们可以直接duck掉异常, 即表示自己会再throw掉此异常即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> ReallyBadException &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ducking只是在踢皮球"><a href="#ducking只是在踢皮球" class="headerlink" title="ducking只是在踢皮球"></a>ducking只是在踢皮球</h4><p>duck只是把Exception甩到上一级. 我们可以一级一级地将Exception向上甩吗, 但如果<code>main()</code>也把Exception给duck掉, 那编译器就直接死机了.</p>
<p>我们可以把Exception向上甩, 但是总有一天我们要catch它的.</p>
<h3 id="异常处理的规则"><a href="#异常处理的规则" class="headerlink" title="异常处理的规则"></a>异常处理的规则</h3><ol>
<li><code>catch</code>与<code>finally</code>不能没有<code>try</code>;</li>
<li><code>try</code>与<code>catch</code>之间不能有程序</li>
<li><code>try</code>一定要有<code>catch</code>或<code>finally</code></li>
<li>只带有<code>finally</code>的<code>try</code>必须要声明异常</li>
</ol>
<h3 id="回到音乐播放程序"><a href="#回到音乐播放程序" class="headerlink" title="回到音乐播放程序"></a>回到音乐播放程序</h3><h4 id="第一版音乐播放程序"><a href="#第一版音乐播放程序" class="headerlink" title="第一版音乐播放程序"></a>第一版音乐播放程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        test1.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">player</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            <span class="type">Sequence</span> <span class="variable">seq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Track</span> <span class="variable">track</span> <span class="operator">=</span> seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第二版音乐播放程序"><a href="#第二版音乐播放程序" class="headerlink" title="第二版音乐播放程序"></a>第二版音乐播放程序</h4><p>这一版的音乐播放程序可以通过在控制台输入数字来改变播放的声音.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest2</span>();</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Do not forget the instrument and note args.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">instrument</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">note</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            test2.play(instrument, note);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(<span class="type">int</span> instrument, <span class="type">int</span> note)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">player</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line">            <span class="type">Sequence</span> <span class="variable">seq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="type">Track</span> <span class="variable">track</span> <span class="operator">=</span> seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">changeInstrument</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line">            player.setSequence(seq);</span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图形用户接口"><a href="#图形用户接口" class="headerlink" title="图形用户接口"></a>图形用户接口</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>一切都要从window开始说起.</p>
<p><code>JFrame</code>是一个代表屏幕上window的对象. 我们可以把<code>button</code>、<code>checkbox</code>和<code>text</code>字段等接口放在window上面. 标准的<code>menu</code>也可以放在上面, 并且能够放置最小化、最大化以及关闭等图标.</p>
<p>在我们创建出<code>JFrame</code>后, 我们就可以把组件(widget)放在上面了. 有很多的Swing组件可供选择, 绝大多数都简单易懂.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建frame</span></span><br><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">// 创建widget(组件)</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"><span class="comment">// 将widget添加到frame上</span></span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"><span class="comment">// 显示出来</span></span><br><span class="line">frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="年轻人的第一个GUI"><a href="#年轻人的第一个GUI" class="headerlink" title="年轻人的第一个GUI"></a>年轻人的第一个GUI</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建frame和button</span></span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在window关闭后自动关闭程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将button加到frame的pane上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame的大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示frame</span></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户接口事件"><a href="#用户接口事件" class="headerlink" title="用户接口事件"></a>用户接口事件</h3><p>如何让按钮在用户按下时执行特定的工作? 我们需要两个东西:</p>
<ol>
<li>被按下时要执行的方法</li>
<li>检测按钮被按下的方法</li>
</ol>
<h4 id="取得用户的事件"><a href="#取得用户的事件" class="headerlink" title="取得用户的事件"></a>取得用户的事件</h4><p>假设我们想要把按钮上的文字在用户按下按钮时从”click me”变成”I’ve been clicked”. 我们需要先编写改变按钮文字的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeIt</span><span class="params">()</span> &#123;</span><br><span class="line">    button.setText(<span class="string">&quot;I&#x27;ve been clicked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 在我们写好了这个方法之后, 我们又应该在什么时候执行这个方法呢? 我们怎么知道按钮被按下去了呢?</p>
<p>在Java中, 取得与处理用户操作事件的过程称为even-handling. 如果用户按下了按钮, 就会产生事件. 这是一个关于用户想要采用启动按钮功能的事件.</p>
<h4 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h4><p>如果想要知道按钮的事件, 就会监听事件的接口. 监听接口是介于监听(我们)与事件源(按钮)之间的桥梁.</p>
<p>Swing的GUI组件是事件的来源. 以Java的术语来说, 事件来源是个可以将用户操作(点击鼠标、按键以及关闭窗口等)转换成事件的对象. 这些事件源会在用户做出相关动作时(按下按钮)产生事件对象. 程序在大多数情况下是事件的接受方而不是创建方. 也就是说, 我们会花比较多的事件当监听者而不是事件来源.</p>
<p>每个事件类型都有相对应的监听者接口. 如果没有, 就要自己写一个.</p>
<p>某些接口不只有一个方法, 因为事件本身就有不同的形态.</p>
<h4 id="监听和事件源如何沟通"><a href="#监听和事件源如何沟通" class="headerlink" title="监听和事件源如何沟通"></a>监听和事件源如何沟通</h4><h5 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h5><p>如果类想要知道按钮的<code>ActionEvent</code>, 我们就需要实现<code>ActionListener</code>这个接口. 按钮需要知道我们关注的部分, 因此要通过调用<code>addActionListener(this)</code>并传入<code>ActionListener</code>的引用(此例中就是我们自己的这个程序, 所有传了一个<code>this</code>进去)来向按钮注册. 按钮会在该事件发生时调用该接口上的方法. 而作为一个<code>ActionListener</code>, 编译器会确保你实现此接口的<code>actionPerformed()</code>.</p>
<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><p>按钮是<code>ActionEvent</code>的来源, 因此它必须要知道有哪些对象是需要事件通知的. 此按钮有个<code>addActionListener</code>方法可以提供对事件有兴趣的对象(<code>listener</code>)一种表达此兴趣的方法.</p>
<p>当按钮的<code>addActionListener()</code>方法被调用时(因为某个<code>listener</code>的调用), 它的参数会被按钮存到清单中. 当用户按下按钮时, 按钮会通过调用清单上每个监听的<code>actionPerformed()</code>来启动事件.</p>
<h4 id="取得按钮的ActionEvent"><a href="#取得按钮的ActionEvent" class="headerlink" title="取得按钮的ActionEvent"></a>取得按钮的<code>ActionEvent</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleGUI</span> <span class="variable">gui</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGUI</span>();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">        button = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        button.addActionListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        button.setText(<span class="string">&quot;I&#x27;ve been clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回到图形上"><a href="#回到图形上" class="headerlink" title="回到图形上"></a>回到图形上</h3><h4 id="在GUI上面加东西的三种方法"><a href="#在GUI上面加东西的三种方法" class="headerlink" title="在GUI上面加东西的三种方法"></a>在GUI上面加东西的三种方法</h4><ol>
<li>在<code>frame</code>上放置<code>widget</code></li>
<li>在<code>widget</code>上绘制2D图形</li>
<li>在<code>widget</code>上绘制JPEG图</li>
</ol>
<h3 id="年轻人的第一个绘图组件"><a href="#年轻人的第一个绘图组件" class="headerlink" title="年轻人的第一个绘图组件"></a>年轻人的第一个绘图组件</h3><p>如果我们要在屏幕放上自己的图形, 最好的方式是自己创建出有绘图功能的<code>widget</code>. 这一需求可以通过创建<code>JPanel</code>的子类并覆盖掉<code>paintComponent()</code>这个方法.</p>
<p>所有绘图程序代码都在<code>paintComponent()</code>里面. 当你的<code>panel</code>所处的<code>frame</code>显示的时候, <code>paintComponent()</code>就会被调用. 如果用户缩小window或选择最小化, Java虚拟机也会知道调用它来重新绘制.</p>
<p>需要强调的是, 我们自己是不会调用这个方法的. 它的参数是个与实际屏幕有关的<code>Graphics</code>对象. 这个对象无法被取得, 它必须由系统来交给我们. 但是, 我们还是可以调用<code>reapint()</code>来要求系统重新绘制显示装置, 然后才会产生<code>paintComponent()</code>的调用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123; <span class="comment">// 创建JPanel子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;    <span class="comment">// 系统调用Graphics类</span></span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在paintComponent-中可以做的事情"><a href="#在paintComponent-中可以做的事情" class="headerlink" title="在paintComponent()中可以做的事情"></a>在<code>paintComponent()</code>中可以做的事情</h4><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><h2 id="序列化和文件的输入-x2F-输出"><a href="#序列化和文件的输入-x2F-输出" class="headerlink" title="序列化和文件的输入&#x2F;输出"></a>序列化和文件的输入&#x2F;输出</h2><p>储存状态的选择有很多种. 我们暂且只讨论两种:</p>
<ol>
<li>序列化(serialization): 在数据只被自己写的Java程序使用时使用</li>
<li>纯文本文件: 在数据需要被其他程序引用时使用</li>
</ol>
<p>此外还有种种进行输入&#x2F;输出的方法, 但它们的基本原理都是类似的: 把数据写到某处——这个某处可以是磁盘上的文件, 也可以是来自网络上的串流. 读取数据的方向则刚好相反.</p>
<h3 id="储存状态"><a href="#储存状态" class="headerlink" title="储存状态"></a>储存状态</h3><p>假设有个程序, 是个幻想冒险游戏. 在游戏运行的过程中, 游戏的任务会累计经验值、宝物和体力等. 我们需要一种方法来保存人物的状态, 并在重新开启时能够将状态回复到上次存储时的原状. 有两种方法可供选择:</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>创建一个文件, 让序列化的三种对象写到此文件中.这个文件在以文本文件形式阅读时是无意义的.</p>
<p>序列化的文件难以阅读, 但它比纯文本文件更容易程序恢复原有的状态, 且更为安全, 因为一般人根本不会知道要如何修改数据.</p>
<h4 id="写入纯文本文件"><a href="#写入纯文本文件" class="headerlink" title="写入纯文本文件"></a>写入纯文本文件</h4><p>创建文件, 写入三行文字, 每个人物一行, 以逗号来分开属性.</p>
<h3 id="储存对象"><a href="#储存对象" class="headerlink" title="储存对象"></a>储存对象</h3><h4 id="将序列化对象写入文件"><a href="#将序列化对象写入文件" class="headerlink" title="将序列化对象写入文件"></a>将序列化对象写入文件</h4><p>下面是将对象序列化(存储)的方法步骤.</p>
<p>首先, 创建出<code>FileOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;MyGame.ser&quot;</span>);   <span class="comment">// 如果文件不存在, 它会自动被创建出来</span></span><br></pre></td></tr></table></figure>

<p>其次, 创建<code>ObjectOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileStream); <span class="comment">// 允许我们写入对象, 但无法直接连接文件, 所以需要参数的指引</span></span><br></pre></td></tr></table></figure>

<p>然后, 写入对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将变量所引用的对象序列化并写入MyGame.ser这个文件</span></span><br><span class="line">os.writeObject(characterOne);</span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br></pre></td></tr></table></figure>

<p>最后, 关闭<code>ObjectOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.close();</span><br></pre></td></tr></table></figure>

<h3 id="数据-在串流中移动"><a href="#数据-在串流中移动" class="headerlink" title="数据, 在串流中移动"></a>数据, 在串流中移动</h3><p>Java的输入&#x2F;输出API带有连接类型的串流, 它代表来源于目的地之间的连接, 连接串流将串流于其他串流连接起来.</p>
<p>一般来说, 串流要两两连接才能做出有意义的事情——其中一个表示连接, 另一个则是要被调用方法的. 这要归功于良好的面向对象设计——每个类只需要做好一件事就好了.</p>
<h2 id="网络与线程"><a href="#网络与线程" class="headerlink" title="网络与线程"></a>网络与线程</h2><h3 id="聊天程序概述"><a href="#聊天程序概述" class="headerlink" title="聊天程序概述"></a>聊天程序概述</h3><ol>
<li>客户端必须要认识服务器</li>
<li>服务器必须要认识所有的客户端</li>
</ol>
<p>工作方式:</p>
<ol>
<li>客户端连接到服务器</li>
<li>服务器建立连接并把客户端加到来宾清单中</li>
<li>另外一个用户连接上来</li>
<li>用户A送出信息到聊天服务器上</li>
<li>服务器将信息送给所有的来宾</li>
</ol>
<h3 id="网络Socket连接"><a href="#网络Socket连接" class="headerlink" title="网络Socket连接"></a>网络<code>Socket</code>连接</h3><p>要让客户端能够工作, 有三件事必须先学:</p>
<ol>
<li>如何建立客户端与服务器之间的初始链接</li>
<li>如何传送信息到服务器</li>
<li>如何接受来自服务器的信息</li>
</ol>
<p>这里有很多的底层工作问题, 但是Java API的网络功能包(java.net)还是提供了解决问题的方案. 但还是推荐深入研究一下TCP&#x2F;IP协议, 否则出错了也不知道怎么错的.</p>
<p>此外, 有个潜藏在简单版聊天客户程序中的问题是我们从未遇见过的: 同时做两件事情. 我们在后面会详细论述.</p>
<h4 id="建立Socket连接"><a href="#建立Socket连接" class="headerlink" title="建立Socket连接"></a>建立<code>Socket</code>连接</h4><p>要连接到其他的机器上, 我们需要<code>Socket</code>连接. <code>Socket</code>是个代表两台机器之间网络连接的对象(<code>java.net.Socket</code>).</p>
<p>要创建<code>Socket</code>连接, 我们需要知道两样关于服务器的信息: 它在哪里以及用哪个端口来收发数据, 即<strong>IP地址</strong>与<strong>端口号</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;196.164.1.103&quot;</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p><code>Socket</code>连接的建立代表两台机器之间存有对方的信息, 包括网络地址和TCP的端口号.</p>
<h4 id="读取socket"><a href="#读取socket" class="headerlink" title="读取socket"></a>读取<code>socket</code></h4><p>我们使用串流来实现<code>Socket</code>沟通, 与上一章所用的串流相同. Java的好处就在于大部分的输入&#x2F;输出并不在乎链接串流的上游实际是什么. 因此, 我们可以使用<code>BufferedReader</code>, 不管串流来自文件还是<code>Socket</code>.</p>
<h5 id="建立对服务器的Socket连接"><a href="#建立对服务器的Socket连接" class="headerlink" title="建立对服务器的Socket连接"></a>建立对服务器的<code>Socket</code>连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="建立连接到Socket上低层输入串流的InputStreamReader"><a href="#建立连接到Socket上低层输入串流的InputStreamReader" class="headerlink" title="建立连接到Socket上低层输入串流的InputStreamReader"></a>建立连接到<code>Socket</code>上低层输入串流的<code>InputStreamReader</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(chatSocket.getInputStream());</span><br></pre></td></tr></table></figure>

<h4 id="建立BufferedReader来读取"><a href="#建立BufferedReader来读取" class="headerlink" title="建立BufferedReader来读取"></a>建立<code>BufferedReader</code>来读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(stream);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> reader.readLine();</span><br></pre></td></tr></table></figure>

<h5 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><code>PrintWriter</code></h5><p>我们除了<code>BufferedReader</code>外, 还有一个选择, 即使用<code>PrintWriter</code>. 由于我们每次写入都只是写入一个字符串, 所有使用<code>PrintWriter</code>是最标准的做法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line">writer.println(<span class="string">&quot;message to send&quot;</span>);</span><br><span class="line">writer.print(<span class="string">&quot;another message&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="DailyAdviceClient客户端程序"><a href="#DailyAdviceClient客户端程序" class="headerlink" title="DailyAdviceClient客户端程序"></a><code>DailyAdviceClient</code>客户端程序</h3><p>这个程序会建立<code>Socket</code>, 通过其他串流来制作<code>BufferedReader</code>, 并从服务器应用程序(用56747端口服务的任何程序)上读取一行信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DailyAdviceClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">56747</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">streamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream());</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(streamReader);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">advice</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Today you should: &quot;</span> + advice);</span><br><span class="line"></span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DailyAdviceClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DailyAdviceClient</span>();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 如果我们直接运行这个程序的话, 它一定会报错. 不是端口的问题(除非我们的56747端口真的被占用了), 是服务器代码没写的问题. 我们需要先运行服务器的代码, 然后再运行这个代码.</p>
<h3 id="编写简单的服务器程序"><a href="#编写简单的服务器程序" class="headerlink" title="编写简单的服务器程序"></a>编写简单的服务器程序</h3><p>编写服务器应用程序要用到哪些东西呢? 一对<code>Socket</code>即可. 它们是一个会等待用户请求(当用户创建<code>Socket</code>时)的<code>ServerSocket</code>以及与用户通信用的<code>Socket</code>.</p>
<h4 id="服务器应用程序对特定端口创建出ServerSocket"><a href="#服务器应用程序对特定端口创建出ServerSocket" class="headerlink" title="服务器应用程序对特定端口创建出ServerSocket"></a>服务器应用程序对特定端口创建出<code>ServerSocket</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">56747</span>);</span><br></pre></td></tr></table></figure>

<h4 id="客户端对服务器应用程序建立Socket连接"><a href="#客户端对服务器应用程序建立Socket连接" class="headerlink" title="客户端对服务器应用程序建立Socket连接"></a>客户端对服务器应用程序建立<code>Socket</code>连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;196.165.1.103&quot;</span>, <span class="number">56747</span>);</span><br></pre></td></tr></table></figure>

<h4 id="服务器创建出与客户端通信的新Socket"><a href="#服务器创建出与客户端通信的新Socket" class="headerlink" title="服务器创建出与客户端通信的新Socket"></a>服务器创建出与客户端通信的新<code>Socket</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> serverSock <span class="title function_">accept</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>accept()</code>方法会在等待用户的<code>Socket</code>连接时闲置着. 当用户连上来时, 此方法会返回一个<code>Socket</code>(在不同的端口上)以便与客户端通信. <code>Socket</code>与<code>ServerSocket</code>的端口不相同, 因此<code>ServerSocket</code>可以空出来等待其他的用户.</p>
<h3 id="DailyAdviceClient客户端程序-2-0"><a href="#DailyAdviceClient客户端程序-2-0" class="headerlink" title="DailyAdviceClient客户端程序 2.0"></a><code>DailyAdviceClient</code>客户端程序 2.0</h3><p>这个程序吹创建<code>ServerSocket</code>并等待客户端的请求. 当它受到客户端请求时, 服务器会建立于客户端的<code>Socket</code>连接. 服务器接着会建立<code>PrintWriter</code>来送出信息给客户端.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DailyAdviceServer</span> &#123;</span><br><span class="line">    <span class="comment">// 锦囊妙计</span></span><br><span class="line">    String[] adviceList = &#123;<span class="string">&quot;Advice 1&quot;</span>, <span class="string">&quot;Advice 2&quot;</span>, <span class="string">&quot;Advice 3&quot;</span>, <span class="string">&quot;Advice 4&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocket会持续监听客户端在56747端口上的要求</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">56747</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器开始五西安等待客户端的请求</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 该方法会停下来等待要求达到之后才会继续</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用Socket连接发送消息, 并在送出后关闭连接</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sock.getOutputStream());</span><br><span class="line">                <span class="type">String</span> <span class="variable">advice</span> <span class="operator">=</span> getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DailyAdviceServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DailyAdviceServer</span>();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写聊天客户端程序"><a href="#编写聊天客户端程序" class="headerlink" title="编写聊天客户端程序"></a>编写聊天客户端程序</h3><h4 id="第一版-只能发送的版本"><a href="#第一版-只能发送的版本" class="headerlink" title="第一版: 只能发送的版本"></a>第一版: 只能发送的版本</h4><p>依旧没写服务器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatClientA</span> &#123;</span><br><span class="line">    JTextField outgoing;</span><br><span class="line">    PrintWriter writer;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Ludicrously Simple Chat Client&quot;</span>);</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">mainPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        outgoing = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">sendButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">        sendButton.addActionListener(<span class="keyword">new</span> <span class="title class_">SendButtonListener</span>());</span><br><span class="line">        mainPanel.add(outgoing);</span><br><span class="line">        mainPanel.add(sendButton);</span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);</span><br><span class="line">        setUpNetworking();</span><br><span class="line">        frame.setSize(<span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setUpNetworking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sock = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">56747</span>);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sock.getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;networking established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent ev)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.println(outgoing.getText());</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            outgoing.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            outgoing.requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleChatClientA</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二版-可发送和接收版"><a href="#第二版-可发送和接收版" class="headerlink" title="第二版: 可发送和接收版"></a>第二版: 可发送和接收版</h4><p>该版本的程序需要解决一个问题: 如何从服务器中取得信息?</p>
<p>这是个比较容易的问题: 当我们设定网络的同时也把输入串流建立好, 然后使用<code>readLine()</code>读取信息. 问题在于: 何时从服务器取得信息? 最好的方法当然是在信息被送到服务器上的时候就把它读回来. 但是, 这样的程序应该怎么写? 需要有一个循环来等待服务器的消息, 但是这个程序又该放在哪里?</p>
<h3 id="线程与Thread"><a href="#线程与Thread" class="headerlink" title="线程与Thread"></a>线程与<code>Thread</code></h3><p>Java有多个线程, 但是<strong>只有一个<code>Thread</code>类</strong>. 它只是<code>java.lang</code>这个包中的一个类, <code>Thread</code>对象才代表线程, 当我们需要启动新的线程时需要建立一个新的<code>Thread</code>实例.</p>
<h4 id="一个以上的执行空间意味着什么"><a href="#一个以上的执行空间意味着什么" class="headerlink" title="一个以上的执行空间意味着什么?"></a>一个以上的执行空间意味着什么?</h4><p>当有一个以上的执行空间时, 看起来会像是有好几件事情同时发生. 但是实际上, 只有真正的多处理器系统才能同时执行好几件事, 但使用Java的线程可以让它们看起来好像在同时执行. 也就是说, 执行动作可以在执行空间间非常快速地来回交换, 因此产生了它们在同时执行的错觉.</p>
<p>线程要记录的一项事物就是目前线程执行空间做到哪里了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java虚拟机调用main()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// main()启动新的线程. 新的线程启动期间, main的线程会暂停执行</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadJob</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java虚拟机会在线程与原来的主线程间切换直到两者都完成为止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何启动新的线程"><a href="#如何启动新的线程" class="headerlink" title="如何启动新的线程"></a>如何启动新的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立Runnable对象(线程的任务)</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立Thread对象并赋值Runnalbe(对象)</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Thread</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<h4 id="Thread的任务"><a href="#Thread的任务" class="headerlink" title="Thread的任务"></a><code>Thread</code>的任务</h4><p>每个<code>Thread</code>需要一个任务来执行, 一个可以放在执行空间的任务.</p>
<p>任务是线程在启动时去执行的工作, 是新线程空间上的第一个方法. 它一定要长成这个样子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 会被新线程执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程怎么会直到要先放上哪个方法? 因为<code>Runnable</code>定义了一个协约. 因为<code>Runnable</code>定义了一个协约. 它自己是一个接口, 线程的任务可以被定义在任何实现<code>Runnable</code>的类上. 线程只在乎传入给<code>Thread</code>的构造函数的参数是否为实现<code>Runnable</code>的类.</p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        doMore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;top o&#x27; the stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;back in main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程有三种状态, 即<strong>新建</strong>、<strong>可执行</strong>和<strong>执行中</strong>. 当线程进入可执行状态, 它就会在可执行与执行中两种状态中来回转变.</p>
<h4 id="可执行-x2F-执行中循环"><a href="#可执行-x2F-执行中循环" class="headerlink" title="可执行&#x2F;执行中循环"></a>可执行&#x2F;执行中循环</h4><p>普通线程会在可执行与执行中两个状态中来回交替. 因为Java虚拟机的线程调度会把线程挑出来运行又把它踢回去让其他的线程有执行机会.</p>
<h4 id="线程有可能会暂时被挡住"><a href="#线程有可能会暂时被挡住" class="headerlink" title="线程有可能会暂时被挡住"></a>线程有可能会暂时被挡住</h4><p>调度器(scheduler)会因为某些原因暂停执行一个线程.</p>
<h3 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a>线程调度器</h3><p>线程调度器会决定哪个线程从等待状况中被挑出来运行, 以及何时把哪个线程送回等待被执行的状态.</p>
<p>但是, 不同虚拟机上的调度器有着不同的工作逻辑, 故我们的程序不能依靠调度的特定行为来保持执行的正确性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        doMore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;top of the stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;back in main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="让线程小睡一下"><a href="#让线程小睡一下" class="headerlink" title="让线程小睡一下"></a>让线程小睡一下</h3><p>确保线程能够有机会执行的最好方式是让它们周期性地去睡一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>但是在这个方法有可能会抛出<code>InterruptedException</code>异常, 所有对它的调用都必须包含在<code>try/catch</code>块中. 因此, 真正的程序代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(实际上, 我们通常不必刻意使用<code>sleep()</code>来保证其他的线程会被执行. 这是一个很复杂的问题, 详见一些专门论述Java多线程的书籍.)</p>
<h3 id="建立与启动两个线程"><a href="#建立与启动两个线程" class="headerlink" title="建立与启动两个线程"></a>建立与启动两个线程</h3><p>线程可以有名字. 下面的例子中有两个线程. 它们都执行相同的工作: 在循环中列出线程的名字.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunThreads</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunThreads</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunThreads</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">alpha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">beta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">        alpha.setName(<span class="string">&quot;Alpha Thread&quot;</span>);</span><br><span class="line">        beta.setName(<span class="string">&quot;Beta Thread&quot;</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; is running .&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程的并发性问题"><a href="#多线程的并发性问题" class="headerlink" title="多线程的并发性问题"></a>多线程的并发性问题</h3><p>并发性会引发竞争状态, 进而引发数据的损毁. 这一切都来自于一种完全可能的状况, 即两个或以上的线程存取单一对象的数据. 也就是说, 两个不同执行空间上的方法都在堆上对同一个对象执行<code>getter</code>或<code>setter</code>.</p>
<p>为了解决这个问题, 我们需要设计一把锁, 使得每个方法在同时只能被一个线程调用. 这把锁就是<code>synchronized</code>.</p>
<p><code>synchronized</code>关键词代表线程需要一把钥匙来存取被同步化(synchronized)过的线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">makeWithdrawal</span><span class="params">(<span class="type">int</span> amount)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步化的死锁问题"><a href="#同步化的死锁问题" class="headerlink" title="同步化的死锁问题"></a>同步化的死锁问题</h4><p>如同步化的定义所述, 它会确保在需要的方法执行完毕前不执行任何其他操作. 问题来了: 如果那个”需要的方法”的执行需要某个被同步化确保不执行的内容怎么办? 这就完蛋了. 程序会永远地等下去. 这就是所谓的死锁.</p>
<p>Java没有处理死锁的机制, 想要尽可能地避免死锁只能依赖良好的多线程程序设计. 推荐阅读O’Relly出版的<em>Java Thread</em>, 上面对包括死锁在内的许多有关Java多线程的知识进行了清晰的论述.</p>
<h2 id="集合与泛型"><a href="#集合与泛型" class="headerlink" title="集合与泛型"></a>集合与泛型</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-09T14:16:43.000Z" title="2022/6/9 22:16:43">2022-06-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-12T13:10:05.468Z" title="2022/6/12 21:10:05">2022-06-12</time></span><span class="level-item">3 minutes read (About 386 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/09/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSS学习笔记</a></h1><div class="content"><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><h3 id="CSS实例"><a href="#CSS实例" class="headerlink" title="CSS实例"></a>CSS实例</h3><p>CSS规则由两个主要的部分构成: 选择器, 以及一条或多条声明. 其中, 选择器通常是需要改变样式的HTML元素, 而声明则是一个属性和一个值. 属性是希望设置的样式属性. 每一个属性都有一个值. 属性和值被冒号分开.<br><code>h1 &#123;color:blue; font-size:12px;&#125;</code></p>
<p>CSS声明总是以分号’;’结束, 声明总是以大括号’{}’括起来.</p>
<p>为了让CSS可读性更强, 可以每行只描述一个属性:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h3><p>在CSS中, 注释以’&#x2F;<em>‘开始, 以’</em>&#x2F;‘结束:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是一个注释*/</span></span><br><span class="line"><span class="selector-tag">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="comment">/*这是另一个注释*/</span></span><br><span class="line">    <span class="attribute">color</span>:black;</span><br><span class="line">    <span class="attribute">font-family</span>:arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSSid和Class"><a href="#CSSid和Class" class="headerlink" title="CSSid和Class"></a>CSS<code>id</code>和<code>Class</code></h2><p>如果要在HTML元素中设置CSS样式, 你需要在元素中设置”id”和”class”选择器.</p>
<h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a><code>id</code>选择器</h3><p><code>id</code>选择器可以为标有特定id的HTML元素制定特定的样式. HTML元素以<code>id</code>属性来设置<code>id</code>选择器. CSS中, id选择器以”#”来定义.</p>
<p>以下的样式规则应用于元素属性<code>id=&quot;para1&quot;</code>:  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#para1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: ID属性不要以数字开头. 数字开头的ID在火狐浏览器中不起作用.</p>
<h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a><code>class</code>选择器</h3><p><code>class</code>选择器用于描述一组元素的样式. 有别于<code>id</code>选择器, <code>class</code>选择器可以在多个元素中使用.</p>
<p><code>class</code>选择器在HTML中以<code>class</code>属性表示, 在CSS中, 类选择器以一个点号<code>.</code>显示.</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Arnold Miao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Arnold Miao</p><p class="is-size-6 is-block">Learner</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China, Asia</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-28T02:32:59.000Z">2022-06-28</time></p><p class="title"><a href="/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">算法入门</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-19T06:29:11.000Z">2022-06-19</time></p><p class="title"><a href="/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/">Java核心技术卷1</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-12T13:12:09.000Z">2022-06-12</time></p><p class="title"><a href="/2022/06/12/java/">Java学习笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-09T14:16:43.000Z">2022-06-09</time></p><p class="title"><a href="/2022/06/09/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CSS学习笔记</a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 Arnold Miao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>