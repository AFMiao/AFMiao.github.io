{"pages":[],"posts":[{"title":"CSS学习笔记","text":"CSS语法CSS实例CSS规则由两个主要的部分构成: 选择器, 以及一条或多条声明. 其中, 选择器通常是需要改变样式的HTML元素, 而声明则是一个属性和一个值. 属性是希望设置的样式属性. 每一个属性都有一个值. 属性和值被冒号分开.h1 {color:blue; font-size:12px;} CSS声明总是以分号’;’结束, 声明总是以大括号’{}’括起来. 为了让CSS可读性更强, 可以每行只描述一个属性: 12345p{ color:red; text-align:center;} CSS注释在CSS中, 注释以’/‘开始, 以’/‘结束: 12345678/*这是一个注释*/p{ text-align:center; /*这是另一个注释*/ color:black; font-family:arial;} CSSid和Class如果要在HTML元素中设置CSS样式, 你需要在元素中设置”id”和”class”选择器. id选择器id选择器可以为标有特定id的HTML元素制定特定的样式. HTML元素以id属性来设置id选择器. CSS中, id选择器以”#”来定义. 以下的样式规则应用于元素属性id=&quot;para1&quot;: 12345#para1{ text-align:center; color:red;} 注意: ID属性不要以数字开头. 数字开头的ID在火狐浏览器中不起作用. class选择器class选择器用于描述一组元素的样式. 有别于id选择器, class选择器可以在多个元素中使用. class选择器在HTML中以class属性表示, 在CSS中, 类选择器以一个点号.显示.","link":"/2022/06/09/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Java核心技术卷1","text":"Java程序设计概述Java程序设计环境Java的基本程序设计结构字符串从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做String. 每一个用双引号括起来的字符串都是String类的一个实例. 子串String类的substring()方法可以从一个较大的字符串中提取出一个字串. 如: 12String greeting = &quot;Hello&quot;;String s = greeting.substring(0,3); substring()方法的第二个参数表示不想复制的第一个位置. 这里, 我们想要复制第0、1和2个字符. substring()的工作方式有一个优点: 容易计算字符串的长度. 字符串s.substring(a, b)的长度就是$b-a$. 拼接与绝大多数的程序设计语言一样, Java允许使用+号连接(拼接)两个字符串. 123String expletive = &quot;Expletive&quot;;String PG13 = &quot;deleted&quot;;String message = expletive + PG13; 上述代码讲”Expletivedeleted”赋值给了变量message. 当讲一个字符串与一个非字符串的值进行拼接时, 后者被转换成了字符串. 例如: 12int age = 13;String rating = &quot;PG&quot; + age; 此处, rating被赋值为13. 如果需要把多个字符串放在一起, 并用一个定界符分隔, 则可以使用静态join()方法: 1String all = String.join(&quot; / &quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;); 我们会得到内容为S / M / L / XL的字符串. 不可变字符串String类中没有提供可用于修改字符串的方法. 如果硬要修改, 可以把不需要修改的部分复制出来, 然后使用拼接的方法建立新的字符串. 不可变字符串的最大优点就是实现了字符串的共享. 字符串变量总是指向内存中的一块区域, 不论怎样复制字符串变量, 其所指向的内容都是相同的. 检测字符串是否相等可以使用equals()方法检测两个字符串是否相等. 对于表达式s.equals(t): 如果字符串s与字符串t相等, 则返回true; 反之则返回false. 需要注意的是, s和t既可以是字符串变量, 也可以是字符串字面量. 例如, &quot;Hello&quot;.equals(greeting)表达式是合法的. 想要在不区分大小写的条件下判断表达式是否合法, 我们可以使用equalsIgnoreCase()方法: 1&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;); 空串与null串空串&quot;&quot;是长度为零的字符串. 可以调用一下代码检查一个字符串是否为空: 1if (str.length() == 0) 或 1if (str.equals(&quot;&quot;)) 而null串是一种特殊的String变量, 它表示没有任何对象与该变量关联. 可用if (str == null)判断一个字符串是否为null. 码点与代码单元String API阅读联机API文档构件字符串有时需要较短的字符串构建字符串, 例如案件或来自文件中的单词. 采用字符串连接的方式达到此目的效率比较低, 因为每次连接字符串都要创建一个新的String对象, 费时又占空间. 使用StringBuilder类就可以避免这个问题的发生. 如果需要用许多小段的字符串构件一个字符串, 那么应该按照下列步骤进行. 首先, 构建一个空的字符串构建器: 1StringBuilder builder = new StringBuilder(); 当每次需要添加一部分时, 就调用append()方法. 12builder.append(ch);builder.append(str); 在需要构件字符串时就调用toString()方法, 将可以得到一个String对象, 其中包含了构建器中的字符序列. 1String completedString = builder.toString(); 输入输出读取输入想要通过控制台进行输入, 首先需要构造一个Scanner对象, 并与”标准输入流”System.in关联. 1Scanner in = new Scanner(System.in); 现在我们就可以使用Scanner类的各种方法实现输入操作了. 如使用nextLine()方法将读取一行的内容做输入: 12System.out.print(&quot;What is your name?&quot;);String name = in.nextLine(); 使用nextLine()的原因是输入行中有可能包含空格. 如果想要读取一个单词(以空白符作为分隔符), 就调用 1String firstName = in.next(); 要是想读取下一个整数, 就调用nextInt()方法; 如果想读取下一个浮点数, 就调用nextDouble()方法. 格式化输出文件输入与输出控制流程大数值数组for each循环Java有一种功能很强的循环结构, 可以用来依次处理数组中的每个元素(其他类型的元素几何也可)而不必为指定下标值而分心. 这种增强的for循环结构的格式为: 1for (variable : collection) statement 数值初始化以及匿名数组在Java中, 提供了一种创建数组对象并同时赋予初始值的简化书写形式. 下面是一个例子: 1int[] smallPrimes = {2, 3, 5, 7, 11, 13}; 甚至还可以初始化一个匿名的数组: 1new int[] {14, 23, 43, 45, 21, 45}; 这种表示法将创建一个新数组并利用括号中提供的值进行初始化, 数值的大小就是初始值的个数. 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组. 例如: 1smallPrimes = new int[] {13, 23, 5, 23, 42, 23}; 这是下列语句的简写形式: 12int[] anonymous = {123, 123, 42, 12, 54, 312};smallPrimes = anonymous; 数组拷贝在Java中, 允许将一个数组变量拷贝给另一个数组变量. 此时, 两个变量将引用同一个数组: 12int[] luckyNumbers = smallPrimes;luckyNumbers[5] = 12; 如果希望将一个数组的所有值拷贝到一个新的数组中去, 就需要使用Array类的copyOf方法: 1int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); 其中, 第二个参数是新数组的长度. 这个方法通常用来增加数组的大小: 1luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 如果数组元素是数值型, 那么多余的元素将被赋值为0; 如果数组元素是布尔型, 则将赋值为false. 相反, 如果长度小于原始数组的长度, 则只拷贝最前面的数组元素. 命令行参数每一个Java应用程序都有一个带String arg[]参数的main()方法. 这个参数表明main()方法将接收一个字符串数组, 也就是命令行参数. 数组排序想要对数值型数组进行排序, 可以使用Arrays类中的sort()方法: 123int[] a = new int[10000];...Arrays.sort(a); 这个方法使用了优化的快速排序算法. 多维数组多维数组将使用多个下标访问数组元素, 它适用于表示表格或更加复杂的排列形式. 在Java中, 声明一个二维数组相当简单. 例如: 1double[][] balances = new double[NYEARS][NRATES]; 如果知道数组元素, 就可以不调用new, 而可以直接使用简化的书写形式对多维数组进行初始化. 例如: 123456int[][] magicSquare = { {12, 3, 123, 34}, {123, 312, 43, 21}, {124, 634, 345, 2}, {845, 235, 542,54}}; 一旦数组被初始化, 就可以利用两个方括号访问每个元素. 注意, for each循环语句不能自动处理二维数组的每一个元素. 它是按照行, 也就是一位数组处理的. 想要访问二维数组a的所有元素, 则需要使用两个嵌套的循环, 如下图所示: 123for (double[] row : a) for (double value : row) statements; 不规则数组我们总是说”Java的多维数组”, 但实际上Java中没有多维数组, 只有一维数组. 多维数组实际上是”数组的数组”, 我们从前面数组magicSquare[]的声明方式就可以看出来. 由此, 我们就可以声明各列长度不一的数组. 对象与类面向对象程序设计概述类对象想要使用OOP(面向对象程序设计)就需要清楚对象的三种主要特性: 对象的行为: 可以对对象施加哪些操作, 或者可以对对象施加哪些方法? 对象的状态: 当施加方法时, 对象如何响应? 对象的标识: 如何辨别具有相同行为与状态的不同对象? 识别类类之间的关系类之间最常见的关系有三: 依赖、聚合以及继承. 依赖依赖是一种最明显而又最常见的关系. 比如, Order类使用Account类是因为Order对象需要访问Account对象查看信用; 但是Item类不依赖于Account类, 这是因为Item对象于客户账户无关. 总而言之, 如果一个类的方法操纵另一个类的对象, 我们就说一个类依赖于另一个类. 我们应该尽可能地将相互依赖的类减至最少, 用软件工程的术语来说, 就是让类之间的耦合度最小. 聚合聚合也是一种相对具体且易于理解的关系. 例如, 一个Order对象包含一些Item对象. 聚合关系意味着类A的对象包含类B的对象. 继承(后面会详细论述)继承是一种用于表示特殊于一般关系的. 使用预定义类方法参数Java总是采用按值调用, 即方法得到的是所有参数值的一个拷贝, 无法修改传递给它的任何参数变量的内容. 但是, 由于一个引用变量与其拷贝指向的都是一个对象, 我们可以很方便的利用方法改变对象的值. 对象构造重载默认域初始化如果在构造器中没有显示地为域赋予初值, 那么就会被自动地赋一个默认值: 数值为0、布尔值为null. 然而, 如果不明确地为域进行初始化, 就会影响程序代码的可读性. 显式域初始化通过重载类的构造器方法, 可以采用多种形式设置类的实例域的初始状态. 为确保不管如何调用构造器, 每个实例域都可以被设置一个有意义的初值. 1private String name = &quot;&quot;; 在执行构造器之前, 先执行赋值操作. 当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时, 这种方式特别有用. 初始值不一定是常量值. 在下面的例子中, 可以调用方法对域进行初始化. 12345678910public class Employee { private static int nextId; private int id = assignId(); private static int assignId() { int r = nextId; nextId++; return r; }} 参数名在编写很小的构造器时, 如何为参数命名是个问题. 通常用单个字符命名参数: 1234public Employee(String n, double s) { name = n; salary = s;} 但这样做有一个缺陷: 只有阅读代码才能够了解参数n和参数s的含义. 有些程序员会在每个参数前面加上一个前缀”a”: 1234public Emplyee(String aName, double aSalary) { name = aName; salary = aSalary;} 这样就比较清晰, 每个读者第一眼就能够看懂参数的含义. 还有一种基于如下事实的常用技巧: 参数变量用同样的名字将实例域屏蔽起来. 例如, 如果将参数命名为salary, salary将引用这个参数, 而不是实例域. 但是, 可以采用this.salary的形式访问实例域. this指隐式参数, 也就是所构造的对象. 下面是一个例子: 1234public Employee(String name, double salary) { this.name = name; this.salary = salary;} 调用另一个构造器关键字this引用方法的隐式参数. 然而, 这个关键字还有另外一个含义. 如果构造函数的第一个语句形如this(...), 则这个构造函数将调用同一个类的另一个构造函数. 下面是一个典型的例子: 12345public Employee(double s) { // calls Employee(String name, double salary) this(&quot;Employee #&quot; + nextId, s); nextId++;} 当调用new Employee(60000)时, Employee(double)构造函数将调用Employee(String, double)构造函数. 初始化块对象析构域finalize方法包文档注释类设计技巧继承类、父类和子类定义子类覆盖方法父类中的方法并不一定完全适合子类. 我们以Employee类和Manager类为例展开论述一下该问题. Manager类中有一个getSalary()方法, 可以返回薪水和奖金的总和. 但是其父类Employee类中的getSalary()方法做不到这一点. 所以, 我们需要写一个方法覆盖(override)掉父类中的这个方法: 12345public class Manager extends Employee { public double getSalary() { ... }} 究竟应该如何实现这个方法呢? 看起来似乎很简单, 只需要返回salary和bonus的和就可以了. 123public double getSalary() { return salary + bonus;} 但是这个方法并不能运行. 这是因为Manager类的getSalary()方法不能直接访问父类的私有域. 也就是说, 尽管每个Manager对象都拥有一个名为salary的域, 但是在Manager类的getSalary()方法中并不能够直接访问salary. 只有Employee类的方法才能够访问私有部分. 如果Manager类的方法一定要访问私有域, 就必须借助于公有的接口, Employee类中的公有方法getSalary()方法就是这样的一个接口. 现在我们再用getSalary()方法试一下: 1234public double getSalary() { double baseSalary = getSalary(); return baseSalary + bonus;} 但是这个方法还是不能运行. 问题出在getSalary()方法上: Manager类也有一个getSalary()方法, 也就是正在执行的这个方法. 如果我们真的这么写了的话, 整个程序就会陷入无限的自我调用中, 最终程序崩溃. 所以, 当我们想要调用父类的某个方法(这里是getSalary()方法)时, 我们需要告诉编译器, 我们需要的是父类的方法. 这一需求可以通过关键字super实现: 1super.getSalary(); 如此, 我们调用的就不是Manager类中的、而是Employee类中的getSalary()方法. 以下是Manager类中getSalary()方法的正确编写方式: 1234public double getSalary() { double baseSalary = super.getSalary(); return baseSalary + bonus;} 在子类中, 我们可以增加域、增加方法或覆盖父类中的方法, 但是不可能删除所继承的任何域和方法. 子类构造函数继承层次多态有一个用来哦按段是否应该设计继承关系的简单规则, 即”IS-A”规则. 它侧面表明了每个子类对象同时也是其父类的对象. “IS-A”规则的另一种表述法是置换法则. 它表明程序中出现父类对象的任何地方都可以用子类对象置换. 例如, 可以将一个子类的对象赋给父类变量. 123Employee e;e = new Employee(...);e = new Manager(...); 在Java中, 对象变量是多态的. 一个Employee变量既可以引用一个Employee类对象, 也可以引用一个Employee类的任何子类对象. 在下面的程序中: 123Manager boss = new Manager(...);Employee[] staff = new Employee[3];staff[0] = boss; , 变量staff[0]与boss引用同一个对象. 但编译器将staff[0]看作Employee对象. 这意味着, 我们可以这样调用: 1boss.setBonus(5000); 但是不能这样调用: 1staff[0].setBonus(5000); 因为staff[0]是一个Employee类引用变量, 不能调用不属于Employee类的方法getBonus(). 理解方法调用阻止继承: final类和方法有时候, 可能希望阻止人们利用某个类定义子类. 不允许扩展的类的类被称为final类. 如果在定义类的时候使用了final修饰符就表明这个类是final类. 例如, 假设希望组织人们定义Executive类的子类, 我们就可以在定义这个类的时候使用final修饰符声明. 声明格式如下: 123public final class Executive extends Manager { ...} 类中的特定方法也可以被声明为final. 如果这样做, 子类就不能覆盖这个方法(final类中的所有方法自动地称为final方法). 例如: 12345public class Employee { public final String getName() { return name; }} 将方法或类声明为final主要目的是: 确保它们不会在子类中改变语义. 例如, Calendar类中的getTime()和setTime()方法都生命为final. 这表明Calendar类的设计者负责实现Date类与日历状态之间的转换, 而不允许子类处理这些问题. 同样地, String类也是final类. 这意味着任何人都不能定义String类的子类. 强制类型转换就像primitive基本类型数据的类型转换一样, 不同类的引用变量之间也可以进行类型转换, 如: 1Manager boss = (Manager) staff[0]; 我们进行类型转换的唯一原因为: 在暂时忽视对象的实际类型之后, 使用对象的全部功能. 例如, 在managerTest类中, 由于某些项是普通雇员, 所以staff数组必须是Employee对象的数组. 我们需要将数组中引用经理的元素复原成Manager类, 以便能够访问新增加的所有变量. 在Java中, 每个对象变量都属于一个类型. 将一个值存入变量时, 编译器将检查该操作是否合法. 将一个子类对象赋给一个父类引用变量, 这是合法的; 将一个父类对象赋给一个子类引用变量, 这就是不合法的. 我们需要养成如下的良好习惯: 在进行类型转换之前, 先查看一下是否能够成功地转换. 这个过程十分简单, 只需要使用instanceof操作符就可以实现. 例如: 1234if (staff[1] instanceof Manager) { boss = (Manager) staff[1]; ...} 如果检查不通过, 编译器就不会进行这个转换. 综上所述: 只能在继承层次内进行类型转换; 在将父类转换成子类之前, 应该使用instanceof进行检查. 需要注意的是, 如果x为null, 在进行instanceof时只会返回false, 并不会产生任何异常. 实际上, 通过类型转换调整对象的类型并不是一种好的做法, 应将类型转换限制在仅在需要调用子类中特有的的方法时进行. 但是, 在出现这种情况时, 我们首先需要做的就是检查父类设计, 在父类中添加需要的方法, 这才是比较正确的选择. 抽象类受保护访问我们常说, 最好将类中的实例变量标记为private, 而方法标记为public. 任何声明为private的内容对其他类都是不可见的, 就连自己的子类也不能访问父类的私有域. 然而, 在某些时候, 我们希望父类中的某些方法允许被子类访问, 或者允许子类的方法访问父类中的某个域. 为此, 我们需要将这些方法或域标记为protected. 例如, 如果将超类Employee中的hireDay声明为protected, 而非private, 其子类Manager中的方法就可以直接访问它. 不过, 就算标记了protected, 子类Manager也只能访问Manager对象中的hireDay()方法, 而不能访问其他Employee对象中的hireDay(), 对于被标记了protected的其他域也有相同的结论. 在实际应用中应谨慎使用protected属性. 假设需要将设计的类提供给其他程序员使用, 而这个类中设置了一些保护域, 由于其他程序员可以由这个类再派生出新类, 并访问其中的受保护域, 则如果需要对这个类的实现进行修改, 就需要通知所有使用这个类的程序员. 这与OOP的数据封装原则相悖. 受保护的方法更具有实际意义. 如果需要限制某个方法的使用, 就可以将它声明为protected. 这表明子类(可能很熟悉祖先类)得到信任, 可以正确地使用这个方法, 而其他类则不行. 这种方法的最好例子就是Object类中的clone方法, 我们会在后面的相关章节展开论述. 归纳一下Java用于控制可见性的四个修饰符: 仅对本类可见: private; 对所有类可见: public; 对包和所有子类可见: protected; 对本包可见: 默认, 无需修饰符. Object: 所有类的父类Object类是Java类中所有类的始祖, 所有的类都是由它扩展来的. 因此, 了解这个类所提供的所有服务非常重要. equals()方法Object类中的equals()方法用于检测一个对象是否等于另外一个对象. 在Object类中, 这个方法将判断两个对象是否具有相同的引用: 如果两个对象具有相同的引用, 则它们一定是相等的. 然而, 对于绝大多数类来说, 这种判断是没有意义的. 例如: 采用这种方法判断两个PrintStream对象是否相等就是完全没有意义的. 通常需要的是判断两个对象的状态是否相等. 如果两个对象的状态是相等的, 就认为这两个对象是相等的. 相等测试与继承如果隐式和显式的参数不属于同一个类, equals()方法将会如何处理呢? 这是一个很有争议的问题. Java语言规范要求equals()方法具有下面的特性: 自反性: 对于任何非空引用x, x.equals(x)应该返回true; 对称性: 对于任何x和y, 当且仅当y.equals(x)返回true, x.equals(y)也应该返回true; 传递性: 对于任何x、y和z, 如果x.equals(y)返回true, y.equals(z)返回true, x.equals(z)也应该返回true; 一致性: 如果x和y引用的对象没有发生变化, 反复调用x.equals(y)应该返回同样的结果; 对于任何非空引用x, x.equals(null)应返回false. 这些规则是比较合理的, 因为其避免了类库实现者在数据结构中定位一个元素时还要考虑调用x.equals(y), 还是调用y.equals(x)的问题. 但是, 但就对称性而言, 当比较两者不属于同一个类时, 我们需要仔细考虑一下. 1e.equals(m); 这里的e是一个Employee对象, m是一个Manager对象, 并且两个对象具有相同的姓名、薪水和雇佣日期. 如果在Employee.equals()中使用instanceof进行检测, 则返回true. 然而, 当我们反过来调用时, 1m.equals(e); 根据对称性, 我们也需要返回true. 这就使得Manager类的equals()方法必须能够用自己与任何一个Employee对象进行比较, 忽视了自己所拥有的特有信息. 这无疑是不合理的. 本书认为: 如果子类能够拥有自己的相等的概念, 则对称性要求强制采用getClass()进行检测; 如果由父类决定相等的概念, 那么就可以使用instanceof进行检测, 这样可以在不同的对象之间进行相等的比较. 同时, 本书给出一个比较合理的编写equals()方法的建议: 显示参数命名为otherObject, 稍后需要将他转换成另一个叫做other的变量; 检测this与otherObject是否引用同一个对象; 检测otherObject是否为null, 如果为null, 则返回false; 比较this与otherObject是否属于同一个类; 将otherObject转换为相应的类类型变量; 对所有需要比较的域进行比较. 如果所有的域都匹配, 就返回true; 反之, 则返回false. hashCode()方法哈希值(Hash Code)是由对象导出的一个整型值, 无规律可言. 这使得两个不同对象的哈希值基本不会相等. String类使用下列算法计算哈希值: 1234int hash = 0;for (int i = 0; i &lt; length(); i++) { hash = 31 * hash + charAt(i);} 由于hashCode()方法定义在Object类中, 因此每个对象都有一个默认的哈希值, 其值为该对象的存储地址. 请看下面的例子: 123456String s = &quot;OK&quot;;StringBuilder sb = new StringBuilder(s);System.out.println(s.hashCode() + &quot; &quot; + sb.hashCode());String t = new String(&quot;OK&quot;);StringBuilder tb = new StringBuilder(t);System.out.println(t.hashCode() + &quot; &quot; + tb.hashCode()); 结果如下: 变量名 哈希值 s 2524 sb 460141958 t 2524 tb 1163157884 我们可以发现, 字符串s和t拥有相同的哈希值, 这是因为字符串的哈希值是由内容导出的; 但是字符串缓冲sb和tb却有着不同的哈希值, 这是因为StringBuilder类总没有定义hashCode()方法, 故调用的实际上是Object类的默认hashCode()方法, 获得的即为其自身的存储地址. 如果重新定义equals()方法, 我们就必须重新定义hashCode()方法, 以便用户可以将对象插入到哈希表中(具体内容会在后面详细论述). hashCode()方法应该返回一个整型数值(可以为负), 并合理地组合实例域的哈希值, 以便能够让各个不同的对象产生的哈希值更加均匀. 例如下面就是Employee类的hashCode()方法: 12345public int hashCode() { return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode();} 该方法还有改进的空间. 首先, 最好使用null安全的Object.hashCode(). 如果其参数为null, 这个方法会直接返回0, 否则返回对参数调用hashCode()的结果. 其次, 可以使用静态方法Double.hashCode()方法来避免创建Double对象: 12345public int hashCode() { return 7 * Object.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Object.hashCode(hireDay);} 还有改进的空间. 需要组合多个哈希值时, 可以调用Objects.hash()并提供多个参数. 这个方法会对各个参数调用Object.hashCode(), 并组合这些哈希值. 如此, Employee.hashCode()方法可以被简单地写为: 123public int hashCode() { return Objects.hash(name, salary, hireDay);} toString()方法在Object中还有一个重要的方法, 即toString()方法. 它用于返回表示对象值的字符串. 下面是一个典型的例子: Point类的toString()方法将返回下面这样的字符串: 1java.awt.Point[x=10,y=20] 绝大多数的toString()方法都遵循这样的格式: 类的名字, 随后是一对方括号括起来的域值. 下面是Employee类中的toString()方法的实现: 123456public String toString() { return &quot;Employee[name=&quot; + name + &quot;, salary=&quot; + salary + &quot;, hireDay=&quot; + hireDay + &quot;]&quot;;} 实际上, 该方法还有改进空间. 最好通过掉调用getClass().getName()方法获得类名的字符串, 而不要将类名硬加到toString()方法中. 1234567public String toString() { return getClass().getName() + &quot;[name=&quot; + name + &quot;, salary=&quot; + salary + &quot;, hireDay=&quot; + hireDay + &quot;]&quot;;} 设计子类的程序员也应该定义自己的toString()方法, 并将子类域的描述添加进去. 如果父类中使用了getClass().getName(), 那么子类只要调用super.toString()方法就可以了. 1234567public class Manager extends Employee { public String toString() { return super.toString() + &quot;[bonus=&quot; + bonus + &quot;]&quot;; }} toString()方法如此常见的原因为: 只要对象域一个字符串通过操作符”+“连接起来, Java编译器就会自动调用toString()方法, 以便获得这个对象的字符串描述. 此外, 对于任意对象x, 使用println(x)方法就会直接调用x.toString(), 并打印输出得到的字符串. 泛型数组列表如何动态调整数组大小一直是一个让程序员头疼的问题. 幸好, 在Java中, 有一个名为ArrayList的类, 能够很好地解决这个问题. ArrayList类是一个采用类型参数(type parameter)的泛型类(generic class). 为了指定数组列表保存的元素对象类型, 需要用一对尖括号将类名括起来加在后面. 下面的代码声明和构造了一个保存Employee类对象的数组列表: 1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); 既然两边都使用Employee, 重复输入多少有些繁琐, 故在Java SE 7中, 可省去右侧的类型参数: 1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); 使用add()方法可以将元素添加到数组列表中. 1staff.add(new Employee(...)); ArrayList类最大的优点在于其可以自动调整内部数组的大小. 但是, 如果已经清楚或能够估计出数组可能储存的元素数量, 我们就可以在填充数组之前调用ensureCapacity()方法: 1staff.ensureCapacity(100); 这个方法将分配一个包含100个对象的内部数组. 然后调用100次add(), 而不用重新分配空间. 另外, 还可以将初始容量传递给ArrayList构造器: 1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100); size()方法将返回ArrayList中包含的实际元素数量. 此外, 一旦确定ArrayList的大小不再发生变化, 就可以调用trimToSize()方法. 这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目, 垃圾回收器也会回收多余的存储空间. 访问数组列表元素想要访问或改变ArrayList元素, 需要使用get或set方法. 比如改变第i个元素的内容: 1staff.set(i, harry); 只有i小于或等于ArrayList大小时才能调用set()方法. 此外, 当没有泛型类时, 原始的ArrayList类提供的get()方法别无选择, 只能返回Object对象. 从这类ArrayList中调用出来的对象需要进行类型转换: 1Employee e = (Employee) staff.get(i); 类型化域原始数组列表的兼容性在我们自己的代码中, 我们可能更愿意使用类型参数来增加安全性. 在本节中, 我们会了解如何与没有使用类型参数的遗留代码交互操作. 假设有下面这个遗留下来的代码: 1234public class EmployeeDB { public void update(ArrayList list) {...} public ArrayList find(String query) {...}} 可以将一个类型化的数组传递给update()方法, 而不需要进行任何类型转换; 也可以将下面的staff对象传递给updates()方法. 12ArrayList&lt;Employee&gt; staff = ...;employeeDB.update(staff); 但是实际上, 这样调用说不上安全. 在update()方法中, 添加到ArrayList中的不一定是Employee对象. 编译器并不会发现这个问题, 但是在对这些元素进行检索的时候就会报错. 相反地, 将一个原始ArrayList赋给一个类型化ArrayList就会得到一个警告. 此外, 就算使用了类型转换也并不能避免出现警告: 1ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query); 我们只能受到一个警告信息, 提醒我们类型转换有误. 这是Java中不尽如人意的参数化类型的限制所带来的结果. 处于兼容性的考虑, 编译器在对类型转换进行检查之后, 如果没有发现违反规则的现象, 就将所有的类型化数组 列表转换成原始ArrayList对象. 在程序运行时, 所有的ArrayList都是一样的, 即没有虚拟机中的类型参数. 因此, 在执行将ArrayList转化为ArrayList&lt;Employee&gt;的操作时, 编译器将执行相同的运行时检查. 此时我们无需多做什么, 只要在与剩下的代码进行交叉操作时, 研究一下比那一起的警告提示, 并确保这些警告不会造成太严重的后果就可以了. 一旦确保不会造成严重后果, 可以用@SuppressWarnings(&quot;unchecked&quot;)标注来标记这个变量能够接收类型转换, 如下所示: 1@SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query); 对象包装器与自动装箱有时需要将int这样的基本类型转换为对象. 每个primitive主数据类型都有一个包装用的类, 名为包装器(wrapper), 且这些包装类都放在Java.lang这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示: primitive主数据类型名称 包装类名称 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double 对象包装器是不可变的, 即一旦构造了包装器, 就不允许改变包装在其中的值. 同时, 对象包装类还被标记为final, 无法被继承. 此外, 还有一个很有用的特性, 使得向ArrayList&lt;Integer&gt;中添加int元素的过程更加方便. list.add(3)将被自动地转换为 1list.add(Integer.valueOf(3)); 这种转换被称为自动装箱(autoboxing). 相反地, 将一个Integer对象赋值给一个int值时, 就会进行自动拆箱, 即将int n = list.get(n)翻译成 1int n = list.get(i).intValue(); 甚至在算数表达式中自动拆装箱也是成立的. 比如, 下面的这个表达式是合法的: 12Integer n = 3;n++; 大多数情况下, 容易有一种假象, 即基本类型与它们的对象包装器是一样的, 只是它们的相等性不同. 大家知道, ==运算符也可以应用于对象包装器对象, 只不过检测的是对象是否指向同一个存储区域, 因此, 下面的比较通常不会成立: 123Integer a = 1000;Integer b = 1000;if (a == b) {...} 的确相等表达式有时会成立, 但是我们的程序不能建立在这种可能上. 如果真的要判断两个Integer对象是否相等的话, 还是需要使用equals()方法. 还有几点有关自动装箱的事情需要注意的. 首先, 由于包装类引用可以为null, 所以自动装箱有可能会抛出一个NullPointerException异常: 12Integer n = null;System.out.println(2*n); 另外, 如果在一个条件表达式中混用Integer和Double类型, Integer值就会拆箱, 提升为double, 并在此装箱为Double. 最后, 自动拆装箱是编译器认可的, 和JVM没有什么关系. 编译器在生成的字节码中添加一些必要的方法调用, 而虚拟机只是忠实地执行这些字节码罢了. 参数数量可变的方法枚举类下面是一个典型的枚举类的例子: 1public enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE}; 此声明定义了一个有着四个实例的类, 在此尽量不要构造新对象. 因此, 在比较两个枚举类型的值时直接使用==即可. 如有需要, 可以在枚举类中添加一些构造器、方法和域. 当然, 构造器只在构造枚举常量时被调用. 下面是一个例子: 123456789public enum Size { SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;); private String abbreviation; private Size(String abbreviation) {this.abbreviation = abbreviation;} public String getAbbreviation() {return abbreviation;}} 所有的枚举类都是Enum类的子类. 它们继承了这个类的许多方法, 其中最有用的就是toString()方法. 这个方法能够返回枚举常量名. 例如, Size.SMALL.toString()将返回字符串”SMALL“. toString()的逆方法是静态方法valueOf(). 例如, 语句 1Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;); 将会把s设置为Size.SMALL. 每个枚举类都有一个静态的values方法, 它将返回一个包含全部枚举值的数组. 例如, 如下调用: 1Size[] values = Size.values() 将返回包含元素Size.SMALL, …和Size.EXTRA_LARGE的数组. ordinal()方法返回enum生命中枚举常量的位置, 索引从零开始计数. 反射继承的设计技巧 将公共操作和域放在父类; 不要使用受保护的域; 使用继承实现”IS-A”关系 除非所有继承的方法都有意义, 否则不要使用继承 在覆盖方法时, 不要改变预期的行为 使用多态, 而非类型信息 不要过多地使用反射 接口、lambda表达式域内部类接口接口概念在Java程序设计语言中, 接口不是类, 而是对类的一组需求描述. 这些类要遵从接口描述的统一格式进行定义. 我们经常听到服务提供商这样说: “如果类遵从某个特定接口, 那么就旅行这项服务”. 下面给出一个具体的示例: Arrays类中的sort()方法承诺可以对对象数组进行排序, 但要求对象所述的类必须实现了Comparable接口. 下面是Comparable接口的代码: 123public interface Comparable { int compareTo(Object other);} 这就是说, 任何实现Comparable接口的类都需要包含comparaTo()方法, 并且这个方法的参数必须是一个Object对象, 返回一个整型数值.] 接口中的所有方法自动地属于public. 因此, 在接口中声明方法时, 不必提供关键字public. 当然, 接口中还有一个没有明确说明的附加要求: 在调用x.compareTo(y)的时候, 这个compareTo()方法必须确实比较两个对象的内容, 并返回比较的结果. 当x小于y时, 返回一个负数; 当x等于y时, 返回0; 否则返回一个正数. 上面这个接口只有一个方法, 而有些接口可能包含多个方法. 稍后可以看到, 在接口中还可以定义常量. 然而, 更为重要的是要知道接口不能提供哪些功能. 接口绝不能含有实例域——提供实例域和方法实现的任务应交由实现接口的那个类来完成. 现在, 假设希望使用Arrays类的sort()方法对Employee对象数组进行排序, Employee类就必须实现Comparable接口. 为了让类实现一个接口, 通常需要下面两个步骤: 将类声明为实现给定的接口; 对接口中的所有方法进行定义. 要将类声明为实现某个接口, 需要使用关键字implements: 1public class Employee implements Comparable 当然, 这里的Employee类需要提供compareTo()方法. 假设希望根据雇员的薪水进行比较. 一下是compareTo()方法的实现: 1234public int compareTo(Object o) { Employee other = (Employee) o; return Double.compare(salary, other.salary);} 在这里, 我们使用了静态方法Double.compare()方法. 如果第一个参数小于第二个参数, 它会返回一个负值; 如果二者相等则返回0; 否则返回一个正值. 需要注意的是: 在接口声明中, 没有将compareTo()方法声明为public, 这是因为接口中的所有方法都默认为public. 不过, 在实现接口时, 我们需要将方法声明为public; 否则, 编译器将认为这个方法的访问属性为default, 之后编译器就会给出视图提供更严格的访问权限的警告信息. 此外, 我们还可以更进一步, 为泛型Comparable接口提供一个类型参数: 1234567public class Employee implements Comparable&lt;Employee&gt;{ private double salary; public int compareTo(Employee o) { return Double.compare(salary, o.salary); }} 这里要提一嘴的是, 对Object参数进行强制类型转换的行为现在已经不常见了. 综上所述, 我们已经看到, 要让一个类使用排序服务必须让它实现compareTo()方法. 这是很有必要的, 因为需要向sort()方法提供对象的比较方式. 但是, 为什么不直接在Employee类中直接提供一个compareTo()方法, 而必须实现Compareable接口呢? 原因在于Java是一种强类型语言. 在调用方法的时候, 编译器将会检查这个方法是否存在. 在sort()方法中可能存在下面这样的语句: 123if (a[i].compareTo(a[j]) &gt; 0) { // rearrange a[i] and a[j]} 为此, 编译器就必须确认a[i]中一定有compareTo()方法. 如果a是一个Comparable对象的数组, 就可以确保拥有compareTo()方法, 因为每个实现Comparable接口的类都必须提供这个方法的定义.\\ 接口的特性接口不是类, 尤其不能使用new运算符实例化一个接口. 但我们可以声明接口的引用变量: 1Comparable x; 接口引用变量必须引用实现了接口的类的对象: 1x = new Employee(...) // Employee implements Comparable 接下来, 如同使用instanceof检查一个对象是否属于某个特定类一样, 也可以使用instance检查一个对象是否实现了某个特定的接口: 1if (anObject instanceof Comparable) {...} 域可以建立类的继承关系一样, 接口也可以被扩展. 这里与允许存在多条从具有较高通用性的接口到较高专用性接口的链. 例如, 假设有一个称为Moveable的接口: 123public interface Moveable { void move(double x, double y);} 然后, 可以以它为基础扩展一个叫做Powered的接口: 123public interface Powered extends Moveable { double milesPerGallon();} 虽然在接口中不能包含实例域或静态方法, 但可以包含常量. 例如: 1234public interface Powered extends Moveable { double milesPerGallon(); double SPEED_LIMIT = 95;} 与接口中的方法都自动被设置为public一样, 接口中的域将被自动设为public static final. 有些接口中只定义了常量, 没有定义方法. 这样有助于在实现了该类接口的类中方便地调用常量. 但这样应用接口似乎有些偏离了接口概念的初衷, 不推荐这样使用. 尽管每个类都只能有一个超类, 但是可以同时实现多个接口. 这为定义类的行为提供了极大的灵活性. 接口与抽象类在本节中, 我们将重点论述抽象类与接口的区别. 我们在前面提出过一个疑问: 为什么Java要引入接口的概念? 为什么不将Comparable直接设计成如下所示的抽象类: 123abstract class Comparable { public abstract int compareTo(Object other);} 然后, Employee类再直接继承这个抽象类, 并提供compareTo()方法的实现呢? 主要原因是每个类只能继承一个类. 如果Employee类已经继承了一个类, 我们就不能再让它继承其他类; 但每个类可以实现多个接口, 如此就足够了. 静态方法在Java SE 8中, 允许在接口中增加静态方法. 理论上讲, 没有任何理由认为这是违法的——它只是有悖于接口作为抽象规范的初衷. 目前为止, 通常的做法都是将静态方法放在伴随类中. 在标准库中有着各式各样的接口和实用工具类, 如Collection/Collections或Path/Paths. 以Paths类为例, 其中只包含两个工厂方法. 可以由一个字符串序列构造一个文件或目录的路径, 如Path.get(&quot;jdk 1.8.0&quot;, &quot;jre&quot;, &quot;bin&quot;). 在Java SE 8中, 可以为Path接口增加以下方法: 123456public interface Path { public static Path get(String first, String... more) { return FileSystem.getDefault().getPath(first, more); } ...} 这样一来, Paths类就不是必要的了. 不过, 将整个Java库都以这种方式重构也是不太可能的. 但在实现我们自己的接口时, 不需要为实用工具另外提供一个伴随类. 默认方法可以为接口方法提供一个默认实现. 必须用default修饰符标记这样一个方法. 123public interface Comparable&lt;T&gt; { default int compareTo(T other) {return 0;}} 说实话, 默认方法并没有太大的用处, 因为最终每个Comparable的每一个实际实现都要覆盖掉这个默认方法. 但在某些情况下, 默认方法会发挥它的作用. 例如, 在Java事件处理中, 如果希望在发生鼠标点击事件时得到通知, 就要实现一个包含五个方法的接口: 1234567public interface MouseListener { void mouseClicked(MouseEvent event); void mousePressed(MouseEvent event); void mouseReleased(MouseEvent event); void mouseEntered(MouseEvent event); void mouseExited(MouseEvent event);} 在大多数情况下, 我们都只关心其中的一两个事件类型. 在Java SE 8中, 可以将所有方法都声明为默认方法. 这些默认方法什么都不做: 1234567public interface MouseListener { default void mouseClicked(MouseEvent event) {} default void mousePressed(MouseEvent event) {} default void mouseReleased(MouseEvent event) {} default void mouseEntered(MouseEvent event) {} default void mouseExited(MouseEvent event) {}} 这样一来, 我们就只需要实现我们关心的方法就可以了. 默认方法的另一个重要用法为”接口演化“(interface evolution). 以Collection接口为例, 这个接口作为Java的一部分已经有很多年了. 假设我们很久以前写了一个类: 1public class Bag implements Collection 后来, 我们又在Java SE 8中为该接口增加了一个stream方法. 如果这个stream方法不是一个默认方法, 则Bag类就不能编译, 因为他没有实现这个新方法. 为接口增加以恶非默认方法不能保证”源代码兼容”(source compatible). 不过, 假设不重新编译一个类, 而是使用原先的一个JAR文件, 这个类依旧能够正常加载. 不过, 如果程序在一个Bag实例上调用stream方法, 就会出现一个AbstractMethodError. 将方法实现一个默认方法就可以解决这两个问题. 此外, 如果没有重新编译而直接加载这个类, 并在一个Bag实例上调用stream方法, 将调用Collection.stream()方法. 解决默认方法冲突如果现在一个接口中将一个方法定义为默认方法, 然后又在父类或另一个接口中定义了同样的方法, 会发生什么情况? 对于这种情况, Java有着如下规定: 父类优先: 如果父类提供了一个具体方法, 同名而且有相同参数类型的默认方法会被忽略; 接口冲突: 如果一个父接口提供了一个默认方法, 另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法, 必须覆盖这个方法来解决冲突. 我们来研究一下第二个规则. 考虑另一个包含getName()方法的接口: 123interface Named { default String getName() {return getClass().getName() + &quot;_&quot; + hashCode();}} 如果有一个类同时实现了这两个接口会怎么样呢? 123class Student implements Person, Named { ...} 类会继承Person和Named接口提供的两个不一致的getName()方法. 我们只需要在Student类中提供一个getName()方法. 在这个方法中, 可以选择两个冲突方法中的一个, 如下所示: 123class Student implements Person, Named { public String getName() {return Person.super.getName();}} 现在我们假设Named接口没有为getName()提供默认实现: 123interface Named { String getName();} Student类会从Person接口继承默认方法吗? 不会的. Java更强调一致性. 两个接口是如何冲突的并不重要, 如果至少有一个接口提供了一个实现, 编译器就会报告错误, 而我们就必须解决这个二义性. 如果两个接口都没有为共享方法提供默认实现, 那么就与Java SE 8之前的情况一样, 不存在冲突. 实现类可以有两个选择: 实现这个方法, 或者干脆不实现. 如果是后一种情况, 这个类本身就是抽象的. 现在来讨论另外一种情况: 一个类继承了父类, 同时又实现了一个接口, 并从父类和接口继承了相同的方法. 例如, 假设Person是一个类, Student定义为: 1class Student extends Person implements Named {...} 在这种情况下, 编译器只会考虑父类方法, 所有接口的默认方法都将被忽略. 这就是”类优先”原则. “类优先”原则有助于确保程序与Java SE 7间的兼容性. 如果为一个接口增加默认方法, 这对于这个默认方法之前能够正常工作的代码不会有任何影响. 接口示例在接下来的三节中, 我们将学习接口的另外一些示例, 并从中进一步学习接口的实际使用. 接口与回调回调(callback)是一种常见的程序设计模式. 在这种模式中, 可以指出某个特定事件发生时应该采取的动作. 例如, 可以指出在按下鼠标或选择某个菜单项时应该采取什么行动. 然而, 由于我们还没有将接口部分介绍完, 所以我们只能讨论一些与上述功能类似且并简化的版本. 在java.swing包中有一个Timer类. 它可以在到达给定的时间间隔时发出通告. 例如, 加入程序中有一个时钟, 就可以请求每秒钟获得一个通告, 以便更新时钟的表盘. 在构造定时器时, 我们需要设置一个时间间隔, 并告知计时器, 当达到时间间隔时需要做些什么操作. 如何告知定时器做什么呢? 在Java中, 我们将某个类的对象传递给定时器, 然后定时器调用这个对象的方法. 由于对象可以携带一些附加的信息, 所以传递一个对象比传递一个函数要灵活的得多. 当然, 定时器需要知道调用哪一个方法, 并要求传递的对象所属的类实现了java.awt.event包的ActionListener接口. 下面是这个接口: 123public interface ActionListener { void actionPerformed(ActionEvent event);} 当达到指定的时间间隔时, 定时器就调用actionPerformed()方法. 假设希望每隔10秒钟打印一条信息”At the tone, the time is …”, 然后响一声, 就应该定义一个实现ActionListener接口的类, 然后将需要执行的语句放在actionPerformed()方法中. 1234567891011import java.awt.*;import java.awt.event.*;import java.util.Date;public class TimePrinter implements ActionListener { @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;At the tone, the time is &quot; + new Date()); Toolkit.getDefaultToolkit().beep(); }} 接下来, 构造这个类的一个对象, 并将它传递给Timer构造器. 12ActionListener listener = new TimePrinter();Timer t = new Timer(1000, listener); 其中, Timer构造器的第一个参数是发出通告的时间间隔, 单位为毫秒; 第二个参数是监听器对象. 最后, 启动定时器: 1t.start(); 于是, 我们就编写了一个每隔一秒显示一次当前时间并振铃的程序. 在下面的程序中, 我们给出了定时器和监听器的操作行为. 在定时器启动后, 程序将弹出一个消息对话框, 并等待用户点击OK按钮来终止程序的执行. 在程序等待用户操作的同时, 每隔10秒钟显示一次当前的时间. 需要注意的是, 该程序除了导入javax.swing.*和java.util.*外, 还通过类名导入了javax.swing.Timer. 这就消除了javax.swing.Timer与java.util.Timer之间的二义性, 其中, 后者是一个与本例无关的类, 主要负责调度后台任务. 123456789101112131415161718192021222324import java.awt.*;import java.awt.event.*;import java.util.*;import javax.swing.*;import javax.swing.Timer;public class TimerTest { public static void main(String[] args) { ActionListener listener = new TimerPrinter(); Timer t = new Timer(1000, listener); t.start(); JOptionPane.showMessageDialog(null, &quot;Quit program&quot;); System.exit(0); } static class TimerPrinter implements ActionListener { public void actionPerformed(ActionEvent e) { System.out.println(&quot;At the tone, the time is &quot; + new Date()); Toolkit.getDefaultToolkit().beep(); } }} Comparator接口在先前我们已经了解了如何对一个ArrayList排序, 前提是这些对象是实现了Comparable接口的类实例. 现在假设我们希望按长度递增的顺序对字符串进行排序, 而不是按字典顺序进行排序. 由于我们不可能对String类做出任何修改, 故我们需要另辟蹊径. Array.sort()方法还有第二个版本, 以一个数组和一个比较器(comparator)作为参数. 比较器是实现了Comparator接口的类的实例. 123public interface Comparator&lt;T&gt; { int compare(T first, T second);} 要按照长度比较字符串, 则可以定义一个以如下方式实现Comparator&lt;String&gt;的类: 12345class LengthComparator implements Comparator&lt;String&gt; { public int compare(String first, String second) { return first.length() - second.length(); }} 在具体完成比较时, 我们需要建立一个实例: 12Comparator&lt;String&gt; comp = new LengthComparator();if (comp.compare(words[i], words[j] &gt; 0)) {...} 该方法与words[i].compareTo(words[j])做比较. 这个compare方法要在比较器对象上调用, 而不是在字符串对象本身上调用. 对象克隆——Cloneable接口鸽了. lambda表达式为什么引入lambda表达式lambda表达式是一个可传递的代码块, 可以在以后执行一次或多次. 在前面的章节中我们已经了解了如何按指定时间间隔完成工作. 将这个工作放在ActionListener的actionPerformed()方法中: 12345class Worker implements ActionListener { public void actionPerformed(ActionEvent event) { // do something }} 在想要反复执行这个代码时, 可以构造Worker类的一个实例, 然后将这个实例提交到一个Timer对象. 这里的重点是actionPerformed()方法包含希望以后执行的代码. 或者可以考虑如何用一个定制比较器完成排序. 如果想按长度而不是默认的字典顺序对字符串排序, 可以向sort()方法传入一个Comparator对象: 1234567class LengthComparator implements Comparator&lt;String&gt; { public int compare(String first, String second) { return first.length() - second.length(); }}...Arrays.sort(string, new LengthComparator()); comparator()方法并不会被立即调用. 实际上, 在数组完成排序之前, sort()方法会一直调用compare()方法, 只要元素的顺序不正确就会重新排列元素. 将比较元素所需的代码段放在sort()方法中, 这个代码与其余的排序逻辑继承. 这两个例子有一些二共同点, 即都是将一个代码块传递到某个对象(一个定时器, 或者一个sort()方法). 这个代码块会在将来某个时间调用. 到目前为止, 在Java中传递一个代码段并不容易, 不能直接传递代码段, 毕竟Java是一种面向对象的语言. 所以必须构造一个对象, 这个对象的类需要有一个方法能包含所需的代码. 但是, lambda表达式解决了这个问题. lambda表达式的语法再考虑上一节讨论的例子. 在compare()方法中, 我们需要实现计算: 1first.length() - second.length() first和second是什么? 它们都是字符串. Java是一种类型语言, 所以我们还需要指定它们的类型: 12(String first, String second) -&gt; first.length() - second.length(); 这就是我们编写的第一个lambda表达式. lambda表达式就是一个代码块, 以及必须传入代码的变量规范. 其编写规范为: 参数, 箭头(-&gt;)以及一个表达式. 如果代码要完成的计算无法放在一个表达式中, 就可以像写方法一样, 把这些代码放在{}中, 并包含显式的return语句. 例如: 12345(String first, String second) -&gt; { if (first.length() &lt; second.length()&gt;) return -1; else if (first.length() &gt; second.length()) return 1; else return 0;} 注意: 如果一个lambda表达式只在某些分支中返回一个值, 而在另外一些分支不返回值, 这是不合法的. 即使lambda表达式没有参数, 仍然要提供空括号, 就像无参数方法一样: 1() -&gt; {for (int i = 100; i &gt;= 0; i--) System.out.println(i);} 如果可以推导出一个lambda表达式的参数类型, 则可以忽略其类型. 例如: 1Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); 在这里, 编译器可以推导出first和second必然是字符串, 因为这个lambda表达式将赋给一个字符串比较器. 如果方法只有一个参数, 而且这个参数的类型可以推到得出, 那么甚至还可以忽略小括号: 12ActionListener listener = event -&gt; System.out.println(&quot;The time is &quot; + new Date()); 无需指定lambda表达式的返回类型. lambda表达式的返回类型总是会由上下文推导得出. 例如, 下面的表达式可以在需要int类型结果的上下文中使用. 1(String first, String second) -&gt; first.length() - second.length() 下面程序中的程序显示了如何在一个比较器和一个动作监听器中使用lambda表达式. 1234567891011121314151617181920212223242526import javax.swing.*;import java.util.*;import javax.swing.Timer;public class LambdaTest { public static void main(String[] args) { String[] planets = new String[] {&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;}; System.out.println(Arrays.toString(planets)); System.out.println(&quot;Sorted in dictionary order:&quot;); Arrays.sort(planets); System.out.println(Arrays.toString(planets)); System.out.println(&quot;Sorted by length:&quot;); Arrays.sort(planets, (first, second) -&gt; first.length() - second.length()); System.out.println(Arrays.toString(planets)); Timer t = new Timer(100, event -&gt; System.out.println(&quot;The time is &quot; + new Date())); t.start(); JOptionPane.showMessageDialog(null, &quot;Quit program&quot;); System.exit(0); }} 函数式接口lambda表达式与接口是兼容的. 对于哪些只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个lambda表达式. 这种接口称为函数式接口(function interface). 为了展示如何转换为函数式接口, 下面考虑Arrays.sort()方法. 它的第二个参数需要一个Comparator实例, Comparator就是只有一个方法的接口, 所以可以提供一个lambda表达式: 1Arrays.sort(words, (first, second) - &gt; first.length() - second.length()); 在底层, Arrays.sort()方法会接收实现了Comparator&lt;String&gt;的某个类的对象. 在这个对象上调用compare()方法会执行这个lambda表达式的体. 这些对象和类的管理完全取决于具体实现, 与使用传统的内联类相比, 这样可能会高效许多. 我们可以将lambda表达式看作是一个函数, 而不是一个对象; 另外要接收lambda表达式可以传递到函数式接口, 这让lambda表达式很有吸引力. 具体的实现语法很简单, 下面就是一个例子: 1234Timer t = new Timer(1000, event -&gt; { System.out.println(&quot;At the tone, the time is &quot; + new Date()); Toolkit.getDefaultToolkit().beep();}); 与使用实现了ActionListener接口的类相比, 这个代码的可读性要好得多. 实际上, 这就是Java中lambda表达式的上限了. 方法引用有时, 可能已经有现成的方法可以完成我们想要传递到其他代码的某个动作. 例如, 假设我们希望只要出现一个定时器事件就打印这个事件对象. 当然, 为此也可以调用: 1Timer t = new Timer(1000, event -&gt; System.out.println(event)); 但是, 如果直接把println()方法传递到Timer构造函数就好了. 实现方法如下: 1Timer t = new Timer(1000, System.out::println); 表达式System.out::println是一个方法引用(method reference), 它等价于lambda表达式x -&gt; System.out.println(x). 构造函数引用变量作用域处理lambda表达式再谈Comparator内部类内部类是定义在另一个类中的类. 为什么需要使用内部类呢? 其主要原因有以下三点: 内部类方法可以访问该定义所在的作用域中的数据, 包括私有的数据; 内部类可以对同一个包中的其他类隐藏起来; 当想要定义一个回调函数且不想编写大量代码时, 使用匿名(anonymous)内部类比较便捷. 使用内部类访问对象状态内部类的语法比较复杂, 故我们选择用一个简单但不太实用的例子说明内部类的使用方法. 下面将进一步分析TimerTest示例, 并抽象出一个TalkingClock类. 构造一个语音时钟时需要提供两个参数: 发布通告的间隔和开关铃声的标志. 123456789public class TalkingClock { private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) {...} public void start() {...} public class TimePrinter implements ActionListener {...}} 需要注意的是, 并不是每一个TalkingClock对象中都有一个TimePrinter实例域. 只有在TalkingClock类中的方法构造了后它才存在. 下面是TimePrinter类的详细内容. 需要注意一点: actionPerformer()方法在发出铃声之前检查了beep标志. 123456public class TimerPrinter implements ActionListener { public void ActionPerformed(ActionEvent event) { System.out.println(&quot;At the tone, the time is &quot; + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); }} 令人惊讶的事情发生了: 按理来说, TimePrinter类没有实例域或者名为beep的变量, 但TimePrinter中的方法还是调用了这个变量. 但真正令人惊讶的是, 正是beep引用创建了TalkingClock对象中TimePrinter的域. 内部类既可以访问自身的数据域, 也可以访问创建它的外围类对象的数据域. 为了能够实现这个功能, 内部类的对象中总有一个隐式引用, 它指向了创建它的外部类对象. 外围类的的引用在构造函数中设置. 编译器修改了所有的内部类的构造函数, 添加一个外围类引用的参数. 因为TimePrinter类没有定义构造器, 所以编译器为这个类生成了一个默认的构造器: 123public TimerPrinter(TalkingClock clock) { outer = clock; // 这里的outer是为了讲解方便而设置的引用. 实际编写的程序中没有这个东西} 下面讨论一下内部类的访问权限问题. 如果有一个常规的TimePrinter类, 它需要调用TalkingClock类的公用方法访问变量beep; 但要是使用了内部类, 我们就不需要提供能够被公开访问的方法了. 下面是一个测试内部类的完整程序. 1234567891011import javax.swing.*;public class innerClass { public static void main(String[] args) { TalkingClock clock = new TalkingClock(1000, true); clock.start(); JOptionPane.showMessageDialog(null, &quot;Quit Program?&quot;); System.exit(0); }} 1234567891011121314151617181920212223242526272829import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Date;public class TalkingClock { private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) { this.interval = interval; this.beep = beep; } public void start() { ActionListener listener = new TimePrinter(); Timer t = new Timer(1000, listener); t.start(); } public class TimePrinter implements ActionListener { @Override public void actionPerformed(ActionEvent e) { System.out.println(&quot;At the tone, the time is &quot; + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); } }} 内部类的特殊语法规则如果想要在内部类中调用外部类引用, 我们需要使用的语法还是有些复杂的. 表达式 1OuterClass.this 表示外围类引用. 例如, 可以像下面这样编写TimePrinter内部类的actionPerformed()方法: 123public void actionPerformed(ActionEvent event) { if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();} 反过来, 可以采用下列语法格式更加明确地编写内部对象的构造器: 1outerObject.new InnerClass(construcion parameters) 例如: 1ActionListener listener = this.new TimePrinter(); 在这里, 最新构造的TimePrinter对象的外围类引用被设置为创建内部类对象的方法中的this引用. 这是一种最常见的情况. 通常, this限定词是多余的. 不过, 可以通过显式地命名将外围类引用设置为其他的对象. 比如, 如果TimePrinter是一个公有内部类, 对于任意的TalkingClock都可以构造一个TimePrinter: 12TalkingClock jabberer = new TalkingClock(1000, true);TalkingClock.TimePrinter listener = jabberer.new TimerPrinter(); 需要注意, 在外围类的作用域之外, 可以这样引用内部类: 1OuterClass.InnerClass 内部类中声明的所有静态域都必须是final. 原因很简单: 我们希望一个静态域只有一个实例, 但对于每个外部对象, 大家会分别有一个单独的内部类实例. 如果这个域不是final的的话, 他可能就不是唯一的.内部类中不能有static方法. 我们也不知道Java语言的设计者为何做出这种限制, 但是遵循就好了. 内部类是否有用、必要和安全局部内部类由外部方法访问变量匿名内部类静态内部类代理本章的最后讨论一下代理(proxy). 利用代理可以在运行时创建一个实现了一组给定接口的新类. 这种功能只有在无法确定需要实现哪个接口时才有必要使用. 异常、断言和日志人总会遇到错误的. 如果一个用户在运行程序期间遭遇了因程序错误或种种外部因素而导致的数据丢失, 他就有可能不会再使用这个程序了. 为了避免这类事情的发生, 至少应该做到以下几点: 向用户通告错误; 保存所有的工作结果; 允许用户以妥善的形式退出程序. 我们接下来就来学习如何做到这几点. 处理错误大家都希望程序在出现错误时, 它能够采取一些理智的行为. 如果由于出现错误而使得欧协操作没有完成, 程序应该: 返回到一种安全状态, 并能够让用户执行一些其他的命令; 允许用户保存所有操作的结果, 并以妥善的方式终止程序. 讲真, 这并不容易. 毕竟检测(或引发)错误条件的代码通常举例那些能够让数据恢复到安全状态、或者能够保存用户的操作结果, 并正常推出程序的代码很远. 异常处理的任务就是将控制权从错误产生的位置转移到能够处理这种情况的错误处理器. 为了能够在程序中处理异常情况, 我们需要研究一下程序中可能出现的错误和问题, 以及哪类问题需要关注. 用户输入错误: 除了那些不可避免的键盘输入错误外, 有些用户喜欢各行其是, 不遵循程序的要求. 例如, 假设有一个用户请求连接一个URL, 而语法却不正确. 在程序代码中应该对此进行检查, 如果没有检查, 网络层就会给出警告. 设备错误: 硬件并不总是那么충!성!, 也会时不时出问题; 物理限制: 磁盘满了, 可用存储空间已被用完; 代码错误: 程序方法有可能无法正确执行. 对于方法中的一个错误, 传统的做法是返回一个特殊的错误码, 由调用方法分析; 但并不是在任何情况下都能够返回一个错误码的, 有可能无法明确地将有效数据与无效数据加以区分. 一个返回整型的方法就不能简单地通过返回-1表示错误, 因为-1很可能是一个完全合法的结果. 在Java中, 如果某个方法不能够采用正常的途径完成它的任务, 就可以通过另外一个路径退出方法. 在这种情况下, 方法并不返回任何值, 而是抛出(throw)一个封装了错误信息的对象, 方法本身也会立刻退出, 而调用这个方法的代码也无法继续执行. 取而代之的是异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler). 异常分类在Java中, 异常对象都是Throwable类的子类. 甚至, 如果Java的内置类不够用, 用户还可以创建自己的异常类. 但需要注意的是, 虽然所有的异常都是从Throwable继承而来, 但是它们在下一层就立即分解为两个分支: Error和Exception. Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误. 应用程序不应该抛出这种类型的对象. 如果出现了这样的内部错误, 除了通告给用户并安全中止程序, 程序自己也做不了其他的事情了. 这种情况很少见. 在设计Java程序时, 需要关注Exception层次结构. 这个层次结构又再次分解为两个分支: 一个分支派生于RuntimeException, 另一个分支包含其他异常. 划分两个分支的规划是: 又程序错误导致的异常属于RuntimeException, 而程序本身没有问题, 但由于像I/O错误这类问题导致的异常属于其他异常. 派生于RuntimeException的异常包含下面几种情况: 错误的类型转换 数组访问越界 访问null指针 非RuntimeException的异常包括: 试图在文件尾部后面读取数据 试图打开一个不存在的文件 试图根据给定的字符串查找Class对象, 但这个字符串表示的类根本不存在. Java将派生于Error类或RuntimeException类的所有异常称为非受查(unchecked)异常, 并将其他所有的异常称为受查(checked)异常. 这是两个很有用的术语, 我们在后面还会频繁地用到它们. 声明受查异常方法应该在其首部声明所有可能抛出的异常. 这样可以从首部反映出这个方法可能抛出哪类受查异常. 以FileInputStream类的一个构造函数的声明为例: 1public FileInputStream(String name) throws FileNotFoundException 这个声明表示这个构造函数将根据给定的String参数产生一个FileInputStream对象, 但也可能抛出一个FileNotFouundException异常. 如果该构造函数真的抛出了该类异常, 系统就会开始搜索异常处理器, 以便知道如何处理FileNotFouundException对象. 并不需要将所有有可能抛出的异常都进行声明. 至于何时应该使用throws声明异常, 何种异常值得被throws, 有如下四个标准可供参考: 调用一个抛出受查异常的方法; 程序运行中发现错误, 并且利用throws语句抛出一个受查异常; 程序出现错误; JVM和运行时的库出现的内部错误. 如果出现前两种情况之一, 则必须告知调用该方法的程序员有可能抛出异常, 因为任何一个抛出异常的方法都有可能是一个死亡陷阱. 如果没有处理器捕获这个异常, 当前执行的现成就会结束. 对于那些可能被他人使用的Java方法, 应该根据异常规范(exception specification), 在方法的首部声明这个方法可能抛出的异常. 123456class MyAnimation { ... public Image loadImage(String s) throws IOException { ... }} 如果一个方法有可能抛出多个受查异常类型, 那么就必须在方法的首部列出所有的异常类, 每个异常类之间用逗号隔开, 如下所示: 123456class MyAnimation { ... public Image loadImage(String s) throws FileNotFoundExceptoin, EOFException { ... }} 但是, 不需要声明Java的内部错误, 即从Error继承的错误. 任何程序代码都有抛出那些异常的潜能, 我们也无法控制它们. 同样地, 也不应该声明从RuntimeException继承的那些非受查异常. 123456class MyAnimation { ... void drawImage(int i) throws ArrayIndexOutOfBoundsException { // bad style ... } } 这些运行时错误完全在我们的控制之下. 如果特别关注数组下标引发的错误, 就应该将更多的时间花费在编写正确的程序上, 而不是等着程序运行出错. 总而言之, 一个方法必须声明所有可能抛出的受查异常, 而非受查异常要么不受控制(Error), 要么应当在编写过程中避免(RuntimeException). 如果方法没有声明所有可能发生的受查异常, 编译器就会报错. 当然, 从前面的示例中也可以知道: 除了声明异常, 我们还可以捕获异常. 这样会使异常不被抛到方法之外, 也不需要throws规范. 稍后我们就会了解到如何决定一个异常是被捕获, 还是被抛出让其他的处理器进行处理. 注意: 如果在子类中覆盖了父类的一个方法, 子类方法中声明的受查异常不能比父类方法声明的异常更加通用(也就是说, 子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常). 这也意味着, 如果父类方法没有抛出任何受查异常, 子类方法也不能抛出任何受查异常. 如果类中的一个方法声明将会抛出一个异常, 而这个异常是某个特定类的实例时, 则这个方法就有可能抛出一个这个类的异常, 或者这个类的任意一个子类的异常. 如何抛出异常假设在程序代码中发生了一些很糟糕的事情: 一个名为readData()的方法正在读取一个首部具有下列信息的文件: 1Content-length: 1024 然而, 在读到733个字符之后文件就结束了. 我们认为这是一种不正常的情况, 希望抛出一个异常. 我们接下来就来研究一下如何抛出这个异常. 首先, 我们需要决定应该抛出什么类型的异常. 在阅读Java API文档之后我们会发现, 将上述异常归结为IOException下的EOFException是一种很好的选择. 文档将该类异常介绍为: “在输入过程中, 遇到了一个未预期的EOF(注: EOF, 即’End of File’, 指文件结尾)后的信号”. 下面是抛出异常的语句: 1throw new EOFException(); 或者: 12EOFException e = new EOFException();throw e; 下面将这些代码放在一起: 1234567891011String readDate(Scanner in) throws EOFException { ... while (true) { if (!in.hasNext()) { // EOF enountered if (n &lt; len) throw new EOFException(); } } return s;} 在EOFException类中还有含有一个字符串参数的构造器. 这个构造器可以更加细致的描述异常出现的情况: 12String gripe = &quot;Content-length: &quot; + len + &quot;, Received: &quot; + n;throw new EOFException(gripe); 综上, 我们可以看出, 对于一个已经存在的异常类, 将其抛出非常容易, 只需: 找到一个合适的异常类; 创建这个类的一个对象; 将对象抛出 即可. 一旦方法抛出了异常, 这个方法就不可能返回到调用者, 我们也就不必为返回的默认值或错误代码担忧. 创建异常类如果标准异常类库中没有能够充分描述我们问题的异常, 我们就只能自己创建处于我们自己的异常. 我们需要做的是定义一个继承了Exception的类, 或者继承自Exception子类的类. 习惯上, 定义的类应该包含两个构造函数: 一个是默认的构造器, 另一个则是带有详细描述信息的构造类(如父类Throwable的toString()方法, 其能偶打印出输入的详细信息, 对我们进行调试工作十分有用). 12345678import java.io.IOException;public class FileFormatException extends IOException { public FileFormatException() {} public FileFormatException(String gripe) { super(gripe); }} 现在我们就可以抛出自己定义的异常类型了. 123456789101112131415import java.io.BufferedReader;public class ThrowTest { String readDate(BufferedReader in) throws FileFormatException { while (true) { if (ch == -1) { if (n &lt; len) throw new FileFormatException(); } } return s; }} 捕获异常有些代码必须捕获异常, 而这需要进行周密的计划. 接下来我们就来介绍如何捕获异常. 小·捕获异常如果某个异常在发生时没有在任何地方进行捕获, 那程序就会中止执行, 并在控制台上打印出异常信息; 对于图形界面程序也有类似的过程. 想要捕获一个异常, 必须设置try/catch语句块. 最简单的try语句块如下所示: 1234567try { codes; more codes; more more codes;} catch (ExceptionType e) { handler for this type;} 如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类, 那么 程序将跳过try语句块的其余代码; 程序将执行catch子句中的处理器代码. 如果在try语句块中的代码没有抛出任何异常, 程序将跳过catch子句. 如果方法中的任何代码抛出了一个在catch子句中没有声明的异常类型, 那么方法也会立刻退出. 下面是一个演示捕获异常的处理过程, 下面给出一个读取数据的典型代码: 1234567891011public void read(String filename) { try { InputStream in = new FileInputStream(filename); int b; while ((b = in.read()) != -1) { // balabala } } catch (IOException e) { e.printStackTrace(); }} 当然, 我们也可以不catch这个异常, 将异常扔给方法的使用者处理: 1234567public void read1(String filename) throws IOException { InputStream in = new FileInputStream(filename); int b; while ((b = in.read()) != -1) { // balabalabala }} 通常来说, 我们应该捕获那些知道如何处理的异常, 而将那些不知道如何处理的异常继续进行传递. 但是, 如果编写一个覆盖父类的方法, 而这个方法有没有抛出异常, 则这个方法就只能捕获自己内部的异常. 捕获多个异常可在try语句块中捕获多个异常类型, 并针对不同类型的异常做出不同的处理. 再次抛出异常与异常链在catch子句中可以再抛出一个异常, 这样做的目的是改变异常的类型. 如果开发了一个供其他程序员使用的子系统, 那么, 用于表示子系统故障的异常类型可能会产生多种解释. ServletException就是这样一个异常类型的例子. 执行servlet的代码可能不想知道发生错误的细节原因, 但希望明确地知道servlet是否有问题. 下面给出了捕获异常并将它再次抛出的基本方法: 12345try { // access the database} catch (SQLException e) { throw new ServletException(&quot;database error: &quot; + e.getMessage());} 这里, ServletException用带有异常信息文本的构造函数来构造. 不过, 还有一种更好的处理方式, 并将原始异常设置为新异常的”原因”: 1234567try { // access the database} catch (SQLException e) { Throwable se = new ServletException(&quot;database error&quot;); se.initCause(e); throw se;} 如此, 在捕获到异常时, 就可以使用下面这条语句重新得到原始异常. 1Throwable e = se.getCause(); 强烈建议使用这种包装技术. 这样就能够让用户抛出子系统中的高级异常, 而不会丢失原始异常的细节. finally子句finally子句中的代码总是会被执行, 不论是否有异常被捕获. 这是一项很有用的语法, 尤其是在编写数据库程序的时候, 其能够确保与数据库的连接能够被恰当的关闭. 在下列代码中, 不论如何程序都会在最后关闭文件: 12345678InputStream in = new FileInputStream(...);try { // balabala} catch (IOException e) { // balabala} finally { // balabala} try语句可以只有finally子句, 而没有catch子句. 1234567InputStream in = ...;try { // balabala} finally { in.close();} 无论如何, finally子句中的代码都会被执行. 但是, 如果try子句中的代码抛出了一个异常, 必须有另外的catch将他捕获. 事实上, 我们认为在需要关闭资源时, 用这种方式使用finally子句是一种不错的选择. 强烈建议解耦合try/catch和try/finally语句块. 这样可以提高代码的清晰度. 例如: 123456789try { try { // } finally { in.close(); }} catch (IOException e) { //} 内部的try语句块只有一个职责, 就是确保关闭输入流; 外部的try语句块也只有一个职责, 就是确保报告出现的错误. 这种方法除表达清晰外还有一个优点, 就是可以报告finally子句中出现的错误. 还需注意的是, 如果try和finally子句中均有return语句, 则finally子句中的return将覆盖掉try中的返回值. 带资源的try语句对于担心因关闭资源报错而丢失更有价值的异常信息的朋友们来说, Java提供了一个很有用的快捷方式. AutoCloseable接口中有一个方法: 1void close() throws Exception 带资源的try语句(try-with-resources)的最简形式为: 123try (Resource res = ...) { //} 在try块退出时, 程序会自动调用res.close(). 下面是一个典型的例子, 我们读取了一个文件中的所有单词: 12345try (Scanner in = new Scanner(new FileInputStream(&quot;/usr/share/dict/words&quot;), &quot;UTF-8&quot;)) { while (in.hasNext()) { System.out.println(in.next()); }} 不管这个块是正常退出了, 又或是发现了一个异常, 程序都会调用in.close()方法, 就好像使用了finally块一样. 还可以指定多个资源. 例如: 123456try (Scanner in = new Scanner(new FileInputStream(&quot;/usr/share/dict/words&quot;), &quot;UTF-8&quot;); PrintWriter out = new PrintWriter(&quot;out.txt&quot;)) { while (in.hasNext()) { out.println(in.next().toUpperCase()); }} 只要是需要关闭资源, 我们就应该尽可能地使用带资源的try语句. 分析堆栈轨迹元素堆栈轨迹(stack trace)是一个方法调用过程的列表, 它包含了程序执行过程中方法调用的特定位置. 我们在前面就已经见到它, 其在Java程序正常终止时就会显示出来. 可以调用Throwable类的printStackTrace()方法访问堆栈轨迹的文本描述信息. 1234Throwable t = new Throwable();StringWriter out = new StringWriter();t.printStackTrace(new PrintWriter(out));String description = out.toString(); 还有一种更加灵活的getStackTrace()方法, 它会得到StackTraaceElement对象的一个数组, 并可以在我们的程序中分析这个对象数组. 例如: 12345Throwable t = new Throwable();StackTraceElement[] frames = t.getStackTrace();for (StackTraceElement frame : frames) { //} StackTraceElement类中含有能够获得文件名和当前执行的代码行号的方法. 同时, 其还含有能够获得类名和方法名的方法. toString()方法将产生一个格式化的字符串, 其中包含所获得的信息. 静态的Thread.getAllStackTrace()方法能够产生所有线程的堆栈轨迹. 下面给出使用这个方法的具体方式: 12345Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTrace();for (Thread t : map.keySet()) { StackTraceElement[] frames = map.get(t); // balabala} 下面是一个打印堆栈轨迹的例子: 如果计算factorial(3), 将会打印下列内容: 123456789101112131415161718factorial(3)stackTrace.factorial(stackTrace.java:15)stackTrace.main(stackTrace.java:9)factorial(2)stackTrace.factorial(stackTrace.java:15)stackTrace.factorial(stackTrace.java:23)stackTrace.main(stackTrace.java:9)factorial(1)stackTrace.factorial(stackTrace.java:15)stackTrace.factorial(stackTrace.java:23)stackTrace.factorial(stackTrace.java:23)stackTrace.main(stackTrace.java:9)return 1return 2return 6Process finished with exit code 0 程序代码如下: 12345678910111213141516171819202122232425262728import java.util.Scanner;public class stackTrace { public static void main(String[] args) { Scanner in = new Scanner(System.in); System.out.print(&quot;Enter n: &quot;); int n = in.nextInt(); factorial(n); } public static int factorial(int n) { System.out.println(&quot;factorial(&quot; + n + &quot;)&quot;); Throwable t = new Throwable(); StackTraceElement[] frames = t.getStackTrace(); for (StackTraceElement f : frames) { System.out.println(f); } int r; if (n &lt;= 1) r = 1; else r = n * factorial(n - 1); System.out.println(&quot;return &quot; + r); return r; }} 使用异常机制的技巧下面是几个使用异常机制的几个技巧. 异常处理不能代替简单的测试以退栈操作为例: 使用isEmpty()方法检测一个栈是否为空所需的时间远小于”尝试进行退栈操作却发现栈为空后抛出异常再捕获”的时间. 只在异常情况下使用异常机制. 不要过分地细化异常利用异常层次结构不要只抛出RuntimeException异常. 应该寻找更加适当的子类或创建自己的异常类. 不要只捕获Thowable异常, 否则, 会使程序代码更难读、更难维护. 考虑受查异常与非受查异常的区别. 已检查异常本来就很庞大, 不要为逻辑错误抛出这些异常. 将一种异常转换成另一种更加适合的异常时不要犹豫. 例如, 在解析某个文件中的一个整数时, 捕获’NumberFormatException’异常, 然后将它转换成IOException或MySubsystemException的子类. 不要压制异常在Java中, 往往强烈地倾向于关闭异常. 如果编写了一个调用另一个方法的方法, 那么另一个方法就会时刻提醒编译器其有可能抛出异常, 不论这个可能性是大是小. 如果这个要抛出的异常根本无关紧要, 我们就可以关闭这个异常: 1234567public Image loadImage(String s) { try { // codes threatening to throw checked exceptions } catch (Exception e) { // shut down }} 如此就可以顺利编译我们的代码了. 如果运行顺利, 那就运行顺利😅; 如果抛出异常, 它也会被自动忽略. 如果认为异常十分重要, 就应该在catch子块中为其进行处理. 尽早抛出出现的异常在用无效的参数调用一个方法时, 返回一个虚拟的数值, 还是抛出一个异常, 哪种处理方式更好? 例如, 在栈空时, Stack.pop()方法是返回一个null, 还是抛出一个异常? 我们认为: 在出错的地方抛出一个EmptyStackException异常要比在后面抛出一个NullPointerException异常更好. 不要羞于传递异常有些异常应当被传递给更高层次的使用者 ,不要羞于传递它们. 断言的使用记录日志记录日志API能够很好地帮助我们观察程序的运行过程. 记录日志API有着如下优点: 可以很容易地取消全部日志记录, 或者仅仅取消某个级别的日志, 而且打开和关闭这个操作也很容易; 可以很简单地禁止日志记录的输出, 因此将这些日志代码留在程序中的开销很小; 日志记录可以被定向到不同的处理器, 用于在控制台中显示, 用于存储在文件中等; 日志记录器和处理器都可以对记录进行过滤. 过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项; 日志记录可以采用不同的方式格式化, 例如纯文本或XML; 应用程序可以使用多个日志记录器, 它们使用类似包名的这种具有层次结构的名字, 例如com.mycompany.myapp; 在默认情况下, 日志系统的配置由配置文件控制. 如果需要的话, 应用程序可以替换这个配置. 基本日志要生成简单的日志记录, 我们可以使用全局日志记录器(global logger)并调用其info()方法 : 1Logger.getGlobal().info(&quot;File-&gt;Open menu item selected&quot;); 如果在main()方法开始的地方(或者其他适当的地方)调用 1Logger.getGlobal().serLevel(Level.OFF); 则所有的日志均会被取消. 高级日志修改日志管理器配置本地化处理器过滤器格式化器日志记录说明调试技巧泛型程序设计为什么要使用泛型程序设计泛型程序设计(generic programming)意味着编写的代码可以被很多不同类型的对象使用. 实际上, 在Java添加泛型类之前, 其中已经有了一个ArrayList类. 下面我们来看一下泛型程序设计的机制是如何演变的, 并进一步体会泛型对于用户和实现者来说的意义. 类型参数的好处在Java中增加泛型类之前, 泛型程序设计是利用继承实现的. ArrayList类只维护一个Object引用的数组: 123456public class ArrayList { private Object[] elementData; ... public Object get(int i) {...} public void add(Object o) {...}} 这个方法有两个问题. 在获取一个值时必须进行强制类型转换是其一; 无法对保存进ArrayList的对象进行错误检查是其二. 但是泛型能够解决这两个问题, 因为其提供了一个更好的解决方案: 类型参数(type parameters). ArrayList类有一个类型参数用来指示元素的类型: 1ArrayList&lt;String&gt; files new ArrayList&lt;String&gt;(); 这让我们一看就知道这个ArrayList中装的是String对象. 在Java SE 7及以后的版本中, 构造函数可以省略泛型类型: 1ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;(); 编译器也可以知道, 从此类ArrayList中提取出来的元素均应为String对象. 此外, 编译器还知道ArrayList&lt;String&gt;中的add()方法中有一个类型为String的参数. 这比使用Object类型的参数安全一些. 这就是类型参数的魅力: 让程序具有更好的可读性和安全性. 谁想成为泛型程序员实际上, 泛型的编写工作非常困难. 绝大多数程序员只是应用泛型这一工具, 而对泛型是如何实现的知之甚少. 后面将通过定义一个简单的泛型类向大家简单介绍泛型的编写方式和运作机制. 如果想要深入理解泛型, 还需要进一步阅读其他书籍. 定义简单泛型类一个泛型类(generic class)就是具有一个或多个类型变量的类. 本节使用一个简单的Pair类作为例子. 对于这个类来说, 我们只关注泛型, 对数据储存问题持无关心态度. 下面是Pair类的代码: 12345678910111213141516171819202122232425262728public class Pair&lt;T&gt; { private T first; private T second; public Pair() { first = null; second = null; } public Pair(T first, T second) { this.first = first; this.second = second; } public T getFirst() { return first; } public T getSecond() { return second; } public void setFirst(T first) { this.first = first; } public void setSecond(T second) { this.second = second; }} Pair类引入了一个类型变量T, 用尖括号(&lt;&gt;)括起来, 并放在类名的后面. 泛型类可以有多个类型变量. 例如, 可以定义Pair类, 其中第一个域和第二个域使用不同的类型: 1public lcass Pair&lt;T, U&gt; {...} 类定义中的类型变量指定方法的返回类型以及域和局部变量的类型. 例如: 1private T first; 类型变量使用大写形式, 且比较短. 这是很常见的. 在Java库中, 通常使用变量E表示集合的元素类型, K和V分别表示表的关键字与值的类型. T(需要时还可用临近的字母U和S)表示”任意类型”. 使用具体的类型替换类型变量就可以实例化泛型类型. 例如: 1Pair&lt;String&gt; 可以将结果想象成带有构造器的普通类: 12Pair&lt;String&gt;()Pair&lt;String&gt;(String, String) 和方法: 1234String getFirst() {}String getSecond() {}void serFirst(String) {}void setSecond(String) {} 换句话说, 泛型类可看作普通类的工厂. 泛型方法前面已经介绍了如何定义一个泛型类. 实际上, 还可以定义一个带有类型参数的简单方法: 12345class ArralAlg { public static &lt;T&gt; T getMiddle(T... a) { return a[a.length / 2]; }} 这个方法是在普通类中定义的, 而不是在泛型类中定义的. 然而, 这是一个泛型方法, 可以从尖括号和类型变量中看出这一点. 注意, 类型变量放在修饰符(这里是public static)的后面, 返回类型的前面. 泛型方法可以定义在普通类中, 也可以定义在泛型类中. 当调用一个泛型方法时, 在方法名前的尖括号中放入具体的类型: 1String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;); 在这种情况下(实际上也是大多数情况下), 方法调用中可以省略&lt;String&gt;. 1String middle = ArrayAlg.getMiddle(&quot;John&quot;, &quot;Q.&quot;, &quot;Public&quot;); 不过偶尔也会出现一些问题, 比如下面这个例子: 1double middle = ArrayAlg.getMiddle(3.14, 1729, 0); 编译器会委婉地指出, 解释这段代码有两种合法方法. 编译器通过将参数打包为一个Double和两个Integer对象, 然后共同寻找这些类的共同父类, 结果找到了两个符合条件的类: Number和Comparable接口, 其本身也是一个泛型类型. 解决方法就是将所有的参数写为double值. 类型变量的限定有时, 类或方法需要对类型变量加以约束. 下面是一个典型的例子. 我们需要计算数组中的最小元素: 12345678class ArrayAlg { public static &lt;T&gt; T min(T[] a) { if (a == null || a.length == 0) return null; T smallest = a[0]; for (int i = 1; i &lt; a.length; i++) if (smallest.compareTo(a[i]) &gt; 0) smallest = a[i]; }} 但是如果我们真的这么写代码的话, 编译器会报错. 原因在于我们不能保证泛型&lt;T&gt;都实现了Comparable接口. 我们可以通过对类型变量T设置限定(bound)实现这一点: 1public static &lt;T extends Comparable&gt; T min(T[] a) {} 事实上, Comparable接口本身就是一个泛型类型. 后面会具体讨论如何在Comparable接口中适当的使用类型参数. 现在, 泛型的min方法就只能被实现了Comparable接口的类的数组调用. 或许各位或有些奇怪——在此为什么使用关键字extends而不是implements? 毕竟, Comparable是一个接口. 实际上, &lt;T extends BoundingType&gt;表示T应该是绑定类型的子类型(subtype). T和绑定类型既可以是类, 也可以是接口. 选择关键字extends的原因是更接近子类的概念, 并且Java的设计者也不打算在语言中再添加新的关键字. 一个类型变量或通配符可以有多个限定, 例如: 1T extends Comparable &amp; Serializable 限定类型用&amp;分隔, 而逗号用来分割类型变量. 在Java的继承中, 可以根据需要拥有多个接口超类型, 但限定中至多有一个类. 如果用一个类作为限定, 它必须是限定列表中的第一个. 下面重新编写了一个泛型方法minmax, 用于计算泛型数组的最大值和最小值, 并返回Pair&lt;T&gt;. 123456789101112131415161718192021222324252627282930import java.time.LocalDate;import java.util.Locale;public class PairTest2 { public static void main(String[] args) { LocalDate[] birthdays = { LocalDate.of(1906, 12, 9), LocalDate.of(1815, 12, 10), LocalDate.of(1903, 12, 3), LocalDate.of(1900, 6, 22) }; Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays); System.out.println(&quot;min = &quot; + mm.getFirst()); System.out.println(&quot;max = &quot; + mm.getSecond()); }}class ArrayAlg { public static &lt;T extends Comparable&gt; Pair&lt;T&gt; minmax(T[] a) { if (a == null || a.length == 0) return null; T min = a[0]; T max = a[0]; for (int i = 1; i &lt; a.length; i++) { if (min.compareTo(a[i]) &gt; 0) min = a[i]; if (max.compareTo(a[i]) &lt; 0) max = a[i]; } return new Pair&lt;&gt;(min, max); }} 泛型代码和虚拟机约束与局限性 不能用基本类型实例化类型参数 运行时类型查询只适用于原始类型 不能创建参数化类型的数组 Varargs警告 不能实例化类型变量 不能构造泛型数组 泛型类的静态上下文中类型变量无效 不能抛出或捕获泛型类的实例 可以消除对受查异常的检查 注意擦除后的冲突 泛型类型的继承规则考虑一个类和子类, 如Employee和Manager, 那么Pair&lt;Manager&gt;和Pair&lt;Employee&gt;的一个子类吗? 不是的. 无论S与T之间有什么关系, 通常Pair&lt;S&gt;和Pair&lt;T&gt;之间都不会有什么联系. 通配符类型固定的泛型类型系统使用起来并没有那么令人愉快, 这一点类型系统的研究人员已经知道一段时间了. Java的设计者设计了一种巧妙且安全的”解决方案”: 通配符类型. 我们接下来就来认识一下它. 通配符的概念通配符类型中, 允许类型参数变化. 例如, 通配符类型 1Pair&lt;? extends Employee&gt; 表示任何泛型Pair类型, 其类型参数应为Employee的子类, 如Pair&lt;Manager&gt;, 但不是Pair&lt;String&gt;. 假设要编写一个打印雇员对的方法, 像这样: 12345public static void printBuddies(Pair&lt;Employee&gt; p) { Employee first = p.getFirst(); Employee second = p.getSecond(); System.out.println(first.getName() + &quot; and &quot; + second.getName() + &quot; are buddies.&quot;);} 如前所述, 不能将pair&lt;Manager&gt;传递给这个方法. 解决方法便是使用通配符类型: 1public static void printBuddies(Pair&lt;? extends Employee&gt; p) 类型Pair&lt;Manager&gt;是Pair&lt;? extends Employee&gt;的子类型. 通配符的父类型限定通配符限定于类型变量限定十分类似, 但是, 还有以恶个附加的能力, 即可以指定一个父类型限定(supertype bound), 如下所示: 1? super Manager 这个通配符限制为Manager的所有父类型(已有的super关键字十分准确地描述了这种联系). 为什么要这样做呢? 带有超类型限定的通配符只能为方法提供参数, 而不能使用返回值. 下面是一个典型的示例: 有一个经理的数组, 并且想把奖金最高和最低的经理放在一个Pair对象中. Pair的类型是什么? 在这里, Pair&lt;Employee&gt;是合理的, Pair&lt;Object&gt;也是合理的. 下面的方法将可以接收任何适当的Pair: 1234567891011public static void minmaxBonus(Manager[] a, Pair&lt;? super Manager&gt; result) { if (a.length == 0) return; Manager min = a[0]; Manager max = a[0]; for (int i = 1; i &lt; a.length; i++) { if (min.getBonus() &gt; a[i].getBonus()) min = a[i]; if (max.getBonus() &gt; a[i].getBonus()) max = a[i]; } result.setFirst(min); result.setSecond(max);} 直观地讲, 带有超类型的通配符可以像泛型对象写入, 带有子类型限定的通配符可以从泛型对象读取. 下面 是超类型限定的另一种应用. Comparable接口本身就是一个泛型类型. 声明如下: 123public interface Comparable&lt;T&gt; { public int compareTo(T other);} 在此, 类型变量指示了other参数的类型. 例如, String类实现Comparable&lt;String&gt;, 它的compareTo()方法就被声明为 1public int compareTo(String other) 通过在接口中使用泛型, 我们就避免了在使用Object类时出现的强制类型转换问题. 由于Comparable是一个泛型类型, 或许可以将ArrayAlg类的min方法做得更好一些? 可以这样声明: 1public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T[] a) 看起来, 这样写比只使用T extends Comparable更彻底, 并且对许多类来讲, 工作得更好. 无限定通配符还可以使用无限定的通配符, 例如Pair&lt;?&gt;. 乍看起来, 这好像与原始的Pair类型一样. 实际上, 有很大的不同. 类型Pair&lt;?&gt;有以下方法: 12? getFirst()void setFirst(?) getFirst()的返回值只能赋给一个Object. setFirst()方法不能被调用, 甚至不能用Object调用. Pair&lt;?&gt;和Pair的不同在于: 可以用任意Object对象调用原始Pair类的setObject()方法. 通配符捕获反射和泛型反射允许我们在运行时分析任意的对象. 如果对象是泛型类的实例, 关于泛型类型参数则得不到太多信息, 因为它们会被擦除. 在下面的小节中, 可以了解利用反射可以获得泛型类的什么信息. 集合Java集合框架将集合的接口与实现分离与现代的数据结构类库的常见情况一样, Java集合类库也将接口与实现分离. 首先, 我们看一下队列(queue)这一数据结构是如何分离的. 队列接口指出可以在队列的尾部添加元素, 在队列的头部删除元素, 并且可以查找队列中元素的个数. 当需要收集对象, 并按照”先进先出”的规则检索对象时就应该使用队列. 队列接口的最简形式可能会类似于: 12345public interface Quece&lt;E&gt; { void add(E element); E remove(); int size();} 这个接口并没有说明队列是如何实现的. 队列通常有两种实现方法: 一种是使用循环数组; 另一种是使用链表. 每一个实现都可以通过一个实现了Queue接口的类表示. 1234567891011121314151617181920public class CircularArrayQueue&lt;E&gt; implements Queue&lt;E&gt; { // not an actual library class private int head; private int tail; CircularArrayQueue(int capacity) {} public void add(E element) {} public E remove() {} public int size() {} private E[] elements;}public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; { // not an actual library class private link head; private link tail; LinkListQueue() {} public void add(E element) {} public E remove() {} public int size() {}} 当在程序中使用队列时, 一旦构建了集合就不需要知道究竟使用了哪种实现. 因此, 只有在构建集合对象时, 使用具体的类才有意义. 可以使用接口类型存放集合的引用. 12Queue&lt;Customer&gt; expressLane = new CircularArrayQueue&lt;&gt;(100);expressLane.add(new Customer(&quot;Harry&quot;)); 利用这种方法, 一旦改变了想法, 就可以轻松地使用另外一种不同的实现. 只需要对程序的一个地方做出修改, 即调用构造器的地方. 如果觉得LinkedListQueue是个更好的选择, 就可以将代码修改为: 12Queue&lt;Customer&gt; expressLane = new LinkedListQueue&lt;&gt;();expressLane.add(new Customer(&quot;Harry&quot;)); 为什么选择这种实现, 而不选择另一种实现呢? 接口本身并不能说明哪种实现的效率究竟如何. 循环数组比链表要高效, 因此多数人优先选择循环数组. 然而, 通常这样做也需要付出一定的代价. 循环数组是一个有限集合, 容量有限; 如果程序中要收集的对象数量没有上限, 则最好使用链表来实现. Collection接口在Java类库中, 集合类的基本接口是Collection接口. 这个接口有两个基本方法: 1234public interface Collection&lt;E&gt; { boolean add(E element); Iterator&lt;E&gt; iterator();} 除了这两个方法外, 还有几个方法, 稍后会继续介绍. add()方法用于向集合中添加元素. 如果添加元素确实改变了结合, 就返回true; 反之, 则返回false. 例如, 如果试图向集合中添加一个对象, 而这个对象在集合中已经存在, 这个添加请求就没有实效, 因为集合中不允许有重复的对象. iterator()方法用于返回一个实现了Iterator接口的对象. 可以使用这个迭代器对象依次访问集合中的元素. 迭代器Iterator接口包含四个方法: 123456public interface Iterator&lt;E&gt; { E next(); boolean hasNext(); void remove(); default void forEachRemaining(Consermer&lt;? super E&gt; action);} 通过反复调用next()方法, 可以逐个访问集合中的每个元素. 不过在调用之前, 还是需要使用hasNext()方法来检验是否可以继续执行next()方法. 如果想要查看集合中的所有元素, 就请求一个迭代器, 并在hasNext()返回true时反复地调用next()方法. 例如: 123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; iter = c.iterator();while (iter.hasNext()) { String element = iter.next(); ...} 使用for each循环可以更加简练地表示同样的循环操作: 123for (String element : c) { ...} 编译器将for each循环简单地翻译为带有迭代器的循环. for each循环可以与任何实现了Iterable接口的对象一起工作, 这个接口只有一个抽象方法: 1234public interface Iterable&lt;E&gt; { Iterator&lt;E&gt; iterator(); ...} Collection接口扩展了Iterable接口. 因此, 对于标准类库中的任何集合都可以使用for each循环. 具体的集合链表数组的储存方式为在连续的存储位置上存放对象引用, 而链表则将对象存放在独立的结点中. 每个节点还存放着序列中下一个节点的引用. 在Java程序设计语言中, 所有链表实际上都是双向链接的, 即每个节点还存放着向前驱节点的引用. 由此, 从链表中间删除一个元素是一件很轻松的事情, 仅需要更新被删除元素附近的链接即可. 在下面的代码示例中, 先添加三个元素, 然后再将第二个元素删除: 12345678List&lt;String&gt; staff = new LinkedList();staff.add(&quot;Amy&quot;);staff.add(&quot;Bob&quot;);staff.add(&quot;Carl&quot;);Iterator iter = staff.iterator();String first = iter.next();String second = iter.next();iter.remove(); 但是, 链表与泛型集合之间的最大区别, 就是链表是一个有序集合. 这意味着每个队形的位置十分重要. 并发","link":"/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/"},{"title":"Java学习笔记","text":"基本概念Java的工作方式Java的目标是写出一个能在任何设备上运行的应用程序. 源代码编写源代码文件. 编译器用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出. 输出编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关. Java虚拟机(JVM)通过Java虚拟机可以读取和执行字节码. 要做的事编写源代码文件, 用javac编译程序, 并在某个Java虚拟机上执行编译过的字节码. Java的程序结构类存放在源文件中; 方法存放在类中; 语句存放在方法中. 什么是源文件源文件(扩展名为.java)带有类的定义. 类用来表示程序的一个组件. 先程序或许只会有一个类. 类的内容必须包在花括号里面. 12345678910111213import java.awt.*;import java.awt.event.*;public class Party { public void buildInvite(){ Frame f = new Frame(); Label l = new Label(&quot;Party at Tim's!&quot;); Button b = new Button(&quot;You bet&quot;); Button c = new Button(&quot;Shoot me&quot;); Panel p = new Panel(); p.add(l); }} 什么是类类中带有一个或多个方法. 方法必须在类的内部声明. 什么是方法在方法的花括号中编写方法应该执行的指令. 方法代码是由一组语句所组成的, 可以把方法想象成是一个函数或过程. 剖析类当Java虚拟机启动执行时, 它会寻找你在命令列所制定的类. 然后它会锁定一个向下面这样一个特定的方法: 123public static void main (String[] arg) { // 程序代码写在这里} 接着Java虚拟机就会执行main方法在花括号间的所有指令. 每个Java程序可能会有很多类, 但是main()函数只能有一个. 编写带有main()的类在Java中的所有东西都会属于某个类, 而main()是程序的七点. 不管有多少个类, 一定都会有一个main()来作为程序的起点. 保存123456public class MyFirstApp { public static void main(String[] args) { System.out.println(&quot;Hello &quot;); System.out.println(&quot;World!&quot;); }} 编译1javac MyFirstApp.java 运行main()中的常见方法声明、设定、调用方法等普通语句123456int x = 3;String name = &quot;Dirk&quot;;x = x * 17;System.out.print(&quot;x is &quot; + x);double d = Math.random();// 注释 反复做某事123456while (x &gt; 12) { x = x - 1;}for (int x = 0; x &lt; 10; x = x + 1) { System.out.println(&quot;x is now &quot; + x);} 在适当条件下做某件事123456789if (x == 10) { System.out.println(&quot;x must be 10&quot;);} else { System.out.println(&quot;x isn't 10&quot;);}if ((x &lt; 3) &amp; (name.equals(&quot;Dirk&quot;))) { System.out.println(&quot;Gently&quot;);}System.out.print(&quot;this line runs no matter what&quot;); 重复与循环Java中有三种循环结构: while循环、do-while循环和for循环. 我们先从while循环介绍起. 循环的关键在于条件测试. 在Java中, 条件测试的结果是boolean值——不是true就是false. 可以用比较运算符来执行简单的boolean值测试: 1234567891011int x = 4;while (x &gt; 3) { // 循环能够顺利运行 // 因为x确实大于3 x = x - 1;}int z= 27;while (z == 17) { // 循环不能顺利运行 // 因为z不等于17} 与其他语言不同, Java中的integer与boolean两种类型并不相容, 故不能写出形如while (i) {...}之类的代码. 条件分支在Java中if与while循环都是boolean测试, 但功能不同. 123456789public class Party { public static void main(String[] args) { int x = 3; if (x == 3) { System.out.println(&quot;x must be 3&quot;); } System.out.println(&quot;This runs no matter what&quot;); }} 还可以在程序中加入else条件, 实现真正的条件选择. 1234567891011public class Party { public static void main(String[] args) { int x = 3; if (x == 3) { System.out.println(&quot;x must be 3&quot;); } else { System.out.println(&quot;x is NOT 3&quot;); } System.out.println(&quot;This runs no matter what&quot;); }} 开始编写程序——专家术语生成器12345678910111213141516171819public class Party { public static void main(String[] args) { String[] wordListOne = {}; String[] wordListTwo = {}; String[] wordListThree = {}; int oneLength = wordListOne.length; int twoLength = wordListTwo.length; int threeLength = wordListThree.length; int rand1 = (int) (Math.random() * oneLength); int rand2 = (int) (Math.random() * twoLength); int rand3 = (int) (Math.random() * threeLength); String phrase = wordListOne[rand1] + &quot; &quot; + wordListTwo[rand2] + &quot; &quot; + wordListThree[rand3]; System.out.println(&quot;What we need is a &quot; + phrase); }} String数组编写该程序的第一步是创建出三个String数组, 也即保存术语的容器. 数组的声明和创建是很简单的, 下面是一个例子: 1String[] pets = {&quot;Fido&quot;, &quot;Zeus&quot;, &quot;Bin&quot;}; 每个元素放在引号中, 彼此间应以逗号隔开. 数组长度获取为了在每个数组中能够随机地跳出一个单字, 我们需要得知每个数组的大小. 我们可以直接”询问”数组其长度: 1int x = pets.length; 执行后, x的值为3. 随机数我们需要三个随机数. Java本身有一组立即可用的数学方法. random()方法会返回介于0和1之间的值, 所以我们呢需要将此值乘以数组的元素数量, 之后再取证. 1int x = (int) 24.6; 组合字符串我们可以用”+“运算符将字符串对象连接在一起. 使用索引数字可以将数组中的元素提取出来. 12String s = pets[0]; // &quot;Fido&quot;s = s + &quot;&quot; + &quot;is a dog!&quot;; // &quot;Fido is a dog!&quot; 输出到屏幕最后, 我们将结果输出到命令列上即可. 拜访对象村我们要离开过程化的世界, 开始建立自己的对象. 以对象来思考当我们设计类时, 要记得对象是靠类的模型塑造出来的, 即: 对象是已知的事物 对象会执行的动作 其中, 对象本身已知的事物被称为实例变量(instance variable), 对象可以执行的动作被称为方法(methods). 总而言之, 类是对象的蓝图. 创建你的第一个对象要做到”会运用对象”, 我们需要两个类, 一个是被操作与对象的类, 另一个是用来测试该类的类. 后者常被命名为”受测类名称” + TestDrive. 编写类123456789public class Dog { int size; String breed; String name; void bark() { System.out.println(&quot;Ruff! Ruff!&quot;); }} 编写测试用类12345public class DogTestDrive { public static void main(String[] args) { // Dog源代码 }} 在测试用类中建立对象并存取对象的变量和方法12345678public class DogTestDrive { public static void main(String[] args) { // Dog源代码 Dog d = new Dog(); // 建立并存取Dog对象 d.size = 40; // 调用Dog类的方法 d.bark(); }} 快离开main真正的Java程序只会让对象与对象交互. 在Java程序中, main()有两种用处: 测试真正的类 启动你的Java应用程序 这里用一个例子展示Java程序如何”预览”以及对象和对象间如何互动. 猜数字游戏该游戏涉及到game与player两个对象. 其中, game会产生介于0~9之间的随机数字, 而3个player对象会猜测该数字. 类: GuessGame.class、Player.class和GameLauncher.class. 程序逻辑: GameLauncher这个类带有main()方法, 是应用程序的入口点. main()中会创建出GuessGame对象, 并调用它的startGame()方法 startGame()方法是游戏的起点. 它会创建三个player对象, 然后挑出要猜测的随机数字. 它会要求player猜测并检测结果, 过程会被列出来. 123456public class GameLauncher { public static void main(String[] args) { GuessGame game = new GuessGame(); game.startGame(); }} 12345678public class Player { int number = 0; public void guess() { number = (int) (Math.random() * 10); System.out.println(&quot;I'm guessing &quot; + number); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class GuessGame { Player p1; Player p2; Player p3; public void startGame() { p1 = new Player(); p2 = new Player(); p3 = new Player(); int guessp1 = 0; int guessp2 = 0; int guessp3 = 0; boolean p1isRight = false; boolean p2isRight = false; boolean p3isRight = false; int targetNumber = (int) (Math.random() * 10); System.out.println(&quot;I'm thinking of a number between 0 and 9 ...&quot;); while (true) { System.out.println(&quot;Number to guess is &quot; + targetNumber); p1.guess(); p2.guess(); p3.guess(); guessp1 = p1.number; System.out.println(&quot;Player one guessed &quot; + guessp1); guessp2 = p2.number; System.out.println(&quot;Player two guessed &quot; + guessp1); guessp3 = p3.number; System.out.println(&quot;Player three guessed &quot; + guessp1); if (guessp1 == targetNumber) { p1isRight = true; } if (guessp2 == targetNumber) { p2isRight = true; } if (guessp3 == targetNumber) { p3isRight = true; } if (p1isRight || p2isRight || p3isRight) { System.out.println(&quot;We have a winner!&quot;); System.out.println(&quot;Player One got it right? &quot; + p1isRight); System.out.println(&quot;Player Two got it right? &quot; + p2isRight); System.out.println(&quot;Player Three got it right? &quot; + p3isRight); System.out.println(&quot;Game is over.&quot;); break; } else { System.out.println(&quot;Players will have to try again.&quot;); } } }} 认识变量变量有两种: primitive主数据类型和引用. 声明变量为了让类型安全能够发挥作用, 我们必须声明所有变量的类型, 制定他是一个int类型或是一个Dog类型. 变量有两种: primitive主数据类型与对象引用. 其中, primitive主数据类型用来保存基本类型的值, 包括整数、布尔类型和浮点数等; 而对象引用保存的是对象的引用. primitive主数据类型primitive主数据类型有着不同的大小与名称, 如四种大小不同的整数类型long, int, short和byte. 避开关键字Java中的变量命名规则如下: 名称必须以字母、下划线或$符号开头, 不能用数字开头 除了第一个字符, 变量名称的其他位置上都可以用数字 避开Java保留字 变量与对象我们已经指导如何声明primitive主数据类型变量. 但是非primitive主数据类型的变量又该如何处理呢? 有以下要点: 事实上没有”对象变量”这样的东西存在 只有**引用(reference)**到对象的变量 对象引用变量保存的是存取对象的方法 它并不是对象的容器, 而是类似指向对象的指针, 或者可以说是地址. 对象的声明、创建于幅值有三个步骤: 1Dog myDog = new Dog(); 声明一个引用变量1Dog myDog 要求Java虚拟机分配空间给引用变量, 并将变量命名为myDog. 创建对象1new Dog(); 要求Java虚拟机分配堆空间给新建立的Dog对象. 连接对象和引用1Dog myDog = new Dog(); 将新的Dog赋值给myDog这个引用变量. 生活在垃圾处理堆上12Book b = new Book();Book c = new Book(); 声明两个Book的引用变量并创建两个Book对象, 然后将Book对象赋值给引用变量. 现在这两个Book对象储存在堆上. 1Book d = c; 声明新的Book引用变量, 但不床啊金新的Book对象而将变量c的值赋值给变量d. 这表示”将c的字节组合拷贝给变量d“. 此时的c和d引用到同一对象. 1c = b; 将变量b的值拷贝给变量c. 此时, b和c两者都引用相同的对象. 堆上的生与死12Book b = new Book();Book c = new Book(); 声明两个Book的引用变量并创建两个Book对象, 然后将Book对象赋值给引用变量. 现在这两个Book对象生活在堆上. 1b = c; 将变量c的值赋给变量b. 两个变量带有相同的值. 此时, 对象1被抛弃且能够作垃圾收集器(GC). 此时, 对象1已经没有引用, 称为无法存取的变量. 1c = null; 将null值赋给c. 这代表它不再引用任何事物, 但还是可以被制定引用其他Book的引用变量. 对象2还引用到, 随意不能够作垃圾收集器. 数组犹如杯架 声明一个int数组变量.int[] nums; 创建大小为七的数组, 并将它赋值给之前声明为int[]的变量nums.nums = new int[7]; 赋予int数组的每一个元素一个int值. 1234567nums[0] = 6;nums[1] = 6;nums[2] = 6;nums[3] = 6;nums[4] = 6;nums[5] = 6;nums[6] = 6; 数组也是对象数组能够让人使用位置索引来快速、随机地存取其中的元素. 注意, 在Java中, 一旦数组被声明出来, 我们就只能在其中装入所声明类型的元素. 创建Dog数组首先声明一个Dog数组变量. 1Dog[] pets; 创建大小为7的Dog数组, 并赋值给钱买你所声明出的Dog[]类型变量pets. 1pets = new Dog[7]; 创建新的Dog对象并将它们赋值给数组的元素. 12pets[0] = new Dog();pets[1] = new Dog(); 如何存取Dog数组中的Dog对象? 我们只需要数组索引(位置)就可以操作 特定对象了: 1234Dog[] myDogs = new Dog[3];myDogs[0] = new Dog();myDogs[0].name = &quot;Fido&quot;;myDogs[0].bark(); 例子: 12345678910111213141516171819202122232425262728293031public class Dog { public static void main(String[] args) { Dog dog1 = new Dog(); dog1.bark(); dog1.name = &quot;Bart&quot;; Dog[] myDogs = new Dog[3]; myDogs[0] = new Dog(); myDogs[1] = new Dog(); myDogs[2] = dog1; myDogs[0].name = &quot;Fred&quot;; myDogs[1].name = &quot;Marge&quot;; System.out.print(&quot;last dog's name is &quot;); System.out.println(myDogs[2].name); int x = 0; while (x &lt; myDogs.length) { myDogs[x].bark(); x = x + 1; } } String name; public void bark() { System.out.println(name + &quot; says Ruff!&quot;); }} 方法操作实例变量类所描述的是对象知道什么与执行什么. 任一类的每个实例都带有相同的方法, 但是方法可以根据实例变量的值来表现不同的行为. 我们可以通过给对象传值的方法控制对象的具体行为. 传值给方法程序中有两种参数, 即 实参(argument) 形参(parameter) 它们的主要区别在于: 方法会运用形参, 调用的一方会传入实参. 实参是传给方法的值; 当它传入方法后就成了形参. 12Dog d = new Dog();d.bark(3); // 此处的&quot;3&quot;即为实参 12345678910public void bark() { System.out.println(name + &quot; says Ruff!&quot;);}void bark(int numOfBarks) { while (numOfBarks &gt; 0) { System.out.println(&quot;ruff&quot;); numOfBarks = numOfBarks - 1; }} 从方法中获得返回值方法可以有返回值, 也可以没有返回值. 被设定为void的方法无返回值: 12void go() {} 也可以指定一个方法的返回值: 123int giveSecret() { return 42;} 如果一个方法声明有返回值, 就必须返回所声明类型的值. 同时向方法传入多个参数方法可以有多个参数. 在声明时需用逗号分开, 传入的时候也是用逗号分开, 并以正确数量、类型和顺序来传递参数. 123456789void go() { TestStuff t = new TestStuff(); t.takeTwo(12, 34);}void takeTwo(int x, int y) { int z = x + y; System.out.println(&quot;Total is &quot; + z);} 也可以将变量当作参数传入, 只要类型相符就可以. 12345678910void go() { int foo = 7; int bar = 3; t.takeTwo(foo, bar);}void takeTwo(int x, int y) { int z = x + y; System.out.println(&quot;Total is &quot; + z);} Java是通过值传递的, 也就是说通过拷贝传递. 运用参数于返回类型Getter和Setter可让你执行get和set. Getter的目的只有一个, 就是返回实例变量的值; 而Setter的目的就是取用一个参数来设定实例变量的值. 1234567891011121314151617181920212223242526272829public class ElectricGuitar { String brand; int numOfPickups; boolean rockStarUsesIt; String getBrand() { return brand; } void setBrand(String aBrand) { brand = aBrand; } int getNumOfPickups() { return numOfPickups; } void setNumOfPickups(int num) { numOfPickups = num; } boolean getRockStarUsesIt() { return rockStarUsesIt; } void setRockStarUsesIt(boolean yesOrNo) { rockStarUsesIt = yesOrNo; }} 封装(Encapsulation)在介绍封装前, 我们需要先介绍暴露, 即可以通过圆点运算符存取对象中的变量: 1theCat.height = 27; 如此简单的存取方法可能会因使用者的不当操作导致实例变量被不当赋值, 如: 1theCat.height = 0; // 现实中哪有身高为0的猫呢 所以我们需要创建Setter这个方法给所有的实例变量, 并寻求某种方法强制其他程序都必须通过Setter来设定变量而不是直接的存取. 注: 对封装优点的具体解释可以看这里. 有了Setter, 我们就可以防止Cat被设定成无法接收的高度. 12345public void setHeight(int ht) { if (ht &gt; 9) { height = ht; }} 数据隐藏如何隐藏数据呢: 答案是使用公有与私有这两个存取修饰符(access modifier). 以下就是封装的基本原则: 将你的实例变量标记为私有的(private), 并提供公有的(public)getter与setter来控制存取动作. 12345678910111213141516171819202122232425262728293031public class GoodDog { public static void main(String[] args) { GoodDog one = new GoodDog(); one.setSize(70); GoodDog two = new GoodDog(); two.setSize(8); System.out.println(&quot;Dog one: &quot; + one.getSize()); System.out.println(&quot;Dog two: &quot; + two.getSize()); one.bark(); two.bark(); } private int size; public int getSize() { return size; } public void setSize(int s) { size = s; } void bark() { if (size &gt; 60) { System.out.println(&quot;Woof! Woof!&quot;); } else if (size &gt; 14) { System.out.println(&quot;Ruff! Ruff!&quot;); } else { System.out.println(&quot;Yip! Yip!&quot;); } }} 数组中对象的方法数组中的对象就如同其他的对象一样, 唯一的差别就是: 数组中的对象需要用索引取得而已. 声明与初始化实例变量实例变量永远都会有默认值. 如果我们没有明确的赋值给实列变量, 或者没有调用setter, 实例变量还是会有值. 实例变量类型 默认值 intergers 0 floating points 0.0 booleans false references null 实例变量与局部变量之间的差别实例变量是声明在类内而不是方法中12345public class Horse { private double height = 15.2; // 实例变量 private String breed; // 实例变量 // more code ...} 局部变量是声明在方法中的123456789class AddThing { int a; int b = 12; public int add() { int total = a + b; // 局部变量 return total; }} 局部变量在使用前必须初始化123456class Foo { public void go() { int x; // 无法编译 int z = x + 3; }} 变量的比较(primitive主数据类型或引用)如果我们想要知道两个primitive主数据类型是否相等, 只需要使用==运算符即可; 如果我们想要知道两个引用变量是否引用到堆上的同一个对象, 也是使用同样的方法即可. 但如果想要知道两个对象是否真的相等, 则需要使用equals()这个方法, 且相等的意义也需要视对象的类型而定. 编写程序——以战舰游戏为例我们可以通过设计一个战舰游戏来讲解如何编写一个”真正的”Java程序. 游戏目标: 以最少的猜测次数打掉计算机所安排的达康公司(Dot Com)网站. 计算机会根据你的表现来评分. 初始设置: 程序启动后, 计算机会在虚拟的$7 \\times 7$方格上安排三个达康网站. 安排完成后, 游戏会要求你开始猜坐标. 进行游戏: 因为我们还没偶学到图形接口的程序设计, 所以这一版会在命令栏上进行. 计算机会提示你输入所猜测的位置(格子), 输入应为”A3”或”C5”等. 计算机会反馈命中”Hit”、脱靶”Miss”或击沉”Sunk”等回应. 当清楚所有的达康后, 计算机会列出得分情况. 高层设计我们需要类和方法, 但是具体需要哪些类和方法呢? 我们需要通过明晰游戏流程来获得这些信息. 玩家启动游戏 计算机创建3个达康网站 将此3个达康网站停在虚拟战场上 游戏开始, 重复下列操作直到全歼达康网站 提示玩家输入坐标 检查命中情况 游戏结束, 根据猜测次数打分 简单的开始乍一看, 本程序需要两个类, 即Game类和DotCom类. 但是我们先编写一个简单的一维版游戏, 并将其命名为”Simple Dot Com Game”. 开发类当我们在创建Java的类以当作”学习经验”时, 程序会像下面这样: 找出类应该做的事情 列出实例变量和方法 编写方法的伪码 编写方法的测试用程序 实现类 测试方法 除错或重新设计 伪码伪码大致上包括三部分: 实例变量的声明、方法的声明和方法的逻辑. 伪码最重要的部分是方法的逻辑, 因为它定义出会发生”什么事”. 这个部分会在稍后真正编写程序代码时转译成”如何”发生. 为SimpleDotCom编写测试码在开始编写方法之前, 我们需要先写出测试方法用的程序代码. 这一概念来自极限编程方法论(XP), 该方法论帮助程序员更快写出程序代码. 我们首先写出SimpleDotCom对象的测试码. 对于该类而言, 我们关心的只有checkYourself()方法, 但为了让该方法正确运行, 我们还需要实现setLocationCells()方法以便让checkYourself()方法正确执行. 对于checkYourself()方法来说, 有如下几个部分需要进行测试: SimpleDotCom对象的初始化 赋值位置(带有三个int的数组, 如{2,3,4}) 创建代表玩家猜想的字符串 传入伪造的玩家猜测以调用checkYourself()方法 列出结果以观察结果是否正确 SimpleDotCom的测试码: 1234567891011121314151617public class SimpleDotComTestDrive { public static void main(String[] args) { SimpleDotCom dot = new SimpleDotCom(); int[] locations = {2,3,4}; dot.setLocationCells(locations); String userGuess = &quot;2&quot;; String result = dot.checkYourself(userGuess); String testResult = &quot;failed&quot;; if (result.equals(&quot;hits&quot;)) { testResult = &quot;passed&quot;; } System.out.println(testResult); }} checkYourself()方法1234567891011121314151617181920212223public class SimpleDotCom { public String checkYourself(String stringGuess) { int guess = Integer.parseInt(stringGuess); String result = &quot;miss&quot;; for (int cell : locationCells) { if (guess == cell) { result = &quot;hit&quot;; numOfHits++; break; } } if (numOfHits == locationCells.length) { result = &quot;kill&quot;; } System.out.println(result); return result; }} SimpleDotCom与SimpleDotComTester的最终版本12345678910public class SimpleDotComTestDrive { public static void main(String[] args) { SimpleDotCom dot = new SimpleDotCom(); int[] locations = {2,3,4}; dot.setLocationCells(locations); String userGuess = &quot;2&quot;; String result = dot.checkYourself(userGuess); }} 12345678910111213141516171819202122232425public class SimpleDotCom { int[] locationCells; int numOfHits = 0; public void setLocationCells(int[] locs) { locationCells = locs; } public String checkYourself(String stringGuess) { int guess = Integer.parseInt(stringGuess); String result = &quot;miss&quot;; for (int cell : locationCells) { if (guess == cell) { result = &quot;hits&quot;; numOfHits++; break; } } if (numOfHits == locationCells.length) { result = &quot;kill&quot;; } System.out.println(result); return result; }} 游戏的main()方法1234567891011121314151617181920212223public class SimpleDotComGame { public static void main(String[] args) { int numOfGuesses = 0; GameHelper helper = new GameHelper(); SimpleDotCom theDotCom = new SimpleDotCom(); int randomNum = (int) (Math.random() * 5); int[] locations = {randomNum, randomNum+1, randomNum+2}; theDotCom.setLocationCells(locations); boolean isAlive = true; while (isAlive == true) { String guess = helper.getUserInput(&quot;enter a number&quot;); String result = theDotCom.checkYourself(guess); numOfGuesses++; if (result.equals(&quot;kill&quot;)) { isAlive = false; System.out.println(&quot;You took &quot; + numOfGuesses + &quot; guesses&quot;); } } }} 最后一个类: GameHelper1234567891011121314151617import java.io.*;public class GameHelper { public String getUserInput(String prompt) { String inputLine = null; System.out.print(prompt + &quot; &quot;); try { BufferedReader is = new BufferedReader(new InputStreamReader(System.in)); inputLine = is.readLine(); if (inputLine.length() == 0) return null; } catch (IOException e) { System.out.println(&quot;IOException: &quot; + e); } return inputLine; }} 关于for循环基础for循环1for (int i=0; i&lt;100; i++) {} 编译器会以如下方式解读这行代码: 创建变量i并赋值为0 只要i小于100就重复执行 在每趟城府过程最后把i加1 加强版的for循环自Java 5.0开始, Java就有了一种加强版的for循环, 能够很容易地逐个运行数组或其他集合(collection)的元素. 1for (String name:nameArray) {} 编译器会以如下方式解读这行代码: 创建名称为name的String变量 将nameArray的第一个元素值赋给name 执行重复的内容 赋值给下一个元素name 重复执行直至所有元素都被运行为止 认识Java的APIArrayList的操作创建: 1ArrayList&lt;Egg&gt; myList = new ArrayList&lt;Egg&gt;(); 加入元素: 12Egg s = new Egg();myList.add(s); 再加入元素: 12Egg b = new Egg();myList.add(b); 查询大小: 1int theSize = myList.size(); 查询特定元素: 1boolean isIn = myList.contains(s); 查询特定元素的位置: 1int idx = myList.indexOf(b); 判断几何是否为空: 1boolean empty = myList.isEmpty(); 删除元素 1myList.remove(s); 使用函数库(Java API)在Java的API中, 类被包装在包中. 要使用API中的类, 我们必须知道他被放在哪个包中. 在使用API时, 我们必须知名程序代码中所用到的类的完整名称, 如java.util.ArrayList; 同时, 必须告诉Java使用的到底是哪个ArrayList. 你可以每次使用的时候都把包名打完整, 也可以直接import, 省时省力: 1import java.util.ArrayList; 继承与多态继承的运行方式在设计继承时, 我们将共同的程序代码放在某个类中, 然后告诉其他的类, 说此类是它们的父类. 当某个类集成了另一个类的时候, 也就是子类继承自父类. 用Java的方式说, 这是”子类继承父类”. 1234567891011121314public class Doctor { boolean worksAtHospital; void treatPatient() {}}public class FamliyDoctor extends Doctor { boolean makesHouseCalls; void giveAdvice() {}}public class Surgeon extends Doctor { void treatPatient() {} void makeIncision() {}} 继承层次的设计——以设计动物仿真程序为例假设要设一个仿真系统程序, 可以让用户设定将一群动物丢到某种环境中以观察会发生什么事情. 我们已经被告知一部分会用的动物(狮子、河马、老虎、狗、猫和狼), 但是并不知道以后还会有多少中动物会被加进来. 每一个动物都会用一个对象来表示, 且动物会在环境中活动, 执行任何被设计的行为. 我们首先要辨别出所有动物都有的、抽象的共同特征, 然后以这些共同特征设计出能够让所有动物加以扩充的类. 找出具有共同属性和行为的对象狮子、河马、老虎、狗、猫和狼间各有什么异同? 这些类型又有什么相关性? 设计代表共同状态与行为的类我们有五个实例变量: picture: 动物JPEG图像的名称 food: 此动物所吃的食物 hunger: 代表饥饿程度的int值 boundaries: 代表动物活动范围区域的长宽 location: 动物在活动区域中的X与Y坐标 还有四个方法: makeNoise(): 动物发出声音的行为程序 eat(): 动物遇到事物时的行为程序 sleep(): 睡眠的行为程序 roam(): 不再进食或睡眠时的行为程序 由于六个动物都是动物, 我们可以用Animal作为共同父类的名称. 决定子类是否需要让某项行为有特定不同的运作方式再仔细考虑后, 我们认为, eat()和makeNoise()应该由各个子类自行覆盖. 通过寻找使用共同行为的子类来找出更多抽象化的机会我们观察到Wolf和Dog间、Lion、Tiger和Cat间有某些共同的行为. 完成类的继承层次我们使用全科和猫科动物的分类来做出Canine和Feline两个类. 每个类中都有各自的roam()方法. 调用哪个方法?当调用对象引用的方法时, 我们会调用到与该对象类型最接近的方法. 子类能够继承哪些东西?子类可以继承父类的成员, 但父类可以通过存取权限决定子类是否能够继承某些特定的成员. 此处只介绍如下所示的四种存取权限, 其限制程度从左到右依次降低: 1private default protected public private类型的成员不会被继承, 而public类型的成员会被继承. 使用继承的几个条件 当某个类比其父类更具有特定意义时使用继承 在行为程序(实现程序代码)应该被多个相同基本类型类所共享时, 应考虑使用继承 继承有时候并不是达成重用行为程序的最佳方式 如果两者间不能通过IS-A测试就不要应用继承关系. 一定要确定子类是父类一种更特定的类型才可以 继承的意义通过设计继承的过程我们可以累计面向对象的经验. 通过提取出一组类间共同的抽象性, 我们能够排除掉重复的程序代码而将这个部分放在父类中. 避免了重复的程序代码 定义出共同的协议 继承可以确保某个父型之下的所有类都有父型所持有的全部方法, 也就是说, 我们会通过继承来定义相关类间的共同协议. 当我们定义出一组类的父型时, 我们可以用子型的任何类来填补任何需要或期待父型的位置. 多态的运行若要观察多态是如何运行的, 我们就需要先复习一下一般声明引用和创建对象的方法: 声明一个引用变量 创建对象 连接对象和引用 重点在于, 引用类型与对象的类型必须相符. 1Dog myDog = new Dog(); 但是在多态下, 引用与对象可以是不同的类型. 1Animal myDog = new Dog(); 运用多态时, 引用类型可以是实际对象类型的父类. 当我们声明一个引用变量时, 任何对该引用变量类型可通过IS-A测试的对象都可以被赋值给该引用. 换句话说, 任何extends过声明引用变量类型的对象都可以被赋值给这个引用变量. 这样我们就可以创建出多态数组一类的东西. 举个例子: 1234567891011121314// 声明Animal类型的数组Animal[] animals = new Animal[5];// 但我们可以放任何Animal类的子类进去animals[0] = new Dog();animals[1] = new Cat();animals[2] = new Wolf();animals[3] = new Hippo();animals[4] = new Lion(); // 我们可以将数组的元素调出来当作Animal对象来操作for (int i = 0; i &lt; animals.length; i++) { animals[i].eat(); animals[i].roam();} 参数和返回类型也可以多态. 123456789101112131415class Vet { public void giveShot(Animal a) { a.makeNoise(); }}class PetOwner { public void start() { Vet v = new Vet(); Dog d = new Dog(); Hippo h = new Hippo(); v.giveShot(d); // 执行Dog的makeNoise() v.giveShot(h); // 执行Hippo的makeNoise() }} 通过将程序代码编写成使用多态参数的程序, 即将参数声明成父类类型, 我们就可以在运行时传入任何的子类对象; 此外, 在引进新子类后, 我们也不必修改以前的程序. 如果你想放置某个类被做出子类, 有三种方法可供选择: 进行存取控制 使用final修饰符——它表示这里是继承树的末端, 不能被继承 让类只拥有private的构造程序(constructor) 覆盖的规则如果想要在子类中覆盖掉父类中的某些方法, 我们需要先遵守以下规则: 参数必须相同, 且返回类型必须要兼容 不能降低方法的存取权限 方法的重载(Overload)重载的意义是两个方法的名称相同, 但参数不同. 这也是其与多态的区别所在. 重载可以有同一方法的多个不同参数版本以方便调用. 它有着下列特点: 返回类型可以不同 不能只改变返回类型 可以更改存取权限 下面是一个合法的重载范例: 1234567891011121314151617public class Overloads { String uniqueID; public int addNum(int a, int b) { return a + b; } public double addNum(double a, double b) { return a + b; } public void setUniqueID(String theID) { uniqueID = theID; } public void setUniqueID(int ssNumber) { String numString = &quot;&quot; + ssNumber; setUniqueID(numString); }} 接口与抽象类继承只是个开始. 要使用多态, 我们还需要接口. 我们需要超越简单的继承并前进到只有通过设计与编写接口规格才能达成的适应性与扩展性. 到底接口是什么呢? 它是一种100%纯抽象的类. 什么是抽象类? 它是无法初始化的类. 有些类不该初始化在前面的章节中, 我们为了介绍继承的概念写了一个仿真动物行为的例子. 在这个例子中, 我们通过继承Animal类建立了具体的动物类, 并以此创建了各动物类的对象. 但是, 如果我们要创建Animal类的对象, 会发生什么呢? 答案是不会发生什么. 但是, 这个世界上毕竟没有叫做”动物”的动物, 我们硬要把它当作对象创建出来也毫无意义; 但是我们又需要Animal类来继承和产生多态. 但是要限制只有它的子类才能被初始化. 在Java中, 通过标记类为抽象类, 编译器就知道这个类不能被初始化, 即被new出来. 具体实施方法就是在类的声明前面加上抽象类关键词abstract即可. 123abstract class Canine extends Animal { public void roam() {}} 当设计好继承结构后, 我们必须要决定哪些类是抽象的, 哪些又是具体的. 抽象类除了被继承之外, 是没有用途、没有值且没有目的的. 抽象的方法除了类之外, 我们也可以将方法标记为abstract的. 抽象的类代表此类必须要被extend过, 抽象的方法代表此方法一定要被覆盖过. 抽象的方法没有实体, 所以抽象方法的代码是这样的: 1public abstract void eat(); // 没有方法体, 直接以分号结束 如果我们声明了一个抽象的方法, 我们就必须将包含这个方法的类表姐为抽象的. 此外, 我们必须实现所有抽象的方法. 多态的使用假设我们不知道有ArrayList这种类而想要自行编写维护list的类以保存Dog对象. 在第一轮我们指挥写出add()方法. 我们使用大小为五的简单Dog数组Dog[]来保存新加入的Dog对象. 当Dog对象超过五个时, 我们还是可以调用add()方法, 但是什么都不会发生. 如果没有越界, add()会把Dog装到可用的数组位置中, 然后递增可用索引nextIndex. 自创Dog专用的list123456789101112public class MyDogList { private Dog[] dogs = new Dog[5]; private int nextIndex = 0; public void add(Dog d) { if (nextIndex &lt; dogs.length) { dogs[nextIndex] = d; System.out.println(&quot;Dog added at &quot; + nextIndex); nextIndex++; } }} 还要给Cat用?如果我们发现现在还要写一个给Cat用的list, 我们是另外单独创建一个MyCatList类; 还是创建一个单独的DogAndCat类, 用addCat(Cat c)与addDog(Dog d)来同时处理两个不同的数组实例呢? 都不是. 我们编写一个不同的AnimalList类让它处理Animal所有的子类. 123456789101112public class MyAnimalList { private Animal[] animals = new Animal[5]; private int nextIndex = 0; public void add(Animal a) { if (nextIndex &lt; animals.length) { animals[nextIndex] = a; System.out.println(&quot;Animal added at &quot; + nextIndex); nextIndex++; } }} 如果要为所有类写一个list呢?如果要为所有类写一个这样的list, 我们就需要为所有的类找到一个父类. 但是, 真的有这样的类吗? 实际上是有的, 这个类就是Object类. Object类在Java中, 所有的类都是从Object这个类中继承下来的. Object类是所有类的源头, 是所有类的父亲. 终极对象中都有什么? equals(Object o): 检测两个对象是否是”相等”的 getClass(): 告诉使用者对象是从哪里被初始化的 hashCode(): 返回对象的哈希值 toString(): 列出类的名称和一个我们并不关系的数字 那么, 代价是什么呢?在开始以Object类型使用所有适用性参数和返回类型之前, 我们应该考虑到使用Object类型作为引用的一些问题. 此处并不涉及制作出Object类型的实例, 这是在说以Object类型作为引用的其他类型. 当我们将对象装进ArrayList&lt;Dog&gt;中时, 它会被当作Dog来输入与输出; 但若你把它声明成ArrayList&lt;Object&gt;时会怎样? 如果我们创造出一个可以保存任何一种对象的ArrayList, 并尝试将Dog对象取出并赋值给Dog的引用时会发生什么事? 答案是无法通过编译. 任何从ArrayList&lt;Object&gt;取出的东西都会被当作Object类型的引用而不管它原来是什么. 如果想要将被编译器看作是Object类的Dog对象转回来, 我们可以从Object中拷贝出一个Dog引用, 并将其赋值给Dog引用变量. 123Object o = al.get(index);Dog d = (Dog) 0;d.roam(); 如果你不能确定他是Dog, 我们可以用instanceof这个运算符来检查. 如果类型抓换错了, 程序会弹出ClassCastException异常并终止程序. 123if (o instanceof Dog) { Dog d = (Dog) 0;} 由此, Java中引用变量的类型的重要性可见一斑. 我们只能在引用变量的类确实有该方法时才能够调用它. 但是, 如果我们想要在某个已经继承了一个父类的类中再引入其他类的功能呢? 我们要再继承一个父类的内容吗? 显然是不行的, 因为如果两个父类中有名称相同的方法的话, 子类会不知道究竟应该继承哪一个. 实际上, Java也不支持继承两个父类的方法. Java提供的解决方式为: 接口. 接口接口(interface)是专为解决上述情况而生的. 它采用的方法也很简单: 将全部的方法都设为抽象的. 由此我们知道, 应该如下定义一个接口: 1234public interface Pet { abstract void beFriendly(); abstract void play();} 如果要实现一个接口的话, 应该编写如下代码: 1public class Dog extends Canine implements Pet {...} 相比继承, 接口还有一个特点, 即不同继承树的类也可以实现相同的接口. 当我们把一个类当作是多态类型运用时, 相同的类型必定来自同一个继承树; 但当我们用接口来作为多态类型时, 对象就可以来自任何地方了. 此外, 类还可以实现多个接口, 如: 1public class dog extends Animal implements Pet, Saveable, Paintable {...} 如何判断应该设计类、子类、抽象类还是接口呢 如果新的类无法对其他的类通过IS-A测试时, 就设计不继承其他类的类; 只要在需要某类的特殊化版本时, 以覆盖或增加新的方法来继承现有的类; 当你需要定义一群子类的模板, 又不想让程序员初始化此模板时, 设计出抽象的类给它们用; 如果想要定义出类可以扮演的角色, 使用接口. 调用父类的方法super关键字能够实现在子类中调用父类方法的功能. 12345678910111213141516abstract class Report { void runReport() { // 设计报告 } void printReport() { // 输出 }}class BuzzwordsReport extends Report { void runReport() { super.runReport(); // 调用父类方法 buzzwordCompliance(); printReport(); } void buzzwordCompliance() {...}} 构造器与垃圾收集器栈与堆在Java中, 内存被分为两种区域: 对象的生存空间堆(heap)以及方法调和变量的生存空间栈(stack). 注意: 并不是所有变量都生活在栈中. 变量分为实例变量和局部变量. 实例变量是被声明在类而不是方法中的变量, 它们被存储于所述的对象中; 局部变量, 又称栈变量, 被声明在方法中. 只有局部变量(栈变量)被储存在栈中, 其余变量均被储存在堆中. 栈上的方法当我们调用一个方法时, 该方法会被放在调用栈的栈顶. 实际被堆上栈的是堆栈块, 它带有方法的状态. 栈上的对象引用非primitive变量保存的只是对象的引用, 而不是对象本身. 故只有保存引用的变量自己被放在了栈上; 对象自己是在堆中待着的. 堆上的实例变量在我们想要新建一个对象时, Java必须为这个对象在堆上找一个位置. 对象中的实例变量会被存放在其中. 但是, 如果实例变量自己也是个对象呢? 如果对象带有一个其他类的对象呢? 如果对象带有其他对象的引用变量呢? 实际上, Java只会为引用变量留出空间. 至于”另一个对象”, 则需要考虑它是什么时候被创建的: 如果声明了对象却没有被赋值, 则只会留下变量的空间: 1private Antenna ant; 自横刀引用变量被赋值一个新的对象, 堆上才会有这个新对象的空间. 1private Antenna ant = new Antenna(); 创建对象详解——构造函数我们都知道, 声明对象并赋值有三个步骤: 声明引用变量、创建对象以及连接对象和引用. 但是新对象究竟是如何诞生的呢? 1Duck myDuck = new Duck(); 我们在创建Duck对象的时候编写了new Duck()代码. 看上去就像调用了一个叫做Duck()的方法. 但实际上不是的, 我们只是调用了Duck的构造函数. 构造函数看起来很像方法, 但实际上并不是. 它会在我们初始化一个对象的时候执行. 我们可以自己编写构造函数, 也可以让编译器帮我们编写一个. 通常, 编译器编写的构造函数是这样的: 123public Duck() { } 从中我们能够看到构造函数与方法的区别: 方法每返回类型, 但是构造函数没有返回类型 构造函数的名称一定要与类的名称相同. 构造Duck构造函数的一项关键特征是它会在对象能够被赋值给引用之前就执行. 在任何人取得对象的遥控器之前, 对象有机会对构造过程给予协助. 1234567891011public class Duck { public Duck() { System.out.println(&quot;Quack&quot;); // 嘎 }}public class UseDuck { public static void main(String[] args) { Duck d = new Duck(); }} 上面的代码在运行后会输出一个Quack. 这证明我们可以借助构造函数干涉对象构件过程. 新建Duck状态的初始化大部分的人都是使用构造函数来初始化对象的状态. 也就是说, 设置和给对象的实例变量赋值. 123public Duck() { size = 34;} 这在开发者知道Duck类应该有多大时是没有问题的. 但如果是要由使用Duck的程序员来决定时怎么办? 那我们就需要使用类的set方法来设置了. 但这会让Duck暂时处于没有大小数值的状态(实例变量没有默认值), 且需要两行才能完成赋值, 如: 123456789public class Duck { int size; public Duck() { System.out.println(&quot;Quack&quot;); // 嘎 } public void setSize(int newSize) { size = newSize; }} 123456public class UseDuck { public static void main(String[] args) { Duck d = new Duck(); d.setSize(42); }} 如果某种对象不应该在状态被初始化之前就使用, 就不要让任何人能够在没有初始化的情况下取得该种对象. 以Duck为例, 让用户先构造出Duck对象再来设定大小是很危险的. 如果用户不知道这件事, 或者干脆忘了要调用set方法, 那Duck对象就会陷入没有大小的混沌状态. 最好的解决办法就是将初始化的程序代码放在构造函数中, 然后将构造函数设定成需要参数的. 12345678public class Duck { int size; public Duck(int duckSize) { System.out.println(&quot;Quack&quot;); // 嘎 size = duckSize; System.out.println(&quot;Size is &quot; + size); }} 12345public class UseDuck { public static void main(String[] args) { Duck d = new Duck(42); }} Duck的产后护理一定要有不需要参数的构造函数还是以Duck为例. 让程序员自己定义Duck的大小固然是好, 但是如果程序员自己也不知道大小, 我们还强迫人家在构造函数里填一个值就未免有些强人所难了. 所以我们需要构件一个不需要参数的构造函数: 一个可以指定Duck的大小, 一个使用默认值而无需指定大小. 1234567891011public class Duck { private int size; public Duck(int duckSize) { System.out.println(&quot;Quack&quot;); // 嘎 size = duckSize; System.out.println(&quot;Size is &quot; + size); } public Duck() { size = 27; }} 另外, 就算一个类不可能提供默认值, 我们也要提供无参数的构造函数. 编译器不是什么时候都会帮你写构造函数的在我们写了一个有参数的构造函数后, 编译器就不会再插手构造函数的编写工作. 如果我们还想写一个没有参数的构造函数, 就只能自行编写. 此外, 如果类有一个以上的构造函数, 则参数一定要不一样. 编译器看的是参数的类型和顺序, 而不是参数的名字. 我们完全可以编写出参数类型相同但是顺序不同的构造函数. 父类的空间——父类与子类的构造函数在创建某个对象时, 对象会取得所有实例变量所需的空间, 其中必然包括一路继承下来的东西. 在创建新对象的同时, 所有继承下来的构造函数都会被执行. 执行new命令的指令是个大事, 因为它会引起构造函数的连锁反应. 此外, 抽象类也有构造函数. 虽然不能对抽象的类执行new操作, 但是抽象类也是父类, 其构造函数会在具体子类创建时执行. 至于原因: 在构造函数中使用super调用父类的构造函数的部分. 要记得子类可能会根据父类的状态来继承方法(即父类的实例变量). 完整的对象需要同样玩这个的父类核心, 故子类必须调用父类的构造函数. 构造函数在执行的时候, 第一件事就是去执行它的父类的构造函数, 这会向上推到Object这个类为止. 12345public class Animal { public Animal() { System.out.println(&quot;Making an Animal&quot;); }} 12345public class Hippo extends Animal { public Hippo() { System.out.println(&quot;Making a Hippo&quot;); }} 123456public class TestHippo { public static void main(String[] args) { System.out.println(&quot;Starting ...&quot;); Hippo h = new Hippo(); }} 运行结果: 123Starting ...Making an AnimalMaking a Hippo 如何调用父类的构造函数以Duck的构造函数来说, 它不是通过Animal(), 而是通过super()来调用父类Animal的构造函数的, 如下: 1234567public class Duck extends Animal { int size; public Duck(int newSize) { super(); size = newSize; }} 在子类的构造函数调用super()后, 编译器会将父类的构造函数放在堆栈的最上方. 而父类的构造函数又会调用父类的父类的构造函数, 直到Object类的构造函数为止. 在Object的构造函数运行完毕后, 其子类的构造函数就会一路弹出, 直到最初的构造函数. 如果我们没有调用super(), 编译器就会帮我们在构造函数中加入super(), 以调用父类的构造函数. 但是编译器添加的构造函数一定是没有参数的super(), 就算父类有带参数的构造函数也是这样. 注意, super()只能放在构造函数的第一行上. 对象的生命周期父类的部分必须在子类创建完成之前就必须完整地成型, 因为子类对象可能需要动用到从父类继承下来的东西. 父类的构造函数必须在子类的构造函数之前结束. 有参数的父类构造函数如果父类的构造函数有参数怎么办? 能够传递值进去吗? 如果不行的话, 则没有无参数构造函数的类将不能被继承. 想象这个场景: 所有的动物都有名字. 所以, Animal类有个getName()可以返回name实例变量的值. 此实例变量是被标记为private的, 但Hippo这个子类把getName()这个方法继承下来了. 问题来了: Hippo有getName()这个方法但是没有name实例变量. Hippo要靠Animal的部分来维持name实例变量, 然后从getName()来返回这个值. 但Animal要如何获得这个值呢? 唯一的机会是通过super()来引用父类, 所以要从这里把name的值传进去, 让Animal把它存到私有的name实例变量中. 12345678910public abstract class Animal { private String name; // Every animal has a name. public String getName() { // Hippo会继承这个get方法 return name; } public Animal(String theName) { // 有参数的构造函数, 用来设定name name = theName; }} 12345public class Hippo extends Animal { public Hippo(String name) { // 如果不传给这个构造函数值, 编译器会报错 super(name); // 传给Animal的构造函数 }} 1234567public class TestHippo { public static void main(String[] args) { System.out.println(&quot;Starting ...&quot;); Hippo h = new Hippo(&quot;Buffy&quot;); System.out.println(h.getName()); }} 调用重载版本——从某个构造函数调用重载版的另一个构造函数如果某个重载版的构造函数除了不能处理不同类型的参数之外, 可以处理所有的工作, 那要怎么般? 我们不能让相同的程序代码出现在每个构造函数中, 所以我们可以将程序代码只摆在某个构造函数中(包括对super()的调用). 如此一来, 多有的构造函数就都会有限调用该构造函数, 让他来执行真正的构造函数. 为此, 我们需要使用this()或this(aString)或this(27, x). 换句话说, this()是对对象本身的调用. 需要注意的是: this()只能出现在构造函数中; this()必须为构造函数的第一句语句; super()和this()不能同时调用. 123456789101112class Mini extends Car { Color color; public Mini() { this(Color.Red); // 无参数的构造函数以默认的颜色调用真正的构造函数 } public Mini(Color c) { super(&quot;Mini&quot;); // 真正的构造函数 color = c; }} 对象的死亡对象的生命周期完全取决于其引用的状态. 如果引用还存在, 则对象也会继续待在堆上; 如果引用”死掉”了, 对象就会被从堆上移除. 那变量又会存在多久呢? 这取决于它是局部变量还是实例变量: 局部变量只存在于声明该变量的方法中; 实例变量的寿命与对象相同. “life”和”scope”的差别 “life”: 只要变量的堆栈还存在于堆栈上, 局部变量就算或者, 即活到方法执行完毕为止; “scope’: 局部变量的范围只限于声明它的方法之内. 当此方法调用别的方法时, 该变量还活着, 但不在目前的范围内. 执行其他方法完毕返回时, 范围也就跟着回来. 引用变量的死亡引用变量的死活判断与primitive主数据类型变量相同. 真正的问题在于: 变量的生命周期如何影响对象的生命周期? 只要有或者的引用, 对象也就会活着. 如果某个对象的引用已经不在它的范围中, 但该引用还是活着的, 则此对象就会继续活在堆上. 如果对象的唯一引用死了, 对象就会从堆中被踢开. 引用变量会跟随堆栈块一道解散, 被踢开的对象也就此出局, 成为了”可被垃圾回收器回收的”. 有三种方法能够将对象变为可被回收的: 对象的引用变量所在的方法被弹出堆栈; 对象的引用变量被复制到其他的对象上; 对象的引用变量被赋了null. 数字与静态Math方法想要执行Math中的方法并不需要创建Math的实例变量. 实际上我们也创建不出来, 因为它们的都是”静态”的. 我们用到的只有这个类本身. 静态方法与非静态方法Java是面向对象的. 但如果有需求(通常是实用方法), 则不需要类的实例. 关键词static可以标记出不需要实例的方法. 一个静态的方法意味着”一种不依靠实例变量也就不需要对象的行为”. 带有静态方法的含义带有静态方法的类一般都不打算被初始化. 这样的类的构造函数一般都被限制为private. 但这并不意味着有一个或多个静态方法的类就不可以被初始化, 毕竟只要有main()的类都算作是有静态方法的类. 由此可知, 我们可以自由地在类中组合静态与非静态方法. 然而任何非静态方法都需要某种实例来操作. 取得新对象的方法也只有通过new或者序列化(deserialization)以及我们暂时设计不到的Java Reflection API. 除此之外, 别无他发. 实际上, 由谁来新建是一个很有意思的问题. 我们会在下面讨论它. 静态方法不能调用非静态变量静态的方法实在无关特定类的实例情况下执行的. 因为静态的方法是通过类的名称来调用, 所以静态的方法无法引用到该类的任何实力变量. 在此情况下, 静态的方法也不会知道可以使用哪个实例变量值. 静态方法也不能调用非静态方法与非静态变量的情况类似, 静态方法也不能调用非静态方法: 实例不存在, 对应的方法也就不存在. 静态变量假设我们要在执行过程中计算有多少Duck的实例已经被建立出来, 应该怎么作? 在构造函数中递增某个实例变量的值? 123456public class Duck { int duckCount = 0; public Duck() { duckCount++; }} 上述代码不行, 因为duckCount是个实例变量, 对象与对象间相互不影响, 所以行不通. 但是, 我们可以将duckCount声明为static变量: 1234567891011121314public class Duck { private int size; private static int duckCount = 0; public Duck() { duckCount++; } public void setSize(int s) { size = s; } public int getSize() { return size; }} 这样, 所有的duckCount值就都是相等的. 每当我们创建一个duckCount对象时, duckCount就加1, 由此实现数量的统计. 静态变量的起始动作静态项目的初始化有两项保证: 静态变量会在该类的任何对象创建之前就完成初始化; 静态变量会在该类的任何静态方法执行之前就初始化. 静态final变量是常数一个被标记为final的变量代表它一旦被初始化之后就不会被改动. 也就是说, 类加载之后静态final变量就一直会维持原值. 以Math.PI为例: 1public static final double PI = 3.141592653589793; 此变量被标记为public, 因此可供各方读取; 此变量被标记为static, 因此你不需要Math的实例; 此变量被标记为final, 因为圆周率是不变的. 没有其他的方法再可以将一个变量标记为不变的, 但是又约定俗成的命名惯例可以帮助我们这些人类认出来, 即常熟变量的名称应该要都是大写字母. 静态final变量的初始化有两种方法. 一是在声明的时候: 123public class Foo { public static final int FOO_X = 25;} 二是在静态初始化程序中: 1234567public class Bar { public static final double BAR_SIGH; static { BAR_SIGN = (double) Math.random(); }} 如果没有按上述两种方式中的一种为静态final变量初始化的话, 如: 123public class Bar { public static final double BAR_SIGN;} 编译器会报错, 要求你初始化这个变量. final的其他用法final不只用在静态变量上. 我们也可以用final关键字来修饰非静态的变量, 其中包括实例变量、局部变量以及方法的参数. 他们都代表被修饰的值不能变动. 我们也可以使用final来防止方法的覆盖或创建子类. 总结一下: final的变量代表其值不能被修改; final的方法代表该方法不能被覆盖; final的类代表该类不能被继承. primitive主数据类型的包装我们有时想要把primitive主数据类型当作对象来处理. 如Java 5.0之前, 我们无法直接将primitive主数据类型装入ArrayList或HashMap中. 但是, 每个primitive主数据类型都有一个包装用的类, 且这些包装类都放在Java.lang这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示: primitive主数据类型名称 包装类名称 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double 包装过程如下: 12int i = 200;Integer iWrap = new Integer(i); 解包装过程如下: 1int unWrapped = iWrap.intValue(); autoboxing: 不必将primitive主数据类型与对象分得那么清楚从5.0版本开始加入的autoboxing功能能够自动将primitive主数据类型转换成包装过的对象. 12345public void doNumsNewWay() { ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;(); listOfNumbers.add(3); int num = listOfNumbers.get(0);} “无处不在的”autoboxing 方法的参数 返回值 boolean表达值 数值运算 赋值 包装的静态实用方法除了一般类的操作外, 包装也有一组实用的静态方法. 我们在之前已经使用过一个: Integer.parseInt(). 这个方法取用Strinig并返回primitive主数据类型值. 12345String s = &quot;2&quot;;int x = Integer.parseInt(s);double d = Double.parseDouble(&quot;420.24&quot;);boolean b = new Boolean(&quot;true&quot;).booleanValue(); // 将String转换为boolean的唯一方法 反过来, 我们也可以将primitive主数据类型值转换成String. 12345double d1 = 42.5;String doubleString1 = &quot;&quot; + d; // &quot;+&quot;运算符是Java中唯一一个重载过的运算符double d2 = 42.5;String doubleString2 = Double.toString(d); 异常处理——以创建MIDI音乐播放器为例JavaSound API如果我们想要创建一个MIDI音乐播放器, 我们首先需要知道如何让Java”发生”. JavaSound API解决了这一问题. Sequencer对象在我们要能够发出任何声音之前, 必须先要取得Sequencer对象. 12345678910111213import javax.sound.midi.*;public class MusicTest1 { public void play() { Sequencer sequencer = MidiSystem.getSequencer(); System.out.println(&quot;We got a sequencer.&quot;); } public static void main(String[] args) { MusicTest1 mt = new MusicTest1(); mt.play(); }} 但是, 上述代码会在执行时报错, 无法通过编译. 为什么呢? 调用有风险的方法假设我们调用了一个不是自己写的方法. 该方法在执行某些有风险的任务时可能会出现状况. 我们必须意识到: 该方法是有风险的, 所以, 我们需要写出可以在发生状况时加以处理的程序代码, 未雨绸缪. Java的异常处理机制是一个简洁且轻量化的例外状况处理方式. 它能够将处理错误状况的程序代码摆在一个容易阅读的为止上. 如何得知某个方法会抛出异常呢? 我们可以在方法的声明中的throws语句中看到. 我们在getSequencer()方法的说明中, 我们看到, getSequencer()可能会抛出MidiUnavailableException异常. 编译器需要确定我们知道这种风险的存在, 而告知其的方法便是将有风险的程序代码包含在try/catch块中. try/catch块会告诉编译器你确实知道所调用的方法会有风险, 并且也已经准备好要处理它, 它只会注意你有没有表示你会注意到异常. 1234567891011121314151617import javax.sound.midi.*;public class MusicTest1 { public void play() { try { Sequencer sequencer = MidiSystem.getSequencer(); System.out.println(&quot;We got a sequencer.&quot;); } catch (MidiUnavailableException ex) { System.out.println(&quot;Bummer&quot;); } } public static void main(String[] args) { MusicTest1 mt = new MusicTest1(); mt.play(); }} 异常也是一种对象异常也是一种对象, 且Exception类型的对象可以是任何它的子类的实例, 所以我们catch住的也是对象. 12345try { // 危险动作} catch(Exception ex) { // 尝试恢复} 谁抛出的异常?现在我们只需要知道: 当我们的程序代码调用有风险的方法时, 也就是声明有异常的方法时, 就是该方法把异常丢给你的. 实际上, 两者都有可能是我们自己写的. 但事实上, 谁写的程序其实并不重要; 重要的是在哪个方法抛出异常以及由哪个方法抓住他. 在编写可能会抛出异常的方法时, 它们都必须声明由异常. 有风险、会抛出异常的程序代码12345public boid takeRisk() throws BadException { if (abandonAllHope) { throw new BadException(); }} 调用该方法的程序代码12345678public void crossFingers() { try { anObject.takeRisk(); } catch(BadException ex) { System.out.println(&quot;Aaargh&quot;); ex.printStackTrace(); // 如果无法从异常中恢复, 至少也可以用printStackTrace()来列出有用的信息 }} 受检查的与不受检查的异常编译器会核对除了RuntimeExceptions之外的每件事. 编译器保证: 如果你有抛出异常, 则你一定要使用throw来声明这件事; 如果你调用会抛出异常的方法, 你必须得确认你知道异常的可能性. 将调用包在try/catch块中是一种满足编译器的方法. 除了RuntimeExceptions这种特例之外, 编译器会关照Exception所有的子类. 任何继承过RuntimeExceptions的类都不会受编译器关于是否声明它会抛出RuntimeExceptions的检查. 同样的, 也不会管调用方是否认识到可能会在运行期间遇到异常. 异常与流程控制当要调用有风险的方法时, 有一两件事可能会发生. 该方法要么成功执行了try块中的内容, 要么将异常丢回调用方的方法. finally块: 无论如何都要执行的部分finally块是用来存放不管有没有异常都得执行的程序. 12345678try { turnOvenOn(); x.bake();} catch (BakingException ex) { ex.printStackTrace();} finally { turnOvenOff();} 需要注意的是, 就算try块或catch块中有return命令, finally还是会执行. 流程会跳到finally块然后再执行return命令. 一次抛出多个异常如果有必要的话, 方法可以抛出多个异常. 但该方法的声明必须要含有全部可能的检查异常(若两个或两个以上的异常有共同的父类时, 可以只声明该父类就行). 12345public class Laundry { public void doLaundry() throws PantsException, LingerieException { // 有可能抛出两个异常的程序代码 }} 123456789101112public class Foo { public void go() { Laundry laundry = new Laundry(); try { laundry.doLaundry(); } catch(PantsException pex) { // 恢复程序代码 } catch(LingerieException lex) { // 恢复程序代码 } }} 异常也是多态的异常除了可以被抛出外与对象无异, 故异常也可以能够以多态的方式来引用. 举例来说, LingerieException对象能够被赋值给ClothingException的引用. PantsException也能够被赋值给Exception的引用. 这样的好处是方法可以不必明确声明每个可能抛出的异常, 只声明父类就可以了. 对于catch块来说, 也可以不用对每个可能的异常做处理, 只要有一个或少数几个catch可以处理所有的异常就足够了. 以异常的父型来声明会抛出的异常1public void doLaundry() throws ClothingException {} 以所抛出的异常父型来catch异常1234567891011try { laundry.doLaundry();} catch(ClothingException cex) { // 可以catch任何ClothingException的子类 // 解决方案}try { laundry.doLaundry();} catch(ClothingException cex) { // 只能catch两种子类 // 解决方案} 合理使用父型我们固然可以直接在catch中写一个Exception类直接抓取所有的异常, 但如果需要异常的不同做出不同的处理的话, 我们还是需要具体地写一下catch代码. 123456789try { laundry.doLaundry();} catch(TeeShirtException tex) { //} catch(LingerieException lex) { //} catch(ClothingException cex) { //} 有catch块时要从小排到大如题, 否则小的(在继承树上靠下的)异常就永远无法被正常解决. 实在是不想处理异常duck如果自己实在是不想处理异常的话, 我们可以直接duck掉异常, 即表示自己会再throw掉此异常即可. 123public void foo() throws ReallyBadException { laundry.doLaundry();} ducking只是在踢皮球duck只是把Exception甩到上一级. 我们可以一级一级地将Exception向上甩吗, 但如果main()也把Exception给duck掉, 那编译器就直接死机了. 我们可以把Exception向上甩, 但是总有一天我们要catch它的. 异常处理的规则 catch与finally不能没有try; try与catch之间不能有程序 try一定要有catch或finally 只带有finally的try必须要声明异常 回到音乐播放程序第一版音乐播放程序12345678910111213141516171819202122232425262728293031323334import javax.sound.midi.*;public class MusicTest1 { public static void main(String[] args) { MusicTest1 test1 = new MusicTest1(); test1.play(); } public void play() { try { Sequencer player = MidiSystem.getSequencer(); player.open(); Sequence seq = new Sequence(Sequence.PPQ, 4); Track track = seq.createTrack(); ShortMessage a = new ShortMessage(); a.setMessage(144, 1, 44, 100); MidiEvent noteOn = new MidiEvent(a, 1); track.add(noteOn); ShortMessage b = new ShortMessage(); b.setMessage(128, 1, 44, 100); MidiEvent noteOff = new MidiEvent(b, 16); track.add(noteOff); player.start(); } catch (Exception ex) { ex.printStackTrace(); } }} 第二版音乐播放程序这一版的音乐播放程序可以通过在控制台输入数字来改变播放的声音. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import javax.sound.midi.*;public class MusicTest2 { public static void main(String[] args) { MusicTest2 test2 = new MusicTest2(); if (args.length &lt; 2) { System.out.println(&quot;Do not forget the instrument and note args.&quot;); } else { int instrument = Integer.parseInt(args[0]); int note = Integer.parseInt(args[1]); test2.play(instrument, note); } } public void play(int instrument, int note) { try { Sequencer player = MidiSystem.getSequencer(); player.open(); Sequence seq = new Sequence(Sequence.PPQ, 4); Track track = seq.createTrack(); MidiEvent event = null; ShortMessage first = new ShortMessage(); first.setMessage(192, 1, instrument, 0); MidiEvent changeInstrument = new MidiEvent(first, 1); track.add(changeInstrument); ShortMessage a = new ShortMessage(); a.setMessage(144, 1, note, 100); MidiEvent noteOn = new MidiEvent(a, 1); track.add(noteOn); ShortMessage b = new ShortMessage(); b.setMessage(128, 1, note, 100); MidiEvent noteOff = new MidiEvent(b, 16); track.add(noteOff); player.setSequence(seq); player.start(); } catch (Exception ex) { ex.printStackTrace(); } }} 图形用户接口window一切都要从window开始说起. JFrame是一个代表屏幕上window的对象. 我们可以把button、checkbox和text字段等接口放在window上面. 标准的menu也可以放在上面, 并且能够放置最小化、最大化以及关闭等图标. 在我们创建出JFrame后, 我们就可以把组件(widget)放在上面了. 有很多的Swing组件可供选择, 绝大多数都简单易懂. 123456789// 创建frameJFrame frame = new JFrame();// 创建widget(组件)JButton button = new JButton(&quot;click me&quot;);// 将widget添加到frame上frame.getContentPane().add(button);// 显示出来frame.setSize(300, 300);frame.setVisible(true); 年轻人的第一个GUI123456789101112131415161718192021import javax.swing.*;public class SimpleGUI { public static void main(String[] args) { // 创建frame和button JFrame frame = new JFrame(); JButton button = new JButton(&quot;click me&quot;); // 在window关闭后自动关闭程序 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 将button加到frame的pane上 frame.getContentPane().add(button); // 设定frame的大小 frame.setSize(300, 300); // 显示frame frame.setVisible(true); }} 用户接口事件如何让按钮在用户按下时执行特定的工作? 我们需要两个东西: 被按下时要执行的方法 检测按钮被按下的方法 取得用户的事件假设我们想要把按钮上的文字在用户按下按钮时从”click me”变成”I’ve been clicked”. 我们需要先编写改变按钮文字的方法: 123public void changeIt() { button.setText(&quot;I've been clicked&quot;);} 但是, 在我们写好了这个方法之后, 我们又应该在什么时候执行这个方法呢? 我们怎么知道按钮被按下去了呢? 在Java中, 取得与处理用户操作事件的过程称为even-handling. 如果用户按下了按钮, 就会产生事件. 这是一个关于用户想要采用启动按钮功能的事件. 事件的监听如果想要知道按钮的事件, 就会监听事件的接口. 监听接口是介于监听(我们)与事件源(按钮)之间的桥梁. Swing的GUI组件是事件的来源. 以Java的术语来说, 事件来源是个可以将用户操作(点击鼠标、按键以及关闭窗口等)转换成事件的对象. 这些事件源会在用户做出相关动作时(按下按钮)产生事件对象. 程序在大多数情况下是事件的接受方而不是创建方. 也就是说, 我们会花比较多的事件当监听者而不是事件来源. 每个事件类型都有相对应的监听者接口. 如果没有, 就要自己写一个. 某些接口不只有一个方法, 因为事件本身就有不同的形态. 监听和事件源如何沟通监听如果类想要知道按钮的ActionEvent, 我们就需要实现ActionListener这个接口. 按钮需要知道我们关注的部分, 因此要通过调用addActionListener(this)并传入ActionListener的引用(此例中就是我们自己的这个程序, 所有传了一个this进去)来向按钮注册. 按钮会在该事件发生时调用该接口上的方法. 而作为一个ActionListener, 编译器会确保你实现此接口的actionPerformed(). 事件源按钮是ActionEvent的来源, 因此它必须要知道有哪些对象是需要事件通知的. 此按钮有个addActionListener方法可以提供对事件有兴趣的对象(listener)一种表达此兴趣的方法. 当按钮的addActionListener()方法被调用时(因为某个listener的调用), 它的参数会被按钮存到清单中. 当用户按下按钮时, 按钮会通过调用清单上每个监听的actionPerformed()来启动事件. 取得按钮的ActionEvent123456789101112131415161718192021222324252627import javax.swing.*;import java.awt.event.*;public class SimpleGUI implements ActionListener { JButton button; public static void main(String[] args) { SimpleGUI gui = new SimpleGUI(); gui.go(); } public void go() { JFrame frame = new JFrame(); button = new JButton(&quot;click me&quot;); button.addActionListener(this); frame.getContentPane().add(button); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 300); frame.setVisible(true); } public void actionPerformed(ActionEvent event) { button.setText(&quot;I've been clicked!&quot;); }} 回到图形上在GUI上面加东西的三种方法 在frame上放置widget 在widget上绘制2D图形 在widget上绘制JPEG图 年轻人的第一个绘图组件如果我们要在屏幕放上自己的图形, 最好的方式是自己创建出有绘图功能的widget. 这一需求可以通过创建JPanel的子类并覆盖掉paintComponent()这个方法. 所有绘图程序代码都在paintComponent()里面. 当你的panel所处的frame显示的时候, paintComponent()就会被调用. 如果用户缩小window或选择最小化, Java虚拟机也会知道调用它来重新绘制. 需要强调的是, 我们自己是不会调用这个方法的. 它的参数是个与实际屏幕有关的Graphics对象. 这个对象无法被取得, 它必须由系统来交给我们. 但是, 我们还是可以调用reapint()来要求系统重新绘制显示装置, 然后才会产生paintComponent()的调用. 123456789import javax.swing.*;import java.awt.*;public class SimpleGUI extends JPanel { // 创建JPanel子类 public void paintComponent(Graphics g) { // 系统调用Graphics类 g.setColor(Color.orange); g.fillRect(20, 50, 100, 100); }} 在paintComponent()中可以做的事情Swing序列化和文件的输入/输出储存状态的选择有很多种. 我们暂且只讨论两种: 序列化(serialization): 在数据只被自己写的Java程序使用时使用 纯文本文件: 在数据需要被其他程序引用时使用 此外还有种种进行输入/输出的方法, 但它们的基本原理都是类似的: 把数据写到某处——这个某处可以是磁盘上的文件, 也可以是来自网络上的串流. 读取数据的方向则刚好相反. 储存状态假设有个程序, 是个幻想冒险游戏. 在游戏运行的过程中, 游戏的任务会累计经验值、宝物和体力等. 我们需要一种方法来保存人物的状态, 并在重新开启时能够将状态回复到上次存储时的原状. 有两种方法可供选择: 序列化创建一个文件, 让序列化的三种对象写到此文件中.这个文件在以文本文件形式阅读时是无意义的. 序列化的文件难以阅读, 但它比纯文本文件更容易程序恢复原有的状态, 且更为安全, 因为一般人根本不会知道要如何修改数据. 写入纯文本文件创建文件, 写入三行文字, 每个人物一行, 以逗号来分开属性. 储存对象将序列化对象写入文件下面是将对象序列化(存储)的方法步骤. 首先, 创建出FileOutputStream: 1FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;); // 如果文件不存在, 它会自动被创建出来 其次, 创建ObjectOutputStream: 1ObjectOutputStream os = new ObjectOutputStream(fileStream); // 允许我们写入对象, 但无法直接连接文件, 所以需要参数的指引 然后, 写入对象: 1234// 将变量所引用的对象序列化并写入MyGame.ser这个文件os.writeObject(characterOne);os.writeObject(characterTwo);os.writeObject(characterThree); 最后, 关闭ObjectOutputStream: 1os.close(); 数据, 在串流中移动Java的输入/输出API带有连接类型的串流, 它代表来源于目的地之间的连接, 连接串流将串流于其他串流连接起来. 一般来说, 串流要两两连接才能做出有意义的事情——其中一个表示连接, 另一个则是要被调用方法的. 这要归功于良好的面向对象设计——每个类只需要做好一件事就好了. 网络与线程聊天程序概述 客户端必须要认识服务器 服务器必须要认识所有的客户端 工作方式: 客户端连接到服务器 服务器建立连接并把客户端加到来宾清单中 另外一个用户连接上来 用户A送出信息到聊天服务器上 服务器将信息送给所有的来宾 网络Socket连接要让客户端能够工作, 有三件事必须先学: 如何建立客户端与服务器之间的初始链接 如何传送信息到服务器 如何接受来自服务器的信息 这里有很多的底层工作问题, 但是Java API的网络功能包(java.net)还是提供了解决问题的方案. 但还是推荐深入研究一下TCP/IP协议, 否则出错了也不知道怎么错的. 此外, 有个潜藏在简单版聊天客户程序中的问题是我们从未遇见过的: 同时做两件事情. 我们在后面会详细论述. 建立Socket连接要连接到其他的机器上, 我们需要Socket连接. Socket是个代表两台机器之间网络连接的对象(java.net.Socket). 要创建Socket连接, 我们需要知道两样关于服务器的信息: 它在哪里以及用哪个端口来收发数据, 即IP地址与端口号. 1Socket chatSocket = new Socket(&quot;196.164.1.103&quot;, 5000); Socket连接的建立代表两台机器之间存有对方的信息, 包括网络地址和TCP的端口号. 读取socket我们使用串流来实现Socket沟通, 与上一章所用的串流相同. Java的好处就在于大部分的输入/输出并不在乎链接串流的上游实际是什么. 因此, 我们可以使用BufferedReader, 不管串流来自文件还是Socket. 建立对服务器的Socket连接1Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000); 建立连接到Socket上低层输入串流的InputStreamReader1InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream()); 建立BufferedReader来读取12BufferedReader reader = new BufferedReader(stream);String message = reader.readLine(); PrintWriter我们除了BufferedReader外, 还有一个选择, 即使用PrintWriter. 由于我们每次写入都只是写入一个字符串, 所有使用PrintWriter是最标准的做法. 123456Socket chatSocket = new Socket(&quot;127.0.0.1&quot;, 5000);PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());writer.println(&quot;message to send&quot;);writer.print(&quot;another message&quot;); DailyAdviceClient客户端程序这个程序会建立Socket, 通过其他串流来制作BufferedReader, 并从服务器应用程序(用56747端口服务的任何程序)上读取一行信息. 12345678910111213141516171819202122232425import java.io.*;import java.net.*;public class DailyAdviceClient { public void go() { try { Socket s = new Socket(&quot;127.0.0.1&quot;, 56747); InputStreamReader streamReader = new InputStreamReader(s.getInputStream()); BufferedReader reader = new BufferedReader(streamReader); String advice = reader.readLine(); System.out.println(&quot;Today you should: &quot; + advice); reader.close(); } catch (IOException ex) { ex.printStackTrace(); } } public static void main(String[] args) { DailyAdviceClient client = new DailyAdviceClient(); client.go(); }} 注意: 如果我们直接运行这个程序的话, 它一定会报错. 不是端口的问题(除非我们的56747端口真的被占用了), 是服务器代码没写的问题. 我们需要先运行服务器的代码, 然后再运行这个代码. 编写简单的服务器程序编写服务器应用程序要用到哪些东西呢? 一对Socket即可. 它们是一个会等待用户请求(当用户创建Socket时)的ServerSocket以及与用户通信用的Socket. 服务器应用程序对特定端口创建出ServerSocket1ServerSocket serverSock = new ServerSocket(56747); 客户端对服务器应用程序建立Socket连接1Socket sock = new Socket(&quot;196.165.1.103&quot;, 56747); 服务器创建出与客户端通信的新Socket1Socket sock = serverSock accept(); accept()方法会在等待用户的Socket连接时闲置着. 当用户连上来时, 此方法会返回一个Socket(在不同的端口上)以便与客户端通信. Socket与ServerSocket的端口不相同, 因此ServerSocket可以空出来等待其他的用户. DailyAdviceClient客户端程序 2.0这个程序吹创建ServerSocket并等待客户端的请求. 当它受到客户端请求时, 服务器会建立于客户端的Socket连接. 服务器接着会建立PrintWriter来送出信息给客户端. 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;import java.net.*;public class DailyAdviceServer { // 锦囊妙计 String[] adviceList = {&quot;Advice 1&quot;, &quot;Advice 2&quot;, &quot;Advice 3&quot;, &quot;Advice 4&quot;}; public void go() { try { // ServerSocket会持续监听客户端在56747端口上的要求 ServerSocket serverSocket = new ServerSocket(56747); // 服务器开始五西安等待客户端的请求 while (true) { // 该方法会停下来等待要求达到之后才会继续 Socket sock = serverSocket.accept(); //使用Socket连接发送消息, 并在送出后关闭连接 PrintWriter writer = new PrintWriter(sock.getOutputStream()); String advice = getAdvice(); writer.println(advice); writer.close(); System.out.println(advice); } } catch (IOException ex) { ex.printStackTrace(); } } private String getAdvice() { int random = (int) (Math.random() * adviceList.length); return adviceList[random]; } public static void main(String[] args) { DailyAdviceServer server = new DailyAdviceServer(); server.go(); }} 编写聊天客户端程序第一版: 只能发送的版本依旧没写服务器代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.*;import java.net.*;import javax.swing.*;import java.awt.*;import java.awt.event.*;public class SimpleChatClientA { JTextField outgoing; PrintWriter writer; Socket sock; public void go() { JFrame frame = new JFrame(&quot;Ludicrously Simple Chat Client&quot;); JPanel mainPanel = new JPanel(); outgoing = new JTextField(20); JButton sendButton = new JButton(&quot;Send&quot;); sendButton.addActionListener(new SendButtonListener()); mainPanel.add(outgoing); mainPanel.add(sendButton); frame.getContentPane().add(BorderLayout.CENTER, mainPanel); setUpNetworking(); frame.setSize(400, 500); frame.setVisible(true); } private void setUpNetworking() { try { sock = new Socket(&quot;127.0.0.1&quot;, 56747); writer = new PrintWriter(sock.getOutputStream()); System.out.println(&quot;networking established&quot;); } catch (IOException ex) { ex.printStackTrace(); } } public class SendButtonListener implements ActionListener { public void actionPerformed(ActionEvent ev) { try { writer.println(outgoing.getText()); writer.flush(); } catch (Exception ex) { ex.printStackTrace(); } outgoing.setText(&quot;&quot;); outgoing.requestFocus(); } } public static void main(String[] args) { new SimpleChatClientA().go(); }} 第二版: 可发送和接收版该版本的程序需要解决一个问题: 如何从服务器中取得信息? 这是个比较容易的问题: 当我们设定网络的同时也把输入串流建立好, 然后使用readLine()读取信息. 问题在于: 何时从服务器取得信息? 最好的方法当然是在信息被送到服务器上的时候就把它读回来. 但是, 这样的程序应该怎么写? 需要有一个循环来等待服务器的消息, 但是这个程序又该放在哪里? 线程与ThreadJava有多个线程, 但是只有一个Thread类. 它只是java.lang这个包中的一个类, Thread对象才代表线程, 当我们需要启动新的线程时需要建立一个新的Thread实例. 一个以上的执行空间意味着什么?当有一个以上的执行空间时, 看起来会像是有好几件事情同时发生. 但是实际上, 只有真正的多处理器系统才能同时执行好几件事, 但使用Java的线程可以让它们看起来好像在同时执行. 也就是说, 执行动作可以在执行空间间非常快速地来回交换, 因此产生了它们在同时执行的错觉. 线程要记录的一项事物就是目前线程执行空间做到哪里了. 12345678910// Java虚拟机调用main()public static void main(String[] args) { // main()启动新的线程. 新的线程启动期间, main的线程会暂停执行 Runnable r = new MyThreadJob(); Thread t = new Thread(r); t.start(); Dog d = new Dog(); // Java虚拟机会在线程与原来的主线程间切换直到两者都完成为止} 如何启动新的线程12345678// 建立Runnable对象(线程的任务)Runnable threadJob = new MyRunnable();// 建立Thread对象并赋值Runnalbe(对象)Thread myThread = new Thread(threadJob);// 启动ThreadmyThread.start(); Thread的任务每个Thread需要一个任务来执行, 一个可以放在执行空间的任务. 任务是线程在启动时去执行的工作, 是新线程空间上的第一个方法. 它一定要长成这个样子: 123public void run() { // 会被新线程执行的代码} 线程怎么会直到要先放上哪个方法? 因为Runnable定义了一个协约. 因为Runnable定义了一个协约. 它自己是一个接口, 线程的任务可以被定义在任何实现Runnable的类上. 线程只在乎传入给Thread的构造函数的参数是否为实现Runnable的类. 实现Runnable接口12345678910111213141516171819202122public class MyRunnable implements Runnable { public void run() { go(); } public void go() { doMore(); } public void doMore() { System.out.println(&quot;top o' the stack&quot;); }}class ThreadTester { public static void main(String[] args) { Runnable threadJob = new MyRunnable(); Thread myThread = new Thread(threadJob); myThread.start(); System.out.println(&quot;back in main&quot;); }} 线程的状态线程有三种状态, 即新建、可执行和执行中. 当线程进入可执行状态, 它就会在可执行与执行中两种状态中来回转变. 可执行/执行中循环普通线程会在可执行与执行中两个状态中来回交替. 因为Java虚拟机的线程调度会把线程挑出来运行又把它踢回去让其他的线程有执行机会. 线程有可能会暂时被挡住调度器(scheduler)会因为某些原因暂停执行一个线程. 线程调度器线程调度器会决定哪个线程从等待状况中被挑出来运行, 以及何时把哪个线程送回等待被执行的状态. 但是, 不同虚拟机上的调度器有着不同的工作逻辑, 故我们的程序不能依靠调度的特定行为来保持执行的正确性. 1234567891011121314151617181920212223public class MRunnable implements Runnable{ public void run() { go(); } public void go() { doMore(); } public void doMore() { System.out.println(&quot;top of the stack&quot;); }}class ThreadTestDrive { public static void main(String[] args) { Runnable threadJob = new MRunnable(); Thread myThread = new Thread(threadJob); myThread.start(); System.out.println(&quot;back in main&quot;); }} 让线程小睡一下确保线程能够有机会执行的最好方式是让它们周期性地去睡一下: 1Thread.sleep(2000); 但是在这个方法有可能会抛出InterruptedException异常, 所有对它的调用都必须包含在try/catch块中. 因此, 真正的程序代码如下: 12345try { Thread.sleep(2000);} catch (InterruptedException ex) { ex.printStackTrace();} (实际上, 我们通常不必刻意使用sleep()来保证其他的线程会被执行. 这是一个很复杂的问题, 详见一些专门论述Java多线程的书籍.) 建立与启动两个线程线程可以有名字. 下面的例子中有两个线程. 它们都执行相同的工作: 在循环中列出线程的名字. 123456789101112131415161718public class RunThreads implements Runnable{ public static void main(String[] args) { RunThreads runner = new RunThreads(); Thread alpha = new Thread(runner); Thread beta = new Thread(runner); alpha.setName(&quot;Alpha Thread&quot;); beta.setName(&quot;Beta Thread&quot;); alpha.start(); beta.start(); } public void run() { for (int i = 0; i &lt; 25; i++) { String threadName = Thread.currentThread().getName(); System.out.println(threadName + &quot; is running .&quot;); } }} 多线程的并发性问题并发性会引发竞争状态, 进而引发数据的损毁. 这一切都来自于一种完全可能的状况, 即两个或以上的线程存取单一对象的数据. 也就是说, 两个不同执行空间上的方法都在堆上对同一个对象执行getter或setter. 为了解决这个问题, 我们需要设计一把锁, 使得每个方法在同时只能被一个线程调用. 这把锁就是synchronized. synchronized关键词代表线程需要一把钥匙来存取被同步化(synchronized)过的线程. 1private synchronized void makeWithdrawal(int amount) {...} 同步化的死锁问题如同步化的定义所述, 它会确保在需要的方法执行完毕前不执行任何其他操作. 问题来了: 如果那个”需要的方法”的执行需要某个被同步化确保不执行的内容怎么办? 这就完蛋了. 程序会永远地等下去. 这就是所谓的死锁. Java没有处理死锁的机制, 想要尽可能地避免死锁只能依赖良好的多线程程序设计. 推荐阅读O’Relly出版的Java Thread, 上面对包括死锁在内的许多有关Java多线程的知识进行了清晰的论述. 集合与泛型","link":"/2022/06/12/java/"},{"title":"算法入门","text":"简介算法与数据结构的重要性课程定位与目标人群算法与数据结构无处不在掌握算法与数据结构的基础知识, 对于编写性能优良、可读性强的工程代码和理解编程语言信息库函数的源代码都很有帮助. 什么是算法与数据结构算法是解决问题的方法学习算法的目的之一是高效地解决问题. 解决这些问题的方式可能是直接使用计算机科学家发明出来的算法与数据结构, 可能是偶尔的灵光一现, 也有可能是对前人思想的改进. 总而言之, 我们需要有一定的只是储备和解决问题的经验. 数据结构是解决问题的过程中使用的容器容器是存放数据的地方, 同时容器还提供了一定的处理数据的能力, 协助我们高效地完成任务. 编程领域中的数据结构们都是一些有些抽象的概念, 但是这些数据结构都我们的编程过程中发挥了巨大的现实作用. 我们要介绍一个概念: 数据结构是缓存. 数据结构是缓存在解决问题的时候, 我们通常不是一下子把数据处理完, 而是需要先将它们放在一个容器里, 等到一定的时刻再把它们拿出来. 使用数据结构是一种”空间换时间”思想的体现, 如果我们在恰当的时刻使用了合适的数据结构, 那我们处理数据的效率就能够大幅度提升. 以下是一些常用的数据结构及其应用场所: 数据结构 应用场景 栈 符合「后进先出」的规律 队列 符合「先进先出」的规律 哈希表(散列表) 实现「快速存取」数据的功能 二分搜索树(红黑树、B 树系列) 维护了一组数据的顺序性, 得到一个数据的上下界 并查集 用于处理不相交集合的「动态」连接问题 优先队列 有「动态」添加、删除数据且需要获得最值的场景 字典树(Tier) 用于保存和统计大量的字符串和相关的信息 线段树 处理数组的区间信息的汇总（求和、最值等）、单点更新、区间更新问题 树状数组 处理数组的前缀和、单点更新、区间更新问题 我们创建这么多数据结构的原因为: 没有完美的数据结构或算法 没有完美的数据结构或算法任何算法都是一种交换. 我们没有办法得到所有想要的东西. u低于算法与数据结构来说, 时间性能和空间消耗通常来说是不可能同时最优的: 一个算法和数据结构对于一个任务来说是优点, 但放在另一个场景下就可能是缺点. 在设计算法时, 我们或是用时间换空间, 或是用空间换时间, 或是综合考虑两者, 设计一个折中方案. 时间复杂度与空间复杂度现行评估算法性能好坏的方法有两个, 即执行时间和内存消耗. 在服务端, 我们更关注的是执行时间, 因为用户一般不会关心程序在服务器端用了多少内存. 在LeetCode提交代码的时候, 会看到提交记录中显示一共有多少测试用例, 又通过了多少测试用例. 这种评估方法被称作事后评估法. 这是一种不是很准确的方法, 因为其测试结果受到输入数据的规模、编程语言、执行时系统状况等多方面影响. 我们在现实中更多采用的是事前评估法, 即大O复杂度表示法. 与此相关的两个概念是”时间复杂度”和”空间复杂度”. 我们在此暂不给出详细的是时间复杂度和空间复杂度的定义. 动态看待时间复杂度和空间复杂度时间复杂度和空间复杂度的前面还有一个词——渐近. 它表示算法在输入数据的规模成倍增长的时候, 相应的时间消耗多增长了多少. 例如Gauss计算从1到100的和, 如果真的从1加到最后一个, 那么从1加到100和从1加到1000000000所需的时间一定是不一样的; 但如果我们使用等差数列求和公式计算, 那么无论n多大, 计算资源的消耗都不会有太大的变动. 1234567891011121314151617// 这个算法执行的操作数与输入规模n线性相关.public int toSum1(int n) { int sum = 0; for (int i = 1; i &lt;= n ; i++) { sum += i; } return sum;}// 这个算法执行的操作数与n无关public int toSum2(int n) { int sum = 0; sum = (1 + n) * n / 2; return sum;} 这个例子较为清晰地展示了渐近时间复杂度的含义, 即不关注一两个测试用例的结果, 而是重视输入规模发生成倍增长、数目扩大到很大时, 相应的时间和空间的消耗增加了多少. 我们在上面的代码中并没有具体说”常数次”究竟执行了多少次, 因为这并不重要. 由于几乎任何东西都有可能影响到程序的执行时间, 故计算出准确的函数执行步数没有太大必要; 此外, 复杂的计算也不利于工程师进行交流. 时间复杂度的计算只需要得出一个大概的结果. 估算的意义是: 便于不同的算法进行比较; 有利于程序员在编码时进行自我检查和优化. 计算时间复杂度和空间复杂度需要强调的是, 时间复杂度的计算(估算)只有在输入规模非常大的时候才有意义. 常见的时间复杂度计算规则常数加法系数看作0一段程序必须要做的操作(常数次操作)不计入复杂度的计算. 一般而言, 常数次操作不会是造成程序性能瓶颈的原因. 对于一个多项式, 只保留最高次幂的项, 并将乘法系数简化为1常见结论: 一次遍历, 里面不再有循环的操作, 时间复杂度为$O(N)$. 也就是说, 我们将输入数据里所有的元素看一遍, 就可以得到结果. 这就是所谓的具有线性复杂度的算法. 双重循环, 内外层都与输入规模相关的时候, 时间复杂度是$O(N^2)$. 需要注意的是, 有些算法名义上是双重循环, 但事实上, 程序只遍历了数组一次或若干次, 故此类算法的时间复杂度仍然是$O(N)$. 对数或者含有对数乘法银子的项, 对数底都看作2对数级别的时间复杂度, 常见且典型的算法是二分算法, 时间复杂度的表达式为$O(\\log N)$ 绝大多数情况下关注最坏情况如果一个程序最坏的情况都是可被接受的, 那么其最好的情况就一定可以被接受. 这就是所谓的”做最好的准备, 做最坏的打算”. 当然, 凡是都有例外: 如果一个程序, 我们采用了一些手段, 导致最坏情况出现的概率大大降低, 那么我们会约定俗称地将时间复杂度定义成”一般情况”. 时间复杂度的数学定义在对时间复杂度有了一个感性的认识后, 我们再来看《算法导论》中对时间复杂度的数学定义: $O(G(n))=f(n): \\exists c, n_0 &gt; 0, \\forall n \\geqslant n_0, 0 \\leqslant f(n) \\leqslant cg(n)$. $O$表示的是一个函数的渐进上界. 说上界, 是因为我们要考虑最坏的情况. 此外, $O$只是一个符号, 不代表任何具体的表达式. 二分查找二分查找的基本思想: 减而治之何为”减而治之”?略. 二分查找算法的应用范围在有序数组中查找一个数(二分下标)在整数范围内查找一个整数(二分答案)二分查找算法的两种思路 在循环体中查找元素(本节介绍) 在循环体中排除目标元素一定不存在的区间(下一节介绍) 二分查找的最基本问题一个最基本的二分查找问题就是在有序数组中查找目标元素下表的问题. 如果目标存在, 则返回目标下表; 如果不存在, 则返回-1. 我们可以假设数组中的元素不重复. 由于数组是有序且升序的数组, 所以我们在进行二分查找时, 可先看位于数组中间的那个元素的值: 如果中间的元素正好等于目标元素, 则直接返回即可; 如果中间元素不等于目标元素, 则根据大小关系在两侧进行查找. 我们来看一下示例代码: 1234567891011121314151617181920212223public class Solution { public int search(int[] nums, int target) { int len = nums.length; int left = 0; int right = len - 1; // 目标元素可能存在在区间 [left, right] while (left &lt;= right) { // 推荐的写法是 int mid = left + (right - left) / 2; int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { // 目标元素可能存在在区间 [mid + 1, right] left = mid + 1; } else { // 目标元素可能存在在区间 [left, mid - 1] right = mid - 1; } } return -1; }} 优化后的代码是这样的: 1234567891011121314151617public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left + 1) / 2; if (nums[mid] &gt; target) { right = mid - 1; } else { left = mid; } } if (nums[left] == target) { return left; } return -1;} 这种做法能够做到”真正的二分”, 即while循环中只需要做一次判断. 还有一道与这个题类似的题, 也可以做一做. 我的答案如下: 123456789101112131415161718public class Solution extends GuessGame { public int guessNumber(int n) { int left = 1; int right = n; int myNum = 0; while (guess(myNum) != 0) { myNum = right + (left - right) / 2; if (guess(myNum) == 1) { left = myNum + 1; } else { right = myNum - 1; } } return myNum; }} 同样的, 改进后如下: 123456789101112131415161718public class Solution extends GuessGame { public int guessNumber(int n) { int left = 1; int right = n; int mid = 1; while (left &lt; right) { mid = left + (right - left + 1) / 2; if (guess(mid) &gt;= 0) { left = mid; } else { right = mid - 1; } } return left; }} 二分查找的典型问题(一): 二分下标所谓二分下标, 指的是在一个有序数组(该条件可适当放宽)中查找目标元素的下表. 我们来看两个例子. 搜索插入位置该题给定了一个排序数组和目标值, 要求在数组中找到目标值, 并返回其索引; 如果目标值不存在于数组中, 则返回它将会被顺序插入的位置. 我自己的提交如下: 12345678910111213141516171819202122class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left + 1) / 2; if (nums[mid] &gt; target) { right = mid - 1; } else { left = mid; } } if (nums[left] &gt;= target) { return left; } else { return left+1; } }} 在排序数组中查找元素的第一个和最后一个位置这道题要求我们在一个有序的数组中找到和目标元素相等的元素的第一个位置和最后一个位置. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { public int[] searchRange(int[] arr, int target) { int arrLength = arr.length; if (arrLength == 0) { return new int[]{-1, -1}; } int firstPosition = firstPosition(arr, target); if (firstPosition == -1) { return new int[]{-1, -1}; } int lastPosition = lastPositon(arr, target); return new int[]{firstPosition, lastPosition}; } public int firstPosition(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt; right) { int mid = left + (right - left) / 2; if (arr[mid] &lt; target) { left = mid + 1; } else if (arr[mid] == target) { right = mid; } else { right = mid - 1; } } if (arr[left] == target) { return left; } else { return -1; } } public int lastPositon(int[] arr, int target) { int left = 0; int right = arr.length - 1; while (left &lt; right) { int mid = left + (right - left + 1) / 2; if (arr[mid] &gt; target) { right = mid - 1; } else { left = mid; } } return left; }} 这里需要强调的是什么时候使用mid = left + (right - left) / 2(即向下取整), 什么时候又使用mid = left + (right - left + 1) / 2(即向上取整). 有如下结论: 向下取整: 配合left = mid + 1, right = mid使用 向上取整: 配合left = mid, right = mid - 1使用 练习一12345678910111213141516171819class Solution { public int findMin(int[] nums) { int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) { left = mid + 1; } else if (nums[mid] &lt; nums[right]) { right = mid; } } return nums[right]; }} 与其他二分法程序不同, 这里虽然使用了向下取整, 但是最后返回的是right. 练习二123456789101112131415161718192021class Solution { public int findMin(int[] nums) { int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) { left = mid + 1; } else if (nums[mid] &lt; nums[right]) { right = mid; } else { right = right - 1; } } return nums[left]; }} 本题最大的特点在于它是一个有可能连续出现相同元素的旋转数组, 故可能会出现取值范围两端元素相等的情况. 如不做调整, 就会在数组两端元素相等、两端元素为数组元素最大元素且数组中间值也为最大数组最大元素时出现返回值为数组最大值的情况. 为了避免这种情况的发生, 我们可以手动去除掉最右侧的元素(反正它也是重复的). 这样就让数组不能满足上述的三个条件, 变为普通的数组. 练习三12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public boolean search(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left) / 2; if (nums[mid] == target || nums[left] == target || nums[right] == target) { return true; } // 如果是左侧升序 if (nums[left] &lt; nums[mid]) { if (nums[mid] &gt; target) { if (nums[left] &lt; target) { right = mid - 1; } else { left = mid + 1; } } else { left = mid + 1; } // 如果左侧断序 } else if (nums[left] &gt; nums[mid]) { if (nums[mid] &gt; target) { right = mid - 1; } else if (nums[left] &lt; target) { right = mid - 1; } else { left = mid + 1; } // 如果两端相等 } else { left = left + 1; } } if (nums[left] == target) { return true; } return false; }} 练习四123456789101112131415161718public class Solution extends VersionControl { public int firstBadVersion(int n) { int left = 1; int right = n; int mid = 0; while (left &lt; right) { mid = left + (right - left) / 2; if (isBadVersion(mid)) { right = mid; } else { left = mid + 1; } } return left; }} 练习五: 山脉数组的峰顶索引12345678910111213141516171819202122232425class Solution { public int peakIndexInMountainArray(int[] arr) { int left = 0; int right = arr.length - 1; int mid = 0; while (left &lt; right) { mid = left + (right - left + 1) / 2; if (arr[left] &lt; arr[mid]) { if (arr[mid] &gt; arr[mid-1]) { left = mid; } else { right = mid - 1; } } else if (arr[left] &gt; arr[mid]) { right = mid - 1; } else { left = left + 1; } } return left; }} 练习六: 山脉数组中查找目标值12345678910111213141516171819202122232425262728293031323334353637class Solution { public int findInMountainArray(int target, MountainArray mountainArr) { int l = 0, r = mountainArr.length() - 1; while (l &lt; r) { int mid = (l + r) / 2; if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1)) { l = mid + 1; } else { r = mid; } } int peak = l; int index = binarySearch(mountainArr, target, 0, peak, true); if (index != -1) { return index; } return binarySearch(mountainArr, target, peak + 1, mountainArr.length() - 1, false); } public int binarySearch(MountainArray mountainArr, int target, int l, int r, boolean flag) { if (!flag) { target *= -1; } while (l &lt;= r) { int mid = (l + r) / 2; int cur = mountainArr.get(mid) * (flag ? 1 : -1); if (cur == target) { return mid; } else if (cur &lt; target) { l = mid + 1; } else { r = mid - 1; } } return -1; }} 这道题的关键在于: 找山峰, 然后现在左侧查找目标值, 再在右侧寻找目标值. 练习七: 寻找两个正序数组的中位数二分查找的典型问题(二): 答案二分例题一: $x$的平方根使用二分法求平方根的方法如下: 123456789101112131415class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l &lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid &lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; }} 还有一种使用Newton迭代解决求根问题的方法. 由于我自己还没有参悟透, 所以就不厚脸皮写在这里了. 各位有兴趣可以去这里看一下. 基础排序算法选择排序排序原理选择排序的原理为: 选取未排定部分的最小元素, 然后将它交换到未排定部分的第一个位置. 代码实现1234567891011121314151617181920212223242526public int[] sortArray(int[] arr) { int length = arr.length; int minIndex = 0; int min = 0; int cache = 0; for (int i = 0; i &lt; length; i++) { minIndex = i; min = arr[i]; for (int j = i + 1; j &lt; length; j++) { if (arr[j] &lt; min) { minIndex = j; min = arr[j]; } } if (minIndex != i) { cache = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = cache; } } return arr;} 接着这个机会介绍一些编程规范: 如果一个问题的输入为数组, 我们则需要将输入数组的长度变成一个变量, 因为输入数组的长度在后面编程的过程中很可能会多次用到. 建议将交换数组中两个元素的方法抽取成一个单独的方法, 因为它不构成程序的主要逻辑. 复杂度分析 时间复杂度: $O(N^2)$ 空间复杂度: $O(1)$ 选择排序的特点 交换的次数最少: 如果一个排序任务交换的成本很高, 则可以考虑使用选择排序 运行时间与输入无关: 每次扫描除了比上一次扫描少了一个元素以外并没有其他的区别. 选择排序没有记录更多的信息. 选择排序体现的算法思想 贪心算法: 每一轮外层循环, 我们只选出”未排定部分”最小的元素, 这种”局部最优, 则整体最优”的思想叫做贪心算法. 我们后面会专门说他. 减而治之: 该算法在二分查找中已经说过了, 不再赘述. 选择排序的优化选择排序是一个效率不高的算法, 因为其每次循环不为下次循环记录有用的信息. 有一种数据结构能够帮助我们在每次”未排定的部分”里快速选择出当前最小的元素. 这种数据结构就是堆, 而根据其衍生出的堆排序就是选择排序的优化排序算法. 我们将在后面介绍. 插入排序插入排序的基本思想插入排序的基本思想就是将一个元素插入一个有序数组中, 使之称为更长的有序数组. 具体来说, 我们要从第二个数开始, 一次将这个数插入到它之前已经排好序的部分, 这样每一次都能得到比上一次更长的有序数组, 直到数组整体有序. 将一个元素插入一个有序数组的两种方式以[6,5,3,1,8,7,2,4]为例进行讲解. 方法一: 逐个交换到前面合适的位置第一种插入的方式是: 1应该放置在下表为0的位置, 通过和它前面的那些元素依次交换, 最终1被交换到下标为0的位置, 然后前四个数字有序. 由于每一次数组里不同元素的交换, 需要进行3次赋值操作. 实际上, 有赋值操作次数更少的方法, 见方式二. 方法二: 暂存当前变量, 将钱买你的若干元素逐个向后赋值第2种插入的方式是: 先将2赋值给一个临时的变量, 然后将2之前比2严格大的所有元素从后向前依次赋值, 最后一定会空出1个位置出来, 这个空出来的位置就是2应该放置的位置, 我们将2赋值回去. 插入排序的代码实现第一版实现123456789101112131415161718public int[] changeSort1(int[] arr ) { int length = arr.length; int cache = 0; for (int i = 1; i &lt; length; i++) { for (int j = i; j &gt; 0; j--) { if (arr[j] &lt; arr[j-1]) { cache = arr[j]; arr[j] = arr[j-1]; arr[j-1] = cache; } else { break; } } } return arr;} 时间复杂度: $O(N^2)$ 空间复杂度: $O(1)$ 第二版实现1234567891011121314151617public int[] sortArray(int[] nums) { int len = nums.length; for (int i = 1; i &lt; len; i++) { int temp = nums[i]; int j = i; while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; temp) { nums[j] = nums[j - 1]; j--; } nums[j] = temp; } return nums;} 插入排序的总结插入排序与选择排序一样, 也是应用了减而治之的思想, 每一次插入的操作我们让”未排定的部分”减少一个元素, 让”已经排序的部分”增加一个元素. 与选择排序不同的是, 插入排序比较的方式是从后向前依次看到的元素与插入的元素进行比较, 这一步操作不用比较玩它前面所有的元素, 即插入排序内层循环可以提前终止, 这一点是插入排序非常重要的性质. 如果待排序的数组是”接近有序”的数组或元素个数较少的数组, 插入排序就可以很快完成排序内容. 举一个极端的例子: 对于一个已经排好序的数组, 插入排序只需执行一次就直接跳出, 不会继续浪费时间. 由此, 在最理想的情况下, 插入排序的最好时间复杂度可以降低到$O(N)$. 下面我们介绍”哨兵技巧”. 哨兵(Sentinel)在以上两版代码中, 在内层循环中都有j &gt; 0这个判断条件. 但是, 有一种插入排序的写法, 即先找到整个数组中最小的两个元素, 将它交换到数组的第一个位置, 后面的逻辑就可以去掉j &lt; 0. 这种技巧被称作”哨兵”, 即放置一个元素, 通常是边界位置, 起到”站岗放哨”的作用, 它能够帮助我们: 回避边界条件 减少分类讨论 循环常量使用循环常量这个概念可以帮助我们理解和证明算法的有效性. 有的算法虽然直观, 但是要证明算法的有效性, 就需要借助循环不变量这个概念. 此外, 循环不变量还能够帮助我们写出正确的代码, 特别是对于边界条件的讨论. 有的时候把循环不变量作为注释写在代码里, 可以帮助我们理清代码的逻辑, 也有助于他人理解我们的代码. 什么是循环常量循环常量是一种语言描述, 描述了在循环过程中, 我们所设计的变量保持不变的性质. 其中: “量”: 表示了一个或者若干个变量; “循环”+”常”: 在若干个变量在循环的过程中, 保持了它们各自的性质. 便利店过程分为三个阶段: 初始时、循环过程中以及结束时. 考虑清楚这三个阶段的逻辑, 能够让我们更清楚变量的边界在哪里. 选择排序的循环常量语言描述: 区间$[0,i)$有序, 即$i$有序, 即$i$之间的元素有序, 并且它们中的元素都放在了最终应该在的位置. 我们考察选择排序的三个阶段: 初始时: $i=0$区间$[0,i)$为空; 循环过程中: 我们将$i$到数组末尾的区间$[i, len-1]$的最小元素交换到$i$的位置, 然后$i$自加$1$, 如此一来, 在下一轮循环开始之前, 区间$[0,i)$有序的性质仍然成立; 结束时: $i=len$, 区间$[0,len)$有序, 即区间$[0,len-1]$有序, 算法的有效性得证. 高级排序算法归并排序 归并排序是我们学习的第一个时间复杂度为$O(N\\log N)$的排序算法; 归并排序应用到的分而治之的思想和递归方法的设计是十分经典且重要的; 归并排序是一种稳定的排序方法, Java语言中对象数组(非原始类型)的排序方法就是使用归并排序的升级版Timsort方法. 归并排序的方法的来源首先介绍一下什么是归并. 所谓归并, 指的就是将两个或两个以上的有序序列合并成一个新的有序序列的过程. 特别说明: 这里”序列”是指具有线性结构的序列, 可以是数组, 也可以是链表. 我们在这一章学习的归并排序是在数组中的归并; 两个数组分别有序是归并得以有效进行的前提. 归并的过程可以总结为: 首先将输入数组进行一次拷贝; 每一次我们都比较拷贝数组最开始的那个元素. 哪个元素小, 我们就把它赋值回归并以后的那个数组(原始输入数组)中; 直到拷贝数组中所有的元素都遍历完成(都赋值回去). 可以看到, 我们在数组归并的过程中我们需要使用额外的空间. 使用额外空间用于辅助数组归并的好处在于: 如果一个元素在数组靠后的位置, 它可以借助辅助数组一下子来到数组的前面, 正好解决了插入排序的痛点. 由于使用了额外空间, 故归并排序是非原地的排序算法. 归并排序的代码编写下面是归并排序的代码实现. 从之前的论述中可以看出, 归并排序是一次又一次, 对数组的不同子区间递归进行排序的过程. 故此, 我们需要设计一个私有函数, 表示我们针对这个数组的子区间进行排序. 为此我们将这个私有函数定义为mergeSort(int[] arr, int left, int right), 参数解释为: 输入数组int[] arr; 两个变量left和right: 表示针对这个数组的子区间$[left, right]$. 下面我们来看这个私有函数应该怎么写: 既然是递归函数, 首先要写递归终止条件, 否则函数就会执行个没完; 在数组被分到只剩下一个元素的时候就停止划分. 综上, 我们先写下一句: 123if (left == right) { return ;} 如果区间的长度严格大于1或者说至少有2个的时候, 需要这个区间从中间将他一分为二: 1int mid = left + (right - left) / 2; 先简单写出代码的框架. 由于写的是递归代码, 所以我们要定义清楚递归函数的语义和参数的意义. 12345678910111213141516171819202122public class MergeSort { public void sort(int[] arr) { int len = arr.length; mergeSort(arr, 0, len-1); } /** * 对数组nums在区间[left,right]内进行归并排序 * @param nums * @param left 左边界, 可以取到 * @param right 右边界, 可以取到 */ private void mergeSort(int[] nums, int left, int right) { if (left == right) { return ; } int mid = left + (right - left) / 2; mergeSort(nums, left, right); mergeSort(nums, mid + 1, right); mergeOfTwoArray(nums, left, mid, right); }} 这里将mid定义的是第一部分的最后一个元素的下表, 然后针对 数组[left.. mid]递归调用一次; 数组[mid+1.. right]递归调用一次. 下面就是归并的过程. 我们将归并的过程定义为: 对数组[left.. right]进行归并, 并且上面递归函数返回以后, mid是两个有序子区间中第一个子区间的末尾. 我们把这个信息要传到这个方法中. 归并过程的代码: 实现这个函数, 我们就得需要一个和区间长度相等的辅助数组, 为此, 我们需要新建一个数组, 因为需要将排序的结构需要直接体现在原始数组上. 因此, 我们采取的策略是先把这个子区间里所有的元素复制出来, 通过比较以后, 再赋值回去. 此时, 组区间的长度是right - left + 1; 我们用i和j分别表示当前子区间第一部分的第一个元素的下标以及第二部分的第一个元素的下标; 用下标k表示马上要赋值回去的那个下标的位置: 总共要赋值数组长度这么多次, 我们每次从temp数组中比较, 赋值回nums数组中. 每次比较的时候, 都看i和j指向的元素哪一个更小; 因此, 首先是temp[i] &lt;= temp[j], 第一个部分先被选出, 故此: 12nums[left + 1] = temp[i];i++; 注意, 这里需要写=, 意味着i和j指向的元素的值相等的时候, 优先选取i指向的那个元素归并回去, 这样就能够保证归并排序的稳定性. 否则, 在相等的元素排序完后, 后面的旧元素就会跑到前面, 破坏了稳定性. 到这里代码还没有写完. 对于数组而言, 数组下标是否越界这件事情非常重要. 所以, 在这两行代码之前, 应该先判断i和j各自扫描完了的情况: 如果i来到了第二部分的第一个元素的位置, 此时我们就一直把j指向的元素从前向后依次赋值; 如果j来到了第二部分的最后一个元素的后面, 此时我们就一直把i指向的元素从前向后依次赋值. 在每次赋值中, 这四种情况会且仅会执行其中一种情况. 经过这样的一次循环, 归并就完成了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Solution { public int[] sortArray(int[] nums) { int len = nums.length; mergeSort(nums, 0, len - 1); return nums; } /** * 对数组 nums 的子区间 [left..right] 进行归并排序 * * @param nums * @param left * @param right */ private void mergeSort(int[] nums, int left, int right) { if (left == right) { return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); mergeOfTwoSortedArray(nums, left, mid, right); } /** * 合并两个有序数组：先把值复制到临时数组，再合并回去 * * @param nums * @param left * @param mid [left, mid] 有序，[mid + 1, right] 有序 * @param right */ private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right) { // 每做一次合并，都 new 数组用于归并，开销大 int len = right - left + 1; int[] temp = new int[len]; for (int i = 0; i &lt; len; i++) { temp[i] = nums[left + i]; } // i 和 j 分别指向前有序数组和后有序数组的起始位置 int i = 0; int j = mid - left + 1; for (int k = 0; k &lt; len; k++) { // 先写 i 和 j 越界的情况 if (i == mid - left + 1) { nums[left + k] = temp[j]; j++; } else if (j == right + 1 - left) { nums[left + k] = temp[i]; i++; } else if (temp[i] &lt;= temp[j]) { // 注意：这里必须写成 &lt;=，否则归并排序就成了非稳定的排序 nums[left + k] = temp[i]; i++; } else { nums[left + k] = temp[j]; j++; } } }} 理解递归函数相较于已经在二分查找中介绍过的分而治之思想, 这里更重要的是递归. 递归在算法领域几乎随处可见, 理解起来也十分的有意思. 递归是一种自上而下思考问题的方式 递归是自己调用自己, 但每次调用中参数的规模不一样. 在线性结构中, 每一次的递归调用一定会朝着数据规模越来越小的方向发展, 故递归终止条件非常重要. 递归函数的调用过程是: 后调用的方法先执行, 因此之前调用的函数的相关信息需要保存起来, 而保存这些信息的数据结构就是”栈”. 我们会在后面的章节中着重介绍栈. 编写递归函数时, 有着如下的编写模式需要遵守: 先写递归终止条件 假定小规模的问题已经解决(通过递归解决) 最后处理小规模问题已经解决的情况下, 与当前问题之间的逻辑联系. 递归函数方式有一个特点, 就是后调用的先返回. 在更底层的函数返回后, 我们可以做点别的事情. 归并排序中的归并过程就是在归并函数返回后进行的. 练习一: 合并两个有序数组123456789101112131415161718192021222324252627class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int indexOne = 0; int indexTwo = 0; int[] cache = new int[m+n]; for (int i = 0; i &lt; m; i++) { cache[i] = nums1[i]; } for (int index = 0; index &lt; m+n; index++) { if (indexOne &gt;= m) { nums1[index] = nums2[indexTwo]; indexTwo++; } else if (indexTwo &gt;= n) { nums1[index] = cache[indexOne]; indexOne++; } else if (cache[indexOne] &lt;= nums2[indexTwo]) { nums1[index] = cache[indexOne]; indexOne++; } else { nums1[index] = nums2[indexTwo]; indexTwo++; } } }} 练习二: 旋转数组123456789101112131415161718192021222324252627282930313233343536class Solution { public void rotate(int[] nums, int k) { int length = nums.length; k = k % length; if (!appropriateK(k, length)) { return; } int[] cache = new int[length]; for (int i = 0; i &lt; length; i++) { cache[i] = nums[i]; } for (int i = 0; i &lt; k; i++) { nums[i] = cache[length - k + i]; } int index = 0; for (int i = k; i &lt; length; i++) { nums[i] = cache[index]; index++; } } public boolean appropriateK(int k, int length) { if (k == 0) { return false; } else if (k &gt; length - 1) { return false; } return true; }} 练习三: 寻找旋转排序数组中的最小值12345678910111213141516171819202122232425262728293031class Solution { public int findMin(int[] nums) { int left = 0; int right = nums.length - 1; if (nums[left] &lt; nums[right]) { return nums[left]; } return divide(nums, left, right); } public int divide(int[] nums, int left, int right) { int mid = left + (right - left) / 2; if (left == mid) { if (nums[left] &gt; nums[right]) { return nums[right]; } else { return nums[left]; } } if (nums[left] &gt; nums[mid]) { right = mid; } else { left = mid; } return divide(nums, left, right); }} 归并排序的优化优化一: 在小区间内使用插入排序如果区间里只有两个元素, 如[4,3], 就犯不着再递归了, 直接交换下位置就好. 但毕竟这种情况太特殊, 如果区间里有更多的元素, 该怎么办呢? 其实, 在小区间里直接使用插入排序就好. 在归并排序的子过程里, 可以使用插入排序的原因是: 操作的指令数更少 插入排序也是稳定的排序算法, 修改成插入排序并不影响归并排序的稳定性. 当然, 这个区间也不能太大. 目前Java语言的库函数规定, 在区间长度小于47的情况下可以使用插入排序. 123456789101112131415161718private static final int INSERTION_SORT_THRESHOLD = 47;if (right - left &lt;= INSERTION_SORT_THRESHOLD) { insertionSort(arr, left, right); return;}private void insertionSort(int[] arr, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = arr[i]; int j = i; while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; }} 优化二: 子区间本身有序则无须归并如果子区间本身是有序的, 我们就没有必要在归并一次. 123if (arr[mid] &lt;= arr[mid + 1]) { return;} 优化三: 在整个归并的过程中, 使用同一个辅助数组在上一节的做法中, 我们每归并一次, 都得创建一个临时数组. 虽然这个临时数组在使用完以后就会被垃圾回收机制回收, 但是, 频繁创建和销毁数组的过程还是造成了一定的性能浪费; 此外, 每次归并的时候, 如果使用的数组不同, 我们还需要计算偏移量, 使用同一个辅助数组就没有类似的问题. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Solution { private static final int INSERTION_SORT_THRESHOLD = 47; public int[] sortArray(int[] nums) { int len = nums.length; // 优化 3：全局使用一份临时数组 int[] temp = new int[len]; mergeSort(nums, 0, len - 1, temp); return nums; } private void mergeSort(int[] nums, int left, int right, int[] temp) { // 优化 1：小区间使用插入排序 if (right - left &lt;= INSERTION_SORT_THRESHOLD) { insertionSort(nums, left, right); return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp); mergeSort(nums, mid + 1, right, temp); // 优化 2：数组已经有序的情况下，不再合并 if (nums[mid] &lt;= nums[mid + 1]) { return; } mergeOfTwoSortedArray(nums, left, mid, right, temp); } private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) { for (int i = left; i &lt;= right; i++) { temp[i] = nums[i]; } int i = left; int j = mid + 1; for (int k = left; k &lt;= right; k++) { if (i == mid + 1) { nums[k] = temp[j]; j++; } else if (j == right + 1) { nums[k] = temp[i]; i++; } else if (temp[i] &lt;= temp[j]) { // 注意：这里一定要写成 &lt;=，否则就变成了非稳定排序 nums[k] = temp[i]; i++; } else { nums[k] = temp[j]; j++; } } } private void insertionSort(int[] arr, int left, int right) { for (int i = left + 1; i &lt;= right; i++) { int temp = arr[i]; int j = i; while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } }} 快速排序: 其一快速排序(quick sort)是一种高效的排序算法, 被应用在大多数的排序任务中. 什么是划分快速排序中最重要的思想是划分, 英文名为partition. 以数组[4,5,1,6,7,3,2]为例, 我们试着说明一下partition的过程. partition通常先随机选取一个元素作为基准元素, 以第一个元素4为例. 痛过一次划分, 我们将数组分为两个部分, 其中一部分小于基准元素4, 另外一部分大于等于基准元素3. 此时, 4就位于了它排序以后最终在的位置, 因为它前面的元素都不大于它, 后面的元素都不小于它. 接下来就是对基准元素前后部分的排序, 使用的同样也是partition方法. 每执行一次partition, 我们都可以确定一个元素的位置. 最终, 我们就可以获得一个有序数组. 左右两侧分别执行partition的过程是通过递归进行的. 与归并排序不同, 快速排序并没有合并子数组的过程. 快速排序中的循环常量我们定义在子区间[left, right]中执行partition的过程, 其中pivot = nums[left], 在一开始的时候位于left+1的位置. j的定义如下: j在循环变量i右移的过程中保持不变的性质是: 在i向右边遍历的过程中, 总有[left+1,j] &lt; pivot, 并且[j+1) &gt;= pivot成立. 在我们遇到一个比基准元素pivot小的元素时, 我们总是想方设法地将它放到数组的前面去, 因此我们更关注小的元素. 由此, 在编写代码的时候, j的初值, 以及遇到一个元素时如何处理, 就十分清晰了: 为了使得初始的时候区间[left+1,j]和区间[j+1,i)都为空, 故设置i=left. 我们可以验证一下: 将j=left带入区间[left+1,j]和区间[j+1,i), 均为空. 这点十分重要. 在i向右遍历的时候, 因为需要保持j以及j之前的元素都小于基准元素, 因此: 如果i指向的元素大于等于基准元素pivot的时候, 什么都不用做 如果i指向的元素小于基准元素pivot的时候 , j先向后移动一位, 再与i交换, 然后i再向前移动, 这就能保持在循环的过程中, i和j的定义不变. 快速排序的代码实现和归并排序一样, 快速排序也是通过递归实现的. 我们首先写出快速排序算法的代码框架: 123456789101112131415161718192021222324252627282930313233343536373839class Solution extends ToolBox { public int[] sortArray(int[] arr) { int len = arr.length; quickSort(arr, 0, len-1); return arr; } private void quickSort(int[] arr, int left, int right) { // 这里包括了大于的情况 if (left &gt;= right) { return; } int p = partition(arr, left, right); quickSort(arr, left, p-1); quickSort(arr, p+1, right); } private int partition(int[] arr, int left, int right) { int pivot = arr[left]; // 循环不变量: lt, 意为less than // [left+1, lt] &lt; pivot // [lt+1, i) &gt;= pivot int lt = left; // 这里需要取等号 for (int i = left + 1; i &lt;= right; i++) { if (arr[i] &lt; pivot) { // 交换当前元素与lt的位置 lt++; swap(arr, i, lt); } } // 最后将left和lt交换位置 swap(arr, left, lt); return lt; } private void swap(int[] arr, int index1, int index2) { int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; }} 有一点需要注意的是: 越是有序的数组, 使用快速排序进行排序所需的时间越长. 快速排序的时间复杂度: 其一在快速排序中, 如果基准元素被交换到的位置越靠中间, 递归执行的深度就越浅, 快速执行的效率就越高; 如果被交换到的位置越靠两侧, 递归执行的深度就越深, 快速排序的效率也就越低. 在最极端的情况(基准元素被交换到了数组开头或结尾)下, 快速排序的效率最低, 时间复杂度可达到$O(N^2)$. 事实上, 如果想要优化快速排序, 一个最基本的原则就是降低递归树的高度, 让树更加平衡, 提高执行效率. 由此, 一个比较容易想到的方法就是在一开始的时候, 随机选择一个元素交换到待排序的部分的开头. 12int randomIndex = left + RANDOM.nextInt(right - left + 1);swap(arr, randomIndex, left); 但即使随机选择了pivot元素, 也有可能选择到最极端的那个元素, 导致递归树不平衡. 但这种情况出现的概率很低, 为: $$\\frac{1}{n}\\cdot\\frac{1}{n-1}\\cdots\\frac{1}{2}\\cdot 1 = \\frac{1}{n!}$$ 这个数值是很小的(在$n=5$的时候$\\frac{1}{n!}$就已经小于$0.01$). 因此, 在通常意义下, 加了随机选择pivot元素的快速排序, 在平均意义下的递归树是”接近平衡的”, 时间复杂度和归并排序一样. 完整代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Random;class Solution extends ToolBox { private static final Random RANDOM = new Random(); public int[] sortArray(int[] arr) { int len = arr.length; quickSort(arr, 0, len-1); return arr; } private void quickSort(int[] arr, int left, int right) { // 这里包括了大于的情况 if (left &gt;= right) { return; } int p = partition(arr, left, right); quickSort(arr, left, p-1); quickSort(arr, p+1, right); } private int partition(int[] arr, int left, int right) { int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(arr, randomIndex, left); int pivot = arr[left]; // 循环不变量: lt, 意为less than // [left+1, lt] &lt; pivot // [lt+1, i) &gt;= pivot int lt = left; // 这里需要取等号 for (int i = left + 1; i &lt;= right; i++) { if (arr[i] &lt; pivot) { // 将原本数组的范围向右扩一位 lt++; // 交换当前元素与lt的位置 swap(arr, i, lt); } } // 最后将left和lt交换位置 swap(arr, left, lt); return lt; } private void swap(int[] arr, int index1, int index2) { int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; }} 快速排序的时间复杂度与空间复杂度增加了”随机选择切分元素”后的快速排序有着更高的效率. 根据上一节的分析, 快速排序的时间复杂度可以降到$O(N\\log N)$. 由于快速排序使用了递归函数, 递归调用栈的深度我们认为接近$\\log N$, 因此空间复杂度是$O(\\log N)$. “随机选择切分元素”的优化在有一种情况下是不起作用的, 即输入数组有大量重复元素的情况. 这是由就要使用另一种优化方法, 即指针对撞的快速排序. 我们在下一节中介绍. 快速排序: 其二“随机选择切分元素”的优化在有一种情况下是不起作用的, 即输入数组有大量重复元素的情况. 这是由就要使用另一种优化方法, 即将和pivot相等的元素平均分到数组的两边, 使得递归树平衡. 这就是所谓的”指针对撞的快速排序“ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Random;class Solution extends ToolBox { private static final Random RANDOM = new Random(); public int[] sortArray(int[] arr) { int len = arr.length; quickSort(arr, 0, len-1); return arr; } private void quickSort(int[] arr, int left, int right) { // 这里包括了大于的情况 if (left &gt;= right) { return; } int p = partition(arr, left, right); quickSort(arr, left, p-1); quickSort(arr, p+1, right); } private int partition(int[] arr, int left, int right) { int randomIndex = left + RANDOM.nextInt(right - left + 1); swap(arr, randomIndex, left); int pivot = arr[left]; int le = left + 1; int ge = right; while (true) { while (le &lt;= ge &amp;&amp; arr[le] &lt; pivot) { le++; } while (le &lt;= ge &amp;&amp; arr[ge] &gt; pivot) { ge--; } if (le &gt; ge) { break; } swap(arr, le, ge); le++; ge--; } swap(arr, left, ge); return ge; } private void swap(int[] arr, int index1, int index2) { int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; }} 快速排序: 其三在本节中, 我们再介绍一种提高快速排序效率的优化方法: 三向切分. 三向切分的原理就是在遍历的过程中把排序的部分分成三个区间, 可视作是先前两种快速排序版本的结合. 在变量i遍历的过程中, 设置两个变量lt和gt, 保持下面的循环常量的性质: 在循环的过程中, 总有[left+1, lt] &lt; pivot、[lt+1, i) = pivot并且[gt, right] ?= pivot成立. 这样划分是出于如下原因: 把与pivot的元素关系进行更细致的划分, 等于pivot元素被单独划分到了一组 除了i以外的区间都是用闭区间, 这是因为i是循环变量, 表意为”遍历之前的元素”性质更好掌握. 根据这样的设定, 我们就可以口头论述一下三向切分快速排序的工作步骤: 首先, 在初始化的时候: i = left + 1, lt = left, gt = right + 1, 三个空间均为空 其次, 在遍历到一个元素的时候: 如果等于pivot, 我们什么都不用做, i向右移动一格即可 如果严格小于pivot, 我们先将lt向右移动一格, 然后交换lt与i, 然后i再向右移动一格 如果严格大于pivot, 我们先将gt向左移动一格, 然后交换gt与i, 此时i无需移动, 因为交换过来的是一个我们还没有看到的元素, 我们可以再下一轮循环中再根据它的大小执行相应的步骤. 最后, 循环终止的时候: i = gt. 因为[lt + 1, i)不包括i. 因此, 这三个区间正好铺满了整个除了基准元素的那个区间, 最后, 我们交换一下left和lt的位置就好了. 接下来, 我们再对[left, lt - 1]和区间[gt, right]分别递归执行下去即可. 三向切分能够加速排序的原因在于: 它在一次partition中就确定了所有等于pivot的元素的位置, 节省了再对这些元素排序的事件; 此外, 如此步骤还降低了子区间的有序度, 提高了partition的效率. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Random;class Solution extends ToolBox { private static final Random RANDOM = new Random(); public int[] sortArray(int[] arr) { int len = arr.length; quickSort(arr, 0, len-1); return arr; } private void quickSort(int[] arr, int left, int right) { if (left &gt;= right) { return; } int randomIndex = left + RANDOM.nextInt(right-left+1); swap(arr, randomIndex, left); int pivot = arr[left]; int lt = left; int gt = right + 1; int i = left + 1; while (i &lt; gt) { if (arr[i] &lt; pivot) { lt++; swap(arr, i, lt); i++; } else if (arr[i] == pivot) { i++; } else { gt--; swap(arr, i, gt); } } swap(arr, left, lt); quickSort(arr, left, lt - 1); quickSort(arr, gt, right); } private void swap(int[] arr, int index1, int index2) { int temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; }} 非比较排序算法所谓”非排序”, 指的是一个元素完成排序后所处的位置, 只由它自己的值确定. 非比较排序中蕴含了哈希表的思想. 计数排序计数排序的基本思想是: 将元素的值, 看作是计数数组的下标. 说起来, 计数排序的原理很简单: 统计每个元素出现的次数, 根据次数完成排序工作. 先前的荷兰国旗问题就可以通过这个问题解决: 分别统计0、1和2出现的次数, 最后根据出现次数打印数组即可. 我们将相同的0、1和2不加区别地对待, 放置在一起, 然后在最后拿出来. 需要注意的是, 如果基数排序排序的对象是对象数组, 那么排序就会失去稳定性; 如果排序任务对稳定性的要求不高, 就可以使用基数排序. 在本节中, 我们将介绍一种”稳定的”计数排序. 这种稳定性, 在下节中的基数排序(确实是这个名字, 我没打错字)也会用到. 计数排序的使用场景为了更好地介绍计数排序, 我们先对计数排序的数据范围做一些假设: 假设输入数组是整型数组 假设输入数组中的元素的值都是非负整数, 即在$[0, 10000]$之间. 这个$10000$没有什么特殊含义, 是我们为了描述问题方便随便写的, 实际越小越好. 计数排序的稳定实现为了维护计数排序的稳定性, 我们还有一些准备工作要做. 以数组[2,5,3,0,2,3,0,3]为例. 第一步: 得到计数数组, 计数数组的元素个数的等于原始数组的最大元素+1: 计数数组 2 0 2 3 0 1 数值(数组下标) 0 1 2 3 4 5 我们发现, 3出现了三次. 这个3很明显应该排在两个0和两个2后面, 由此, 我们更进一步, 计算出前缀和数组. 第二步: 将计数数组改造成”前缀和”计数数组: “前缀和”计数数组 2 2 4 7 7 8 数值(数组下标) 0 1 2 3 4 5 “前缀和”计数数组的意义如下: 排好序以后, 最后一个0位于数组的第二个位置(下标为1), 最后一个2位于数组的第四个位置(下标为3)… 以此类推. 通过前缀和计数数组, 我们可以很清楚地知道最后一个元素在排好序之后应该位于什么位置, 因此我们可以从后向前一次遍历原始数组, 将值赋值回去, 这样就能保证排序以后数组的稳定性. 第三步: 从后向前赋值回原始数组 最后我们再重复一下计数排序的基本思想: 对于每一个输入数组的元素, 严格计算小于它的元素的个数(也就是这个元素在排序后最后出现在哪个元素上), 并将各元素放置到对应的位置上. 计数排序的适用场景 数据的范围小 重复元素多 计数排序最典型的应用场景就是对年龄和考试成绩等数据的排序. 如果元素中有负数或小数, 则我们可以先为负数或小数与非负整数建立一一对应的关系, 然后再进行排序即可. 计数排序代码编写这里的代码仅考虑排序数组中的元素均为非负整数的情况. 123456789101112131415161718192021222324252627282930class Solution extends ToolBox { public void sort(int[] arr) { int length = arr.length; int max = arr[0]; for (int i = 0; i &lt; length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } int[] count = new int[max+1]; for (int i = 0; i &lt; length; i++) { count[arr[i]] += 1; } for (int i = 1; i &lt;= max; i++) { count[i] += count[i - 1]; } int[] arrCopy = new int[length]; System.arraycopy(arr, 0, arrCopy, 0, length); for (int i = length - 1; i&gt;= 0; i--) { int position = count[arrCopy[i]] - 1; arr[position] = arrCopy[i]; count[arrCopy[i]]--; } }} 计数排序的复杂度分析 时间复杂度: $O(N+K)$, 其中: $N$为数组长度, $K$为数组的最大值; 空间复杂度: $O(N+K)$ 可以看出, 如果$K$很大, 计数排序就会既耗时、又耗空间. 基数排序基数排序是一种非比较的排序方法, 是多关键字的排序方法. 所谓关键字, 在基数排序中, 即为数组每一位(个位和和十位等)上的数字. 为了更好地论述基数排序, 我们这里只讨论非负整数的排序任务. 计数排序有两种: 高位优先(Most significant digital)和低位优先(Least significant digital). 常见的做法是低位优先, 故这里只简单介绍高位优先, 着重介绍低位优先. 高位优先高位优先比较直观, 即先按照高位升序排序, 然后按照次高位排序, 依次进行, 知道最低位排序完成. 这种方法需要用到递归, 且空间复杂度较大, 与低位优先基数排序相比逊色了不少. 低位优先我们以数组[329, 457, 657, 839, 436, 720, 355]为例, 论述低位优先的工作原理. 首先按照个位数进行一次稳定排序(相同数字顺序不变), 得到$$[720, 355, 436, 457, 657, 329, 839]$$ 然后按照十位数进行一次稳定排序(相同数字顺序不变), 得到$$[720, 329, 436, 839, 355, 457, 657]$$ 最后按照百位数进行一次稳定排序(相同数字顺序不变), 得到$$[329, 355, 436, 457, 657, 720, 839]$$ 在日常生活中, 我们总是先对高位数字进行比较. 但是在低位优先里, 我们先对低位数字进行比较. 为了保证排序的稳定性, 在每次比较中, 我们必须使用稳定排序, 确保先前确定好的顺序不会被破坏. 代码编写首先需要解决得到数位上的数字的问题. 解决方法很简单: 首先将低位抹去, 再直接取个位(对10取模)即可. 1int remainder = (arr[j] / divisor) % 10; 完整代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class RadixSort { public void sort(int[] nums) { int len = nums.length; // 第 1 步：找出最大的数字 int max = nums[0]; for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍 int maxLen = getMaxLen(max); // 第 3 步：每一趟都使用计数排序 int[] count = new int[10]; int[] temp = new int[len]; int divisor = 1; // 有几位数，外层循环就得执行几次 for (int i = 0; i &lt; maxLen; i++) { // 每一步都使用计数排序，保证排序结果是稳定的，这一步需要额外空间保存结果集，因此把结果保存在 temp 中 countingSort(nums, temp, divisor, len, count); System.arraycopy(temp, 0, nums, 0, len); divisor *= 10; } } /** * * @param nums 原始数组 * @param temp 在计数排序的过程中使用的辅助数组，这一次基于 divisor 关键字的排序结果存在这里 * @param divisor * @param len 原始数组的长度（冗余变量） * @param count 计数数组 */ private void countingSort(int[] nums, int[] temp, int divisor, int len, int[] count) { // 内层循环得把数组从头到尾看一遍 for (int j = 0; j &lt; len; j++) { // 计算数位上的数是几，先取个位，再十位、百位 int remainder = (nums[j] / divisor) % 10; count[remainder]++; } for (int j = 1; j &lt; 10; j++) { count[j] += count[j - 1]; } for (int j = len - 1; j &gt;= 0; j--) { int remainder = (nums[j] / divisor) % 10; int index = count[remainder] - 1; temp[index] = nums[j]; count[remainder]--; } // 重置数组 count，以便下次使用 for (int j = 0; j &lt; 10; j++) { count[j] = 0; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; }} 基数排序的复杂度分析 时间复杂度: $O(KN)$, 其中: $N$为输入数组的长度, $K$为关键字的个数; 空间复杂度: $O(N + K)$, 其中$K$通常远小于$N$. 桶排序桶排序的基本思想桶排序使用”分而治之”的思想, 将待排序数组分配到若干个桶内, 然后再对每个桶各自执行一个排序任务. 桶内的排序可以使用不同的排序方法, 每个桶内排序完成后, 依次将每个桶内的元素取出来, 最终得到一个有序数组. 具体步骤可被论述为: 将要排序的数分到几个大小相同、被称作”桶”的子区间里; 分别对每个桶里的数据进行排序(这里使用插入排序); 按照顺序将每个桶中的元素依次取出. 桶排序的适用范围 数据均匀分布, 不会出现很多元素都放在一个桶中的情况 如果步长和桶数设置合理, 每个桶使用插入排序, 既能加快排序, 又能保证数据的稳定性. 桶排序的代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BucketSort { public void sort(int[] nums) { int len = nums.length; int max = nums[0]; // 第 1 步：找到数组中的最大值，以确定计数数组的长度 for (int i = 1; i &lt; len; i++) { if (nums[i] &gt; max) { max = nums[i]; } // 数据有效性校验，因为要将数值作为 count 的索引用，因此 nums[i] 不能小于 0 if (nums[i] &lt; 0) { throw new IllegalArgumentException(&quot;该数组不适合使用计数排序&quot;); } } // 第 2 步：计算出最大的数字有几位，这个数值决定了桶的个数 int maxLen = getMaxLen(max); // 步长 int step = 1000; // 决定设置几个桶 if (maxLen &lt; 5) { // 如果最大数小于 10000 // 3 位数就设置 100 个桶 // 2 位数就设置 10 个桶 step = (int) Math.pow(10, maxLen - 1); } // System.out.println(&quot;步长：&quot; + step); // 桶的个数 int bucketLen = max / step + 1; // System.out.println(&quot;桶的个数：&quot; + bucketLen); // 因为不能确定每个桶存放的数据量，因此每个桶的长度都设置为 len int[][] temp = new int[bucketLen][len]; int[] next = new int[bucketLen]; // 第 3 步：分桶 for (int i = 0; i &lt; len; i++) { // 找到所在的桶的索引 int bucketIndex = nums[i] / step; // 在该桶中放入元素 temp[bucketIndex][next[bucketIndex]] = nums[i]; // 该桶存放的元素个数 + 1 next[bucketIndex]++; } // 第 4 步：对于每个桶执行插入排序 for (int i = 0; i &lt; bucketLen; i++) { insertionSort(temp[i], next[i] - 1); } // 第 5 步：从桶里依次取出来 int index = 0; for (int i = 0; i &lt; bucketLen; i++) { int curLen = next[i]; for (int j = 0; j &lt; curLen; j++) { nums[index] = temp[i][j]; index++; } } } private void insertionSort(int[] arr, int endIndex) { for (int i = 1; i &lt;= endIndex; i++) { int temp = arr[i]; int j = i; while (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp) { arr[j] = arr[j - 1]; j--; } arr[j] = temp; } } /** * 获取一个整数的最大位数 * * @param num * @return */ private int getMaxLen(int num) { int maxLen = 0; while (num &gt; 0) { num /= 10; maxLen++; } return maxLen; }} 桶排序的复杂度分析 时间复杂度: $O(N)$, 这个复杂度是平均时间复杂度. 该结论需要严格证明, 故过于理论化, 具体证明过程详见《算法导论》 空间复杂度: $O(M)$, 这个$M$是一个相对笼统的概念, 需要根据具体实现的细节来确定. 非比较排序的思想至此, 我们介绍了三种非比较排序方法. 虽然这三种方法各有各的特点, 但在原理方面, 它们都有一些相同之处: 都需要借助额外的空间完成排序; 它们都有一定的机制保证了排序的稳定性; 三种非比较排序的应用场景有一定局限性, 一般来说, 排序数据的范围不能太大; 所谓”非比较”体现在: 程序只要读取到这个元素就能确定它的位置, 不需要再和其他元素进行比较. 这种思想是哈希表思想的基础.","link":"/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"}],"categories":[]}