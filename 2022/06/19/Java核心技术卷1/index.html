<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java核心技术卷1 - 小苗的个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="小苗的个人博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小苗的个人博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java程序设计概述Java程序设计环境Java的基本程序设计结构字符串从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做String. 每一个用双引号括起来的字符串都是String类的一个实例. 子串String类"><meta property="og:type" content="blog"><meta property="og:title" content="Java核心技术卷1"><meta property="og:url" content="http://example.com/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/"><meta property="og:site_name" content="小苗的个人博客"><meta property="og:description" content="Java程序设计概述Java程序设计环境Java的基本程序设计结构字符串从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做String. 每一个用双引号括起来的字符串都是String类的一个实例. 子串String类"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2022-06-19T06:29:11.000Z"><meta property="article:modified_time" content="2022-06-27T12:13:52.663Z"><meta property="article:author" content="Arnold Miao"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/"},"headline":"Java核心技术卷1","image":["http://example.com/img/og_image.png"],"datePublished":"2022-06-19T06:29:11.000Z","dateModified":"2022-06-27T12:13:52.663Z","author":{"@type":"Person","name":"Arnold Miao"},"publisher":{"@type":"Organization","name":"小苗的个人博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"Java程序设计概述Java程序设计环境Java的基本程序设计结构字符串从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做String. 每一个用双引号括起来的字符串都是String类的一个实例. 子串String类"}</script><link rel="canonical" href="http://example.com/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-19T06:29:11.000Z" title="2022/6/19 14:29:11">2022-06-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-27T12:13:52.663Z" title="2022/6/27 20:13:52">2022-06-27</time></span><span class="level-item">3 hours read (About 25884 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java核心技术卷1</h1><div class="content"><h2 id="Java程序设计概述"><a href="#Java程序设计概述" class="headerlink" title="Java程序设计概述"></a>Java程序设计概述</h2><h2 id="Java程序设计环境"><a href="#Java程序设计环境" class="headerlink" title="Java程序设计环境"></a>Java程序设计环境</h2><h2 id="Java的基本程序设计结构"><a href="#Java的基本程序设计结构" class="headerlink" title="Java的基本程序设计结构"></a>Java的基本程序设计结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>从概念上讲, Java字符串就是Unicode字符序列. 例如, 串”Java\u2122”由5个Unicode字符J、a、v、a和™组成. Java没有内置的字符串类型, 而是在标准Java类库中提供了一个预定义类, 其很自然地叫做<code>String</code>. 每一个用双引号括起来的字符串都是<code>String</code>类的一个实例.</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p><code>String</code>类的<code>substring()</code>方法可以从一个较大的字符串中提取出一个字串. 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><code>substring()</code>方法的第二个参数表示<strong>不想复制</strong>的第一个位置. 这里, 我们想要复制第0、1和2个字符.</p>
<p><code>substring()</code>的工作方式有一个优点: 容易计算字符串的长度. 字符串<code>s.substring(a, b)</code>的长度就是$b-a$.</p>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>与绝大多数的程序设计语言一样, Java允许使用<code>+</code>号连接(拼接)两个字符串.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">expletive</span> <span class="operator">=</span> <span class="string">&quot;Expletive&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">PG13</span> <span class="operator">=</span> <span class="string">&quot;deleted&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> expletive + PG13;</span><br></pre></td></tr></table></figure>

<p>上述代码讲”Expletivedeleted”赋值给了变量<code>message</code>.</p>
<p>当讲一个字符串与一个非字符串的值进行拼接时, 后者被转换成了字符串. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">rating</span> <span class="operator">=</span> <span class="string">&quot;PG&quot;</span> + age;</span><br></pre></td></tr></table></figure>

<p>此处, <code>rating</code>被赋值为<code>13</code>.</p>
<p>如果需要把多个字符串放在一起, 并用一个定界符分隔, 则可以使用静态<code>join()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">all</span> <span class="operator">=</span> String.join(<span class="string">&quot; / &quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们会得到内容为<code>S / M / L / XL</code>的字符串.</p>
<h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p><code>String</code>类中没有提供可用于<strong>修改</strong>字符串的方法. 如果硬要修改, 可以把不需要修改的部分复制出来, 然后使用拼接的方法建立新的字符串.</p>
<p>不可变字符串的最大优点就是<strong>实现了字符串的共享</strong>. 字符串变量总是指向内存中的一块区域, 不论怎样复制字符串变量, 其所指向的内容都是相同的.</p>
<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>可以使用<code>equals()</code>方法检测两个字符串是否相等. 对于表达式<code>s.equals(t)</code>: 如果字符串<code>s</code>与字符串<code>t</code>相等, 则返回<code>true</code>; 反之则返回<code>false</code>. 需要注意的是, <code>s</code>和<code>t</code>既可以是字符串变量, 也可以是字符串字面量. 例如, <code>&quot;Hello&quot;.equals(greeting)</code>表达式是合法的.</p>
<p>想要在不区分大小写的条件下判断表达式是否合法, 我们可以使用<code>equalsIgnoreCase()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="空串与null串"><a href="#空串与null串" class="headerlink" title="空串与null串"></a>空串与<code>null</code>串</h4><p>空串<code>&quot;&quot;</code>是长度为零的字符串. 可以调用一下代码检查一个字符串是否为空:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>而<code>null</code>串是一种特殊的<code>String</code>变量, 它表示没有任何对象与该变量关联. 可用<code>if (str == null)</code>判断一个字符串是否为<code>null</code>.</p>
<h4 id="码点与代码单元"><a href="#码点与代码单元" class="headerlink" title="码点与代码单元"></a>码点与代码单元</h4><h4 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a><code>String</code> API</h4><h4 id="阅读联机API文档"><a href="#阅读联机API文档" class="headerlink" title="阅读联机API文档"></a>阅读联机API文档</h4><h4 id="构件字符串"><a href="#构件字符串" class="headerlink" title="构件字符串"></a>构件字符串</h4><p>有时需要较短的字符串构建字符串, 例如案件或来自文件中的单词. 采用字符串连接的方式达到此目的效率比较低, 因为每次连接字符串都要创建一个新的<code>String</code>对象, 费时又占空间. 使用<code>StringBuilder</code>类就可以避免这个问题的发生.</p>
<p>如果需要用许多小段的字符串构件一个字符串, 那么应该按照下列步骤进行. 首先, 构建一个空的字符串构建器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>当每次需要添加一部分时, 就调用<code>append()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.append(ch);</span><br><span class="line">builder.append(str);</span><br></pre></td></tr></table></figure>

<p>在需要构件字符串时就调用<code>toString()</code>方法, 将可以得到一个<code>String</code>对象, 其中包含了构建器中的字符序列.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">completedString</span> <span class="operator">=</span> builder.toString();</span><br></pre></td></tr></table></figure>

<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><p>想要通过控制台进行输入, 首先需要构造一个<code>Scanner</code>对象, 并与”标准输入流”<code>System.in</code>关联.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用<code>Scanner</code>类的各种方法实现输入操作了. 如使用<code>nextLine()</code>方法将读取一行的内容做输入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;What is your name?&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.nextLine();</span><br></pre></td></tr></table></figure>

<p>使用<code>nextLine()</code>的原因是输入行中有可能包含空格. 如果想要读取一个单词(以空白符作为分隔符), 就调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">firstName</span> <span class="operator">=</span> in.next();</span><br></pre></td></tr></table></figure>

<p>要是想读取下一个整数, 就调用<code>nextInt()</code>方法; 如果想读取下一个浮点数, 就调用<code>nextDouble()</code>方法.</p>
<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><h4 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h4><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a><code>for each</code>循环</h4><p>Java有一种功能很强的循环结构, 可以用来依次处理数组中的每个元素(其他类型的元素几何也可)而不必为指定下标值而分心. 这种增强的<code>for</code>循环结构的格式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement</span><br></pre></td></tr></table></figure>

<h4 id="数值初始化以及匿名数组"><a href="#数值初始化以及匿名数组" class="headerlink" title="数值初始化以及匿名数组"></a>数值初始化以及匿名数组</h4><p>在Java中, 提供了一种创建数组对象并同时赋予初始值的简化书写形式. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] smallPrimes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>甚至还可以初始化一个匿名的数组:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">14</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这种表示法将创建一个新数组并利用括号中提供的值进行初始化, 数值的大小就是初始值的个数. 使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallPrimes = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">13</span>, <span class="number">23</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">23</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这是下列语句的简写形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anonymous = &#123;<span class="number">123</span>, <span class="number">123</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">312</span>&#125;;</span><br><span class="line">smallPrimes = anonymous;</span><br></pre></td></tr></table></figure>

<h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><p>在Java中, 允许将一个<strong>数组变量</strong>拷贝给另一个<strong>数组变量</strong>. 此时, <strong>两个变量将引用同一个数组</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] luckyNumbers = smallPrimes;</span><br><span class="line">luckyNumbers[<span class="number">5</span>] = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>如果希望将一个数组的所有值<strong>拷贝</strong>到一个新的数组中去, 就需要使用<code>Array</code>类的<code>copyOf</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>其中, 第二个参数是新数组的长度. 这个方法通常用来增加数组的大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luckyNumbers = Arrays.copyOf(luckyNumbers, <span class="number">2</span> * luckyNumbers.length);</span><br></pre></td></tr></table></figure>

<p>如果数组元素是数值型, 那么多余的元素将被赋值为<code>0</code>; 如果数组元素是布尔型, 则将赋值为<code>false</code>. 相反, 如果长度小于原始数组的长度, 则只拷贝最前面的数组元素.</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>每一个Java应用程序都有一个带<code>String arg[]</code>参数的<code>main()</code>方法. 这个参数表明<code>main()</code>方法将接收一个字符串数组, 也就是命令行参数.</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>想要对数值型数组进行排序, 可以使用<code>Arrays</code>类中的<code>sort()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>

<p>这个方法使用了优化的快速排序算法.</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组将使用多个下标访问数组元素, 它适用于表示表格或更加复杂的排列形式. 在Java中, 声明一个二维数组相当简单. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span>[][] balances = <span class="keyword">new</span> <span class="title class_">double</span>[NYEARS][NRATES];</span><br></pre></td></tr></table></figure>

<p>如果知道数组元素, 就可以不调用<code>new</code>, 而可以直接使用简化的书写形式对多维数组进行初始化. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] magicSquare = &#123;</span><br><span class="line">    &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">123</span>, <span class="number">34</span>&#125;,</span><br><span class="line">    &#123;<span class="number">123</span>, <span class="number">312</span>, <span class="number">43</span>, <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="number">124</span>, <span class="number">634</span>, <span class="number">345</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">845</span>, <span class="number">235</span>, <span class="number">542</span>,<span class="number">54</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦数组被初始化, 就可以利用两个方括号访问每个元素.</p>
<p>注意, <code>for each</code>循环语句不能自动处理二维数组的每一个元素. 它是按照行, 也就是一位数组处理的. 想要访问二维数组<code>a</code>的所有元素, 则需要使用两个嵌套的循环, 如下图所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">double</span>[] row : a)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> value : row)</span><br><span class="line">        statements;</span><br></pre></td></tr></table></figure>

<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><p>我们总是说”Java的多维数组”, 但实际上Java中没有多维数组, 只有一维数组. 多维数组实际上是”数组的数组”, 我们从前面数组<code>magicSquare[]</code>的声明方式就可以看出来.</p>
<p>由此, 我们就可以声明各列长度不一的数组.</p>
<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><h3 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h3><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>想要使用OOP(面向对象程序设计)就需要清楚对象的三种主要特性:</p>
<ol>
<li>对象的行为: 可以对对象施加哪些操作, 或者可以对对象施加哪些方法?</li>
<li>对象的状态: 当施加方法时, 对象如何响应?</li>
<li>对象的标识: 如何辨别具有相同行为与状态的不同对象?</li>
</ol>
<h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p>类之间最常见的关系有三: <strong>依赖</strong>、<strong>聚合</strong>以及<strong>继承</strong>.</p>
<h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>依赖是一种最明显而又最常见的关系. 比如, <code>Order</code>类使用<code>Account</code>类是因为<code>Order</code>对象需要访问<code>Account</code>对象查看信用; 但是<code>Item</code>类不依赖于<code>Account</code>类, 这是因为<code>Item</code>对象于客户账户无关. 总而言之, 如果一个类的方法操纵另一个类的对象, 我们就说一个类依赖于另一个类.</p>
<p>我们应该尽可能地将相互依赖的类减至最少, 用软件工程的术语来说, 就是让类之间的耦合度最小.</p>
<h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p>聚合也是一种相对具体且易于理解的关系. 例如, 一个<code>Order</code>对象包含一些<code>Item</code>对象. 聚合关系意味着类<code>A</code>的对象包含类<code>B</code>的对象.</p>
<h5 id="继承-后面会详细论述"><a href="#继承-后面会详细论述" class="headerlink" title="继承(后面会详细论述)"></a>继承(后面会详细论述)</h5><p>继承是一种用于表示特殊于一般关系的.</p>
<h3 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h3><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>Java总是采用<strong>按值调用</strong>, 即方法得到的是所有参数值的一个拷贝, 无法修改传递给它的任何参数变量的内容.</p>
<p>但是, 由于一个引用变量与其拷贝指向的都是一个对象, 我们可以很方便的利用方法改变对象的值.</p>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><h4 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h4><p>如果在构造器中没有显示地为域赋予初值, 那么就会被自动地赋一个默认值: 数值为<code>0</code>、布尔值为<code>null</code>. 然而, 如果不明确地为域进行初始化, 就会影响程序代码的可读性.</p>
<h4 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h4><p>通过重载类的构造器方法, 可以采用多种形式设置类的实例域的初始状态. 为确保不管如何调用构造器, 每个实例域都可以被设置一个有意义的初值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在执行构造器之前, 先执行赋值操作. 当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时, 这种方式特别有用.</p>
<p>初始值不一定是常量值. 在下面的例子中, 可以调用方法对域进行初始化.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> assignId();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">assignId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h4><p>在编写很小的构造器时, 如何为参数命名是个问题. 通常用单个字符命名参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">double</span> s)</span> &#123;</span><br><span class="line">    name = n;</span><br><span class="line">    salary = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样做有一个缺陷: 只有阅读代码才能够了解参数<code>n</code>和参数<code>s</code>的含义.</p>
<p>有些程序员会在每个参数前面加上一个前缀”a”:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Emplyee</span><span class="params">(String aName, <span class="type">double</span> aSalary)</span> &#123;</span><br><span class="line">    name = aName;</span><br><span class="line">    salary = aSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就比较清晰, 每个读者第一眼就能够看懂参数的含义.</p>
<p>还有一种基于如下事实的常用技巧: 参数变量用同样的名字将实例域<em>屏蔽</em>起来. 例如, 如果将参数命名为<code>salary</code>, <code>salary</code>将引用这个参数, 而不是实例域. 但是, 可以采用<code>this.salary</code>的形式访问实例域. <code>this</code>指隐式参数, 也就是所构造的对象. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h4><p>关键字<code>this</code>引用方法的隐式参数. 然而, 这个关键字还有另外一个含义.</p>
<p>如果<em>构造函数</em>的第一个语句形如<code>this(...)</code>, 则这个构造函数将调用同一个类的另一个构造函数. 下面是一个典型的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// calls Employee(String name, double salary)</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId, s);</span><br><span class="line">    nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>new Employee(60000)</code>时, <code>Employee(double)</code>构造函数将调用<code>Employee(String, double)</code>构造函数.</p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><h4 id="对象析构域finalize方法"><a href="#对象析构域finalize方法" class="headerlink" title="对象析构域finalize方法"></a>对象析构域<code>finalize</code>方法</h4><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类、父类和子类"><a href="#类、父类和子类" class="headerlink" title="类、父类和子类"></a>类、父类和子类</h3><h4 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h4><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>父类中的方法并不一定完全适合子类. 我们以<code>Employee</code>类和<code>Manager</code>类为例展开论述一下该问题.</p>
<p><code>Manager</code>类中有一个<code>getSalary()</code>方法, 可以返回薪水和奖金的总和. 但是其父类<code>Employee</code>类中的<code>getSalary()</code>方法做不到这一点. 所以, 我们需要写一个方法覆盖(override)掉父类中的这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>究竟应该如何实现这个方法呢? 看起来似乎很简单, 只需要返回<code>salary</code>和<code>bonus</code>的和就可以了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法并不能运行. 这是因为<code>Manager</code>类的<code>getSalary()</code>方法不能直接访问父类的私有域. 也就是说, 尽管每个<code>Manager</code>对象都拥有一个名为<code>salary</code>的域, 但是在<code>Manager</code>类的<code>getSalary()</code>方法中并不能够直接访问<code>salary</code>. 只有<code>Employee</code>类的方法才能够访问私有部分. 如果<code>Manager</code>类的方法一定要访问私有域, 就必须借助于公有的接口, <code>Employee</code>类中的公有方法<code>getSalary()</code>方法就是这样的一个接口.</p>
<p>现在我们再用<code>getSalary()</code>方法试一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法还是不能运行. 问题出在<code>getSalary()</code>方法上: <code>Manager</code>类也有一个<code>getSalary()</code>方法, 也就是正在执行的这个方法. 如果我们真的这么写了的话, 整个程序就会陷入无限的自我调用中, 最终程序崩溃.</p>
<p>所以, 当我们想要调用父类的某个方法(这里是<code>getSalary()</code>方法)时, 我们需要告诉编译器, 我们需要的是<strong>父类的</strong>方法. 这一需求可以通过关键字<code>super</code>实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.getSalary();</span><br></pre></td></tr></table></figure>

<p>如此, 我们调用的就不是<code>Manager</code>类中的、而是<code>Employee</code>类中的<code>getSalary()</code>方法. 以下是<code>Manager</code>类中<code>getSalary()</code>方法的正确编写方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">    <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类中, 我们可以增加域、增加方法或覆盖父类中的方法, 但是不可能删除所继承的任何域和方法.</p>
<h4 id="子类构造函数"><a href="#子类构造函数" class="headerlink" title="子类构造函数"></a>子类构造函数</h4><h4 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h4><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>有一个用来哦按段是否应该设计继承关系的简单规则, 即”IS-A”规则. 它侧面表明了<strong>每个子类对象同时也是其父类的对象</strong>.</p>
<p>“IS-A”规则的另一种表述法是<strong>置换法则</strong>. 它表明<strong>程序中出现父类对象的任何地方都可以用子类对象置换</strong>.</p>
<p>例如, 可以将一个子类的对象赋给父类变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br></pre></td></tr></table></figure>

<p>在Java中, 对象变量是<strong>多态</strong>的. 一个<code>Employee</code>变量既可以引用一个<code>Employee</code>类对象, 也可以引用一个<code>Employee</code>类的任何子类对象. 在下面的程序中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss;</span><br></pre></td></tr></table></figure>

<p>, 变量<code>staff[0]</code>与<code>boss</code>引用同一个对象. 但编译器将<code>staff[0]</code>看作<code>Employee</code>对象. 这意味着, 我们可以这样调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boss.setBonus(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>但是不能这样调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff[<span class="number">0</span>].setBonus(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>因为<code>staff[0]</code>是一个<code>Employee</code>类引用变量, 不能调用不属于<code>Employee</code>类的方法<code>getBonus()</code>.</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><h4 id="阻止继承-final类和方法"><a href="#阻止继承-final类和方法" class="headerlink" title="阻止继承: final类和方法"></a>阻止继承: <code>final</code>类和方法</h4><p>有时候, 可能希望阻止人们利用某个类定义子类. 不允许扩展的类的类被称为<code>final</code>类. 如果在定义类的时候使用了<code>final</code>修饰符就表明这个类是<code>final</code>类. 例如, 假设希望组织人们定义<code>Executive</code>类的子类, 我们就可以在定义这个类的时候使用<code>final</code>修饰符声明. 声明格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Executive</span> <span class="keyword">extends</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中的特定方法也可以被声明为<code>final</code>. 如果这样做, 子类就不能覆盖这个方法(<code>final</code>类中的所有方法自动地称为<code>final</code>方法). 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将方法或类声明为<code>final</code>主要目的是: 确保它们不会在子类中改变语义. 例如, <code>Calendar</code>类中的<code>getTime()</code>和<code>setTime()</code>方法都生命为<code>final</code>. 这表明<code>Calendar</code>类的设计者负责实现<code>Date</code>类与日历状态之间的转换, 而不允许子类处理这些问题. 同样地, <code>String</code>类也是<code>final</code>类. 这意味着任何人都不能定义<code>String</code>类的子类.</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>就像primitive基本类型数据的类型转换一样, 不同类的引用变量之间也可以进行类型转换, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> (Manager) staff[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>我们进行类型转换的唯一原因为: <strong>在暂时忽视对象的实际类型之后, 使用对象的全部功能</strong>. 例如, 在<code>managerTest</code>类中, 由于某些项是普通雇员, 所以<code>staff</code>数组必须是<code>Employee</code>对象的数组. 我们需要将数组中引用经理的元素复原成<code>Manager</code>类, 以便能够访问新增加的所有变量.</p>
<p>在Java中, 每个对象变量都属于一个类型. 将一个值存入变量时, 编译器将检查该操作是否合法. 将一个子类对象赋给一个父类引用变量, 这是合法的; 将一个父类对象赋给一个子类引用变量, 这就是不合法的. 我们需要养成如下的良好习惯: <strong>在进行类型转换之前, 先查看一下是否能够成功地转换</strong>. 这个过程十分简单, 只需要使用<code>instanceof</code>操作符就可以实现. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager) &#123;</span><br><span class="line">    boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果检查不通过, 编译器就不会进行这个转换. 综上所述:</p>
<ol>
<li>只能在继承层次内进行类型转换;</li>
<li>在将父类转换成子类之前, 应该使用<code>instanceof</code>进行检查.</li>
</ol>
<p>需要注意的是, 如果<code>x</code>为<code>null</code>, 在进行<code>instanceof</code>时只会返回<code>false</code>, 并不会产生任何异常.</p>
<p>实际上, 通过类型转换调整对象的类型并不是一种好的做法, 应将类型转换限制在仅在需要调用子类中特有的的方法时进行. 但是, 在出现这种情况时, 我们首先需要做的就是检查父类设计, 在父类中添加需要的方法, 这才是比较正确的选择.</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><h4 id="受保护访问"><a href="#受保护访问" class="headerlink" title="受保护访问"></a>受保护访问</h4><p>我们常说, 最好将类中的实例变量标记为<code>private</code>, 而方法标记为<code>public</code>. 任何声明为<code>private</code>的内容对其他类都是不可见的, 就连自己的子类也不能访问父类的私有域.</p>
<p>然而, 在某些时候, 我们希望父类中的某些方法允许被子类访问, 或者允许子类的方法访问父类中的某个域. 为此, 我们需要将这些方法或域标记为<code>protected</code>. 例如, 如果将超类<code>Employee</code>中的<code>hireDay</code>声明为<code>protected</code>, 而非<code>private</code>, 其子类<code>Manager</code>中的方法就可以直接访问它.</p>
<p>不过, 就算标记了<code>protected</code>, 子类<code>Manager</code>也只能访问<code>Manager</code>对象中的<code>hireDay()</code>方法, 而不能访问其他<code>Employee</code>对象中的<code>hireDay()</code>, 对于被标记了<code>protected</code>的其他域也有相同的结论.</p>
<p>在实际应用中应谨慎使用<code>protected</code>属性. 假设需要将设计的类提供给其他程序员使用, 而这个类中设置了一些保护域, 由于其他程序员可以由这个类再派生出新类, 并访问其中的受保护域, 则如果需要对这个类的实现进行修改, 就需要通知所有使用这个类的程序员. 这与OOP的数据封装原则相悖.</p>
<p>受保护的方法更具有实际意义. 如果需要限制某个方法的使用, 就可以将它声明为<code>protected</code>. 这表明子类(可能很熟悉祖先类)得到信任, 可以正确地使用这个方法, 而其他类则不行. 这种方法的最好例子就是<code>Object</code>类中的<code>clone</code>方法, 我们会在后面的相关章节展开论述.</p>
<p>归纳一下Java用于控制可见性的四个修饰符:</p>
<ol>
<li>仅对本类可见: <code>private</code>;</li>
<li>对所有类可见: <code>public</code>;</li>
<li>对包和所有子类可见: <code>protected</code>;</li>
<li>对本包可见: 默认, 无需修饰符.</li>
</ol>
<h3 id="Object-所有类的父类"><a href="#Object-所有类的父类" class="headerlink" title="Object: 所有类的父类"></a><code>Object</code>: 所有类的父类</h3><p><code>Object</code>类是Java类中所有类的始祖, 所有的类都是由它扩展来的. 因此, 了解这个类所提供的所有服务非常重要.</p>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a><code>equals()</code>方法</h4><p><code>Object</code>类中的<code>equals()</code>方法用于检测一个对象是否等于另外一个对象. 在<code>Object</code>类中, 这个方法将判断两个对象是否具有相同的引用: 如果两个对象具有相同的引用, 则它们一定是相等的.</p>
<p>然而, 对于绝大多数类来说, 这种判断是没有意义的. 例如: 采用这种方法判断两个<code>PrintStream</code>对象是否相等就是完全没有意义的. 通常需要的是判断两个对象的状态是否相等. 如果两个对象的状态是相等的, 就认为这两个对象是相等的.</p>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>如果隐式和显式的参数不属于同一个类, <code>equals()</code>方法将会如何处理呢? 这是一个很有争议的问题.</p>
<p>Java语言规范要求<code>equals()</code>方法具有下面的特性:</p>
<ol>
<li>自反性: 对于任何非空引用<code>x</code>, <code>x.equals(x)</code>应该返回<code>true</code>;</li>
<li>对称性: 对于任何<code>x</code>和<code>y</code>, 当且仅当<code>y.equals(x)</code>返回<code>true</code>, <code>x.equals(y)</code>也应该返回<code>true</code>;</li>
<li>传递性: 对于任何<code>x</code>、<code>y</code>和<code>z</code>, 如果<code>x.equals(y)</code>返回<code>true</code>, <code>y.equals(z)</code>返回<code>true</code>, <code>x.equals(z)</code>也应该返回<code>true</code>;</li>
<li>一致性: 如果<code>x</code>和<code>y</code>引用的对象没有发生变化, 反复调用<code>x.equals(y)</code>应该返回同样的结果;</li>
<li>对于任何非空引用<code>x</code>, <code>x.equals(null)</code>应返回<code>false</code>.</li>
</ol>
<p>这些规则是比较合理的, 因为其避免了类库实现者在数据结构中定位一个元素时还要考虑调用<code>x.equals(y)</code>, 还是调用<code>y.equals(x)</code>的问题.</p>
<p>但是, 但就对称性而言, 当比较两者不属于同一个类时, 我们需要仔细考虑一下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.equals(m);</span><br></pre></td></tr></table></figure>

<p>这里的<code>e</code>是一个<code>Employee</code>对象, <code>m</code>是一个<code>Manager</code>对象, 并且两个对象具有相同的姓名、薪水和雇佣日期. 如果在<code>Employee.equals()</code>中使用<code>instanceof</code>进行检测, 则返回<code>true</code>. 然而, 当我们反过来调用时,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.equals(e);</span><br></pre></td></tr></table></figure>

<p>根据对称性, 我们也需要返回<code>true</code>. 这就使得<code>Manager</code>类的<code>equals()</code>方法必须能够用自己与任何一个<code>Employee</code>对象进行比较, 忽视了自己所拥有的特有信息. 这无疑是不合理的.</p>
<p>本书认为:</p>
<ol>
<li>如果子类能够拥有自己的相等的概念, 则对称性要求强制采用<code>getClass()</code>进行检测;</li>
<li>如果由父类决定相等的概念, 那么就可以使用<code>instanceof</code>进行检测, 这样可以在不同的对象之间进行相等的比较.</li>
</ol>
<p>同时, 本书给出一个比较合理的编写<code>equals()</code>方法的建议:</p>
<ol>
<li>显示参数命名为<code>otherObject</code>, 稍后需要将他转换成另一个叫做<code>other</code>的变量;</li>
<li>检测<code>this</code>与<code>otherObject</code>是否引用同一个对象;</li>
<li>检测<code>otherObject</code>是否为<code>null</code>, 如果为<code>null</code>, 则返回<code>false</code>;</li>
<li>比较<code>this</code>与<code>otherObject</code>是否属于同一个类;</li>
<li>将<code>otherObject</code>转换为相应的类类型变量;</li>
<li>对所有需要比较的域进行比较. 如果所有的域都匹配, 就返回<code>true</code>; 反之, 则返回<code>false</code>.</li>
</ol>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h4><p>哈希值(Hash Code)是由对象导出的一个整型值, 无规律可言. 这使得两个不同对象的哈希值基本不会相等.</p>
<p><code>String</code>类使用下列算法计算哈希值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length(); i++) &#123;</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>hashCode()</code>方法定义在<code>Object</code>类中, 因此每个对象都有一个默认的哈希值, 其值为该对象的存储地址. 请看下面的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">System.out.println(s.hashCode() + <span class="string">&quot; &quot;</span> + sb.hashCode());</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(t);</span><br><span class="line">System.out.println(t.hashCode() + <span class="string">&quot; &quot;</span> + tb.hashCode());</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th>哈希值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>s</code></td>
<td>2524</td>
</tr>
<tr>
<td align="center"><code>sb</code></td>
<td>460141958</td>
</tr>
<tr>
<td align="center"><code>t</code></td>
<td>2524</td>
</tr>
<tr>
<td align="center"><code>tb</code></td>
<td>1163157884</td>
</tr>
</tbody></table>
<p>我们可以发现, 字符串<code>s</code>和<code>t</code>拥有相同的哈希值, 这是因为字符串的哈希值是由内容导出的; 但是字符串缓冲<code>sb</code>和<code>tb</code>却有着不同的哈希值, 这是因为<code>StringBuilder</code>类总没有定义<code>hashCode()</code>方法, 故调用的实际上是<code>Object</code>类的默认<code>hashCode()</code>方法, 获得的即为其自身的存储地址.</p>
<p>如果重新定义<code>equals()</code>方法, 我们就必须重新定义<code>hashCode()</code>方法, 以便用户可以将对象插入到哈希表中(具体内容会在后面详细论述).</p>
<p><code>hashCode()</code>方法应该返回一个整型数值(可以为负), 并合理地组合实例域的哈希值, 以便能够让各个不同的对象产生的哈希值更加均匀. 例如下面就是<code>Employee</code>类的<code>hashCode()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> * name.hashCode()</span><br><span class="line">        + <span class="number">11</span> * <span class="keyword">new</span> <span class="title class_">Double</span>(salary).hashCode()</span><br><span class="line">        + <span class="number">13</span> * hireDay.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法还有改进的空间. 首先, 最好使用<code>null</code>安全的<code>Object.hashCode()</code>. 如果其参数为<code>null</code>, 这个方法会直接返回0, 否则返回对参数调用<code>hashCode()</code>的结果.</p>
<p>其次, 可以使用静态方法<code>Double.hashCode()</code>方法来避免创建<code>Double</code>对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> * Object.hashCode(name)</span><br><span class="line">        + <span class="number">11</span> * Double.hashCode(salary)</span><br><span class="line">        + <span class="number">13</span> * Object.hashCode(hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>还有改进的空间</strong>. 需要组合多个哈希值时, 可以调用<code>Objects.hash()</code>并提供多个参数. 这个方法会对各个参数调用<code>Object.hashCode()</code>, 并组合这些哈希值. 如此, <code>Employee.hashCode()</code>方法可以被简单地写为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, salary, hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a><code>toString()</code>方法</h4><p>在<code>Object</code>中还有一个重要的方法, 即<code>toString()</code>方法. 它用于返回表示对象值的字符串. 下面是一个典型的例子: <code>Point</code>类的<code>toString()</code>方法将返回下面这样的字符串:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Point[x=<span class="number">10</span>,y=<span class="number">20</span>]</span><br></pre></td></tr></table></figure>

<p>绝大多数的<code>toString()</code>方法都遵循这样的格式: 类的名字, 随后是一对方括号括起来的域值. 下面是<code>Employee</code>类中的<code>toString()</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">         + <span class="string">&quot;, hireDay=&quot;</span> + hireDay</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上, 该方法还有改进空间. 最好通过掉调用<code>getClass().getName()</code>方法获得类名的字符串, 而不要将类名硬加到<code>toString()</code>方法中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()</span><br><span class="line">         + <span class="string">&quot;[name=&quot;</span> + name</span><br><span class="line">         + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">         + <span class="string">&quot;, hireDay=&quot;</span> + hireDay</span><br><span class="line">         + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计子类的程序员也应该定义自己的<code>toString()</code>方法, 并将子类域的描述添加进去. 如果父类中使用了<code>getClass().getName()</code>, 那么子类只要调用<code>super.toString()</code>方法就可以了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString()</span><br><span class="line">             + <span class="string">&quot;[bonus=&quot;</span> + bonus</span><br><span class="line">             + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toString()</code>方法如此常见的原因为: 只要对象域一个字符串通过操作符”<code>+</code>“连接起来, Java编译器就会自动调用<code>toString()</code>方法, 以便获得这个对象的字符串描述. 此外, 对于任意对象<code>x</code>, 使用<code>println(x)</code>方法就会直接调用<code>x.toString()</code>, 并打印输出得到的字符串.</p>
<h3 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h3><p>如何动态调整数组大小一直是一个让程序员头疼的问题. 幸好, 在Java中, 有一个名为<code>ArrayList</code>的类, 能够很好地解决这个问题.</p>
<p><code>ArrayList</code>类是一个采用类型参数(type parameter)的泛型类(generic class). 为了指定数组列表保存的元素对象类型, 需要用一对尖括号将类名括起来加在后面. 下面的代码声明和构造了一个保存<code>Employee</code>类对象的数组列表:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>既然两边都使用<code>Employee</code>, 重复输入多少有些繁琐, 故在Java SE 7中, 可省去右侧的类型参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>使用<code>add()</code>方法可以将元素添加到数组列表中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(...));</span><br></pre></td></tr></table></figure>

<p><code>ArrayList</code>类最大的优点在于其可以自动调整内部数组的大小. 但是, 如果已经清楚或能够估计出数组可能储存的元素数量, 我们就可以在填充数组之前调用<code>ensureCapacity()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.ensureCapacity(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法将分配一个包含100个对象的内部数组. 然后调用100次<code>add()</code>, 而不用重新分配空间.</p>
<p>另外, 还可以将初始容量传递给<code>ArrayList</code>构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>size()</code>方法将返回<code>ArrayList</code>中包含的<strong>实际元素数量</strong>.</p>
<p>此外, 一旦确定<code>ArrayList</code>的大小不再发生变化, 就可以调用<code>trimToSize()</code>方法. 这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目, 垃圾回收器也会回收多余的存储空间.</p>
<h4 id="访问数组列表元素"><a href="#访问数组列表元素" class="headerlink" title="访问数组列表元素"></a>访问数组列表元素</h4><p>想要访问或改变<code>ArrayList</code>元素, 需要使用<code>get</code>或<code>set</code>方法. 比如改变第<code>i</code>个元素的内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.set(i, harry);</span><br></pre></td></tr></table></figure>

<p>只有<code>i</code>小于或等于<code>ArrayList</code>大小时才能调用<code>set()</code>方法.</p>
<p>此外, 当没有泛型类时, 原始的<code>ArrayList</code>类提供的<code>get()</code>方法别无选择, 只能返回<code>Object</code>对象. 从这类<code>ArrayList</code>中调用出来的对象需要进行类型转换:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> (Employee) staff.get(i);</span><br></pre></td></tr></table></figure>

<h4 id="类型化域原始数组列表的兼容性"><a href="#类型化域原始数组列表的兼容性" class="headerlink" title="类型化域原始数组列表的兼容性"></a>类型化域原始数组列表的兼容性</h4><p>在我们自己的代码中, 我们可能更愿意使用类型参数来增加安全性. 在本节中, 我们会了解如何与没有使用类型参数的遗留代码交互操作.</p>
<p>假设有下面这个遗留下来的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(ArrayList list)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将一个类型化的数组传递给<code>update()</code>方法, 而不需要进行任何类型转换; 也可以将下面的<code>staff</code>对象传递给<code>updates()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = ...;</span><br><span class="line">employeeDB.update(staff);</span><br></pre></td></tr></table></figure>

<p>但是实际上, 这样调用说不上安全. 在<code>update()</code>方法中, 添加到<code>ArrayList</code>中的不一定是<code>Employee</code>对象. 编译器并不会发现这个问题, 但是在对这些元素进行检索的时候就会报错. 相反地, 将一个原始<code>ArrayList</code>赋给一个类型化<code>ArrayList</code>就会得到一个警告.</p>
<p>此外, 就算使用了类型转换也并不能避免出现警告:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query);</span><br></pre></td></tr></table></figure>

<p>我们只能受到一个警告信息, 提醒我们类型转换有误.</p>
<p>这是Java中不尽如人意的参数化类型的限制所带来的结果. 处于兼容性的考虑, 编译器在对类型转换进行检查之后, 如果没有发现违反规则的现象, 就将所有的类型化数组 列表转换成原始<code>ArrayList</code>对象. 在程序运行时, 所有的<code>ArrayList</code>都是一样的, 即没有虚拟机中的类型参数. 因此, 在执行将<code>ArrayList</code>转化为<code>ArrayList&lt;Employee&gt;</code>的操作时, 编译器将执行相同的运行时检查.</p>
<p>此时我们无需多做什么, 只要在与剩下的代码进行交叉操作时, 研究一下比那一起的警告提示, 并确保这些警告不会造成太严重的后果就可以了. 一旦确保不会造成严重后果, 可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>标注来标记这个变量能够接收类型转换,  如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query);</span><br></pre></td></tr></table></figure>

<h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><p>有时需要将<code>int</code>这样的基本类型转换为对象. 每个primitive主数据类型都有一个包装用的类, 名为包装器(wrapper), 且这些包装类都放在<code>Java.lang</code>这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示:</p>
<table>
<thead>
<tr>
<th>primitive主数据类型名称</th>
<th>包装类名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
</tbody></table>
<p>对象包装器是不可变的, 即一旦构造了包装器, 就不允许改变包装在其中的值. 同时, 对象包装类还被标记为<code>final</code>, 无法被继承.</p>
<p>此外, 还有一个很有用的特性, 使得向<code>ArrayList&lt;Integer&gt;</code>中添加<code>int</code>元素的过程更加方便. <code>list.add(3)</code>将被自动地转换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>这种转换被称为自动装箱(autoboxing).</p>
<p>相反地, 将一个<code>Integer</code>对象赋值给一个<code>int</code>值时, 就会进行自动拆箱, 即将<code>int n = list.get(n)</code>翻译成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i).intValue();</span><br></pre></td></tr></table></figure>

<p>甚至在算数表达式中自动拆装箱也是成立的. 比如, 下面的这个表达式是合法的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<p>大多数情况下, 容易有一种假象, 即基本类型与它们的对象包装器是一样的, 只是它们的相等性不同. 大家知道, <code>==</code>运算符也可以应用于对象包装器对象, 只不过检测的是对象是否指向同一个存储区域, 因此, 下面的比较通常不会成立:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>的确相等表达式有时会成立, 但是我们的程序不能建立在这种<em>可能</em>上. 如果真的要判断两个<code>Integer</code>对象是否相等的话, 还是需要使用<code>equals()</code>方法.</p>
<p>还有几点有关自动装箱的事情需要注意的. 首先, 由于包装类引用可以为<code>null</code>, 所以自动装箱有可能会抛出一个<code>NullPointerException</code>异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span>*n);</span><br></pre></td></tr></table></figure>

<p>另外, 如果在一个条件表达式中混用<code>Integer</code>和<code>Double</code>类型, <code>Integer</code>值就会拆箱, 提升为<code>double</code>, 并在此装箱为<code>Double</code>.</p>
<p>最后, 自动拆装箱是<strong>编译器</strong>认可的, 和JVM没有什么关系. 编译器在生成的字节码中添加一些必要的方法调用, 而虚拟机只是忠实地执行这些字节码罢了.</p>
<h4 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h4><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>下面是一个典型的枚举类的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br></pre></td></tr></table></figure>

<p>此声明定义了一个有着四个实例的类, 在此尽量不要构造新对象. 因此, 在比较两个枚举类型的值时直接使用<code>==</code>即可.</p>
<p>如有需要, 可以在枚举类中添加一些构造器、方法和域. 当然, 构造器只在构造枚举常量时被调用. 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    SMALL(<span class="string">&quot;S&quot;</span>), MEDIUM(<span class="string">&quot;M&quot;</span>), LARGE(<span class="string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String abbreviation;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abbreviation)</span> &#123;<span class="built_in">this</span>.abbreviation = abbreviation;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span> &#123;<span class="keyword">return</span> abbreviation;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的枚举类都是<code>Enum</code>类的子类. 它们继承了这个类的许多方法, 其中最有用的就是<code>toString()</code>方法. 这个方法能够返回枚举常量名. 例如, <code>Size.SMALL.toString()</code>将返回字符串”<code>SMALL</code>“.</p>
<p><code>toString()</code>的逆方法是静态方法<code>valueOf()</code>. 例如, 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">s</span> <span class="operator">=</span> Enum.valueOf(Size.class, <span class="string">&quot;SMALL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将会把<code>s</code>设置为<code>Size.SMALL</code>.</p>
<p>每个枚举类都有一个静态的<code>values</code>方法, 它将返回一个包含全部枚举值的数组. 例如, 如下调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size[] values = Size.values()</span><br></pre></td></tr></table></figure>

<p>将返回包含元素<code>Size.SMALL</code>, …和<code>Size.EXTRA_LARGE</code>的数组.</p>
<p><code>ordinal()</code>方法返回<code>enum</code>生命中枚举常量的位置, 索引从零开始计数.</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h3><ol>
<li>将公共操作和域放在父类;</li>
<li>不要使用受保护的域;</li>
<li>使用继承实现”IS-A”关系</li>
<li>除非所有继承的方法都有意义, 否则不要使用继承</li>
<li>在覆盖方法时, 不要改变预期的行为</li>
<li>使用多态, 而非类型信息</li>
<li>不要过多地使用反射</li>
</ol>
<h2 id="接口、lambda表达式域内部类"><a href="#接口、lambda表达式域内部类" class="headerlink" title="接口、lambda表达式域内部类"></a>接口、lambda表达式域内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口概念"><a href="#接口概念" class="headerlink" title="接口概念"></a>接口概念</h4><p>在Java程序设计语言中, 接口不是类, 而是对类的一组需求描述. 这些类要遵从接口描述的统一格式进行定义.</p>
<p>我们经常听到服务提供商这样说: “如果类遵从某个特定接口, 那么就旅行这项服务”. 下面给出一个具体的示例: <code>Arrays</code>类中的<code>sort()</code>方法承诺可以对对象数组进行排序, 但要求对象所述的类必须实现了<code>Comparable</code>接口.</p>
<p>下面是<code>Comparable</code>接口的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是说, 任何实现<code>Comparable</code>接口的类都需要包含<code>comparaTo()</code>方法, 并且这个方法的参数必须是一个<code>Object</code>对象, 返回一个整型数值.]</p>
<p>接口中的所有方法自动地属于<code>public</code>. 因此, 在接口中声明方法时, 不必提供关键字<code>public</code>.</p>
<p>当然, 接口中还有一个没有明确说明的附加要求: 在调用<code>x.compareTo(y)</code>的时候, 这个<code>compareTo()</code>方法必须确实比较两个对象的内容, 并返回比较的结果. 当<code>x</code>小于<code>y</code>时, 返回一个负数; 当<code>x</code>等于<code>y</code>时, 返回<code>0</code>; 否则返回一个正数.</p>
<p>上面这个接口只有一个方法, 而有些接口可能包含多个方法. 稍后可以看到, 在接口中还可以定义常量. 然而, 更为重要的是要知道接口不能提供哪些功能. 接口绝不能含有实例域——提供实例域和方法实现的任务应交由实现接口的那个类来完成.</p>
<p>现在, 假设希望使用<code>Arrays</code>类的<code>sort()</code>方法对<code>Employee</code>对象数组进行排序, <code>Employee</code>类就必须实现<code>Comparable</code>接口.</p>
<p>为了让类实现一个接口, 通常需要下面两个步骤:</p>
<ol>
<li>将类声明为实现给定的接口;</li>
<li>对接口中的所有方法进行定义.</li>
</ol>
<p>要将类声明为实现某个接口, 需要使用关键字<code>implements</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br></pre></td></tr></table></figure>

<p>当然, 这里的<code>Employee</code>类需要提供<code>compareTo()</code>方法. 假设希望根据雇员的薪水进行比较. 一下是<code>compareTo()</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee) o;</span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里, 我们使用了静态方法<code>Double.compare()</code>方法. 如果第一个参数小于第二个参数, 它会返回一个负值; 如果二者相等则返回<code>0</code>; 否则返回一个正值.</p>
<p>需要注意的是: 在接口声明中, 没有将<code>compareTo()</code>方法声明为<code>public</code>, 这是因为接口中的所有方法都默认为<code>public</code>. 不过, 在实现接口时, 我们需要将方法声明为<code>public</code>; 否则, 编译器将认为这个方法的访问属性为<code>default</code>, 之后编译器就会给出视图提供更严格的访问权限的警告信息.</p>
<p>此外, 我们还可以更进一步, 为泛型<code>Comparable</code>接口提供一个类型参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, o.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要提一嘴的是, 对<code>Object</code>参数进行强制类型转换的行为现在已经不常见了.</p>
<p>综上所述, 我们已经看到, 要让一个类使用排序服务必须让它实现<code>compareTo()</code>方法. 这是很有必要的, 因为需要向<code>sort()</code>方法提供对象的比较方式. 但是, 为什么不直接在<code>Employee</code>类中直接提供一个<code>compareTo()</code>方法, 而必须实现<code>Compareable</code>接口呢?</p>
<p>原因在于<strong>Java是一种强类型语言</strong>. 在调用方法的时候, 编译器将会检查这个方法是否存在. 在<code>sort()</code>方法中可能存在下面这样的语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i].compareTo(a[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// rearrange a[i] and a[j]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为此, 编译器就必须确认<code>a[i]</code>中一定有<code>compareTo()</code>方法. 如果<code>a</code>是一个<code>Comparable</code>对象的数组, 就可以确保拥有<code>compareTo()</code>方法, 因为每个实现<code>Comparable</code>接口的类都必须提供这个方法的定义.\</p>
<h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><p>接口不是类, 尤其不能使用<code>new</code>运算符实例化一个接口. 但我们可以声明接口的引用变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparable x;</span><br></pre></td></tr></table></figure>

<p>接口引用变量必须引用实现了接口的类的对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Employee</span>(...) <span class="comment">// Employee implements Comparable</span></span><br></pre></td></tr></table></figure>

<p>接下来, 如同使用<code>instanceof</code>检查一个对象是否属于某个特定类一样, 也可以使用<code>instance</code>检查一个对象是否实现了某个特定的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> Comparable) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>域可以建立类的继承关系一样, 接口也可以被扩展. 这里与允许存在多条从具有较高通用性的接口到较高专用性接口的链. 例如, 假设有一个称为<code>Moveable</code>的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, 可以以它为基础扩展一个叫做<code>Powered</code>的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在接口中不能包含实例域或静态方法, 但可以包含常量. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">SPEED_LIMIT</span> <span class="operator">=</span> <span class="number">95</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与接口中的方法都自动被设置为<code>public</code>一样, 接口中的域将被自动设为<code>public static final</code>.</p>
<p>有些接口中只定义了常量, 没有定义方法. 这样有助于在实现了该类接口的类中方便地调用常量. 但这样应用接口似乎有些偏离了接口概念的初衷, 不推荐这样使用.</p>
<p>尽管每个类都只能有一个超类, 但是可以同时实现多个接口. 这为定义类的行为提供了极大的灵活性.</p>
<h4 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h4><p>在本节中, 我们将重点论述抽象类与接口的区别.</p>
<p>我们在前面提出过一个疑问: 为什么Java要引入接口的概念? 为什么不将<code>Comparable</code>直接设计成如下所示的抽象类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后, <code>Employee</code>类再直接继承这个抽象类, 并提供<code>compareTo()</code>方法的实现呢?</p>
<p>主要原因是每个类只能继承一个类. 如果<code>Employee</code>类已经继承了一个类, 我们就不能再让它继承其他类; 但每个类可以实现多个接口, 如此就足够了.</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在Java SE 8中, 允许在接口中增加静态方法. 理论上讲, 没有任何理由认为这是违法的——它只是有悖于接口作为抽象规范的初衷.</p>
<p>目前为止, 通常的做法都是将静态方法放在伴随类中. 在标准库中有着各式各样的接口和实用工具类, 如<code>Collection</code>&#x2F;<code>Collections</code>或<code>Path</code>&#x2F;<code>Paths</code>.</p>
<p>以<code>Paths</code>类为例, 其中只包含两个工厂方法. 可以由一个字符串序列构造一个文件或目录的路径, 如<code>Path.get(&quot;jdk 1.8.0&quot;, &quot;jre&quot;, &quot;bin&quot;)</code>. 在Java SE 8中, 可以为<code>Path</code>接口增加以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">get</span><span class="params">(String first, String... more)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystem.getDefault().getPath(first, more);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来, <code>Paths</code>类就不是必要的了.</p>
<p>不过, 将整个<code>Java</code>库都以这种方式重构也是不太可能的. 但在实现我们自己的接口时, 不需要为实用工具另外提供一个伴随类.</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口方法提供一个默认实现. 必须用<code>default</code>修饰符标记这样一个方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span> &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话, 默认方法并没有太大的用处, 因为最终每个<code>Comparable</code>的每一个实际实现都要覆盖掉这个默认方法. 但在某些情况下, 默认方法会发挥它的作用. 例如, 在Java事件处理中, 如果希望在发生鼠标点击事件时得到通知, 就要实现一个包含五个方法的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大多数情况下, 我们都只关心其中的一两个事件类型. 在Java SE 8中, 可以将所有方法都声明为默认方法. 这些默认方法什么都不做:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseListener</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent event)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来, 我们就只需要实现我们关心的方法就可以了.</p>
<p>默认方法的另一个重要用法为”<strong>接口演化</strong>“(interface evolution). 以<code>Collection</code>接口为例, 这个接口作为Java的一部分已经有很多年了. 假设我们很久以前写了一个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span> <span class="keyword">implements</span> <span class="title class_">Collection</span></span><br></pre></td></tr></table></figure>

<p>后来, 我们又在Java SE 8中为该接口增加了一个<code>stream</code>方法. 如果这个<code>stream</code>方法不是一个默认方法, 则<code>Bag</code>类就不能编译, 因为他没有实现这个新方法. 为接口增加以恶非默认方法不能保证”源代码兼容”(source compatible).</p>
<p>不过, 假设不重新编译一个类, 而是使用原先的一个JAR文件, 这个类依旧能够正常加载. 不过, 如果程序在一个<code>Bag</code>实例上调用<code>stream</code>方法, 就会出现一个<code>AbstractMethodError</code>.</p>
<p>将方法实现一个默认方法就可以解决这两个问题. 此外, 如果没有重新编译而直接加载这个类, 并在一个<code>Bag</code>实例上调用<code>stream</code>方法, 将调用<code>Collection.stream()</code>方法.</p>
<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>如果现在一个接口中将一个方法定义为默认方法, 然后又在父类或另一个接口中定义了同样的方法, 会发生什么情况? 对于这种情况, Java有着如下规定:</p>
<ol>
<li>父类优先: 如果父类提供了一个具体方法, 同名而且有相同参数类型的默认方法会被忽略;</li>
<li>接口冲突: 如果一个父接口提供了一个默认方法, 另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法, 必须覆盖这个方法来解决冲突.</li>
</ol>
<p>我们来研究一下第二个规则. 考虑另一个包含<code>getName()</code>方法的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;_&quot;</span> + hashCode();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有一个类同时实现了这两个接口会怎么样呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Named &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类会继承<code>Person</code>和<code>Named</code>接口提供的两个不一致的<code>getName()</code>方法. 我们只需要在<code>Student</code>类中提供一个<code>getName()</code>方法. 在这个方法中, 可以选择两个冲突方法中的一个, 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Named &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;<span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们假设<code>Named</code>接口没有为<code>getName()</code>提供默认实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code>类会从<code>Person</code>接口继承默认方法吗? 不会的. Java更强调一致性. 两个接口是如何冲突的并不重要, 如果至少有一个接口提供了一个实现, 编译器就会报告错误, 而我们就必须解决这个二义性.</p>
<p>如果两个接口都没有为共享方法提供默认实现, 那么就与Java SE 8之前的情况一样, 不存在冲突. 实现类可以有两个选择: 实现这个方法, 或者干脆不实现. 如果是后一种情况, 这个类本身就是抽象的.</p>
<p>现在来讨论另外一种情况: 一个类继承了父类, 同时又实现了一个接口, 并从父类和接口继承了相同的方法. 例如, 假设<code>Person</code>是一个类, <code>Student</code>定义为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Named</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下, 编译器只会考虑父类方法, 所有接口的默认方法都将被忽略. 这就是”类优先”原则.</p>
<p>“类优先”原则有助于确保程序与Java SE 7间的兼容性. 如果为一个接口增加默认方法, 这对于这个默认方法之前能够正常工作的代码不会有任何影响.</p>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><p>在接下来的三节中, 我们将学习接口的另外一些示例, 并从中进一步学习接口的实际使用.</p>
<h4 id="接口与回调"><a href="#接口与回调" class="headerlink" title="接口与回调"></a>接口与回调</h4><p>回调(callback)是一种常见的程序设计模式. 在这种模式中, 可以指出某个特定事件发生时应该采取的动作. 例如, 可以指出在按下鼠标或选择某个菜单项时应该采取什么行动. 然而, 由于我们还没有将接口部分介绍完, 所以我们只能讨论一些与上述功能类似且并简化的版本.</p>
<p>在<code>java.swing</code>包中有一个<code>Timer</code>类. 它可以在到达给定的时间间隔时发出通告. 例如, 加入程序中有一个时钟, 就可以请求每秒钟获得一个通告, 以便更新时钟的表盘.</p>
<p>在构造定时器时, 我们需要设置一个时间间隔, 并告知计时器, 当达到时间间隔时需要做些什么操作.</p>
<p>如何告知定时器做什么呢? 在Java中, 我们将某个类的对象传递给定时器, 然后定时器调用这个对象的方法. 由于对象可以携带一些附加的信息, 所以传递一个对象比传递一个函数要灵活的得多.</p>
<p>当然, 定时器需要知道调用哪一个方法, 并要求传递的对象所属的类实现了<code>java.awt.event</code>包的<code>ActionListener</code>接口. 下面是这个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当达到指定的时间间隔时, 定时器就调用<code>actionPerformed()</code>方法.</p>
<p>假设希望每隔10秒钟打印一条信息”At the tone, the time is …”, 然后响一声, 就应该定义一个实现<code>ActionListener</code>接口的类, 然后将需要执行的语句放在<code>actionPerformed()</code>方法中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来, 构造这个类的一个对象, 并将它传递给<code>Timer</code>构造器.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br></pre></td></tr></table></figure>

<p>其中, <code>Timer</code>构造器的第一个参数是发出通告的时间间隔, 单位为毫秒; 第二个参数是监听器对象.</p>
<p>最后, 启动定时器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>于是, 我们就编写了一个每隔一秒显示一次当前时间并振铃的程序.</p>
<p>在下面的程序中, 我们给出了定时器和监听器的操作行为. 在定时器启动后, 程序将弹出一个消息对话框, 并等待用户点击OK按钮来终止程序的执行. 在程序等待用户操作的同时, 每隔10秒钟显示一次当前的时间.</p>
<p>需要注意的是, 该程序除了导入<code>javax.swing.*</code>和<code>java.util.*</code>外, 还通过类名导入了<code>javax.swing.Timer</code>. 这就消除了<code>javax.swing.Timer</code>与<code>java.util.Timer</code>之间的二义性, 其中, 后者是一个与本例无关的类, 主要负责调度后台任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerPrinter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit program&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimerPrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a><code>Comparator</code>接口</h4><p>在<a href="#%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5">先前</a>我们已经了解了如何对一个<code>ArrayList</code>排序, 前提是这些对象是实现了<code>Comparable</code>接口的类实例.</p>
<p>现在假设我们希望按长度递增的顺序对字符串进行排序, 而不是按字典顺序进行排序. 由于我们不可能对<code>String</code>类做出任何修改, 故我们需要另辟蹊径.</p>
<p><code>Array.sort()</code>方法还有第二个版本, 以一个数组和一个比较器(comparator)作为参数. 比较器是实现了<code>Comparator</code>接口的类的实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T first, T second)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要按照长度比较字符串, 则可以定义一个以如下方式实现<code>Comparator&lt;String&gt;</code>的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体完成比较时, 我们需要建立一个实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = <span class="keyword">new</span> <span class="title class_">LengthComparator</span>();</span><br><span class="line"><span class="keyword">if</span> (comp.compare(words[i], words[j] &gt; <span class="number">0</span>)) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>该方法与<code>words[i].compareTo(words[j])</code>做比较. 这个<code>compare</code>方法要在比较器对象上调用, 而不是在字符串对象本身上调用.</p>
<h4 id="对象克隆——Cloneable接口"><a href="#对象克隆——Cloneable接口" class="headerlink" title="对象克隆——Cloneable接口"></a>对象克隆——<code>Cloneable</code>接口</h4><p>鸽了.</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><h4 id="为什么引入lambda表达式"><a href="#为什么引入lambda表达式" class="headerlink" title="为什么引入lambda表达式"></a>为什么引入lambda表达式</h4><p>lambda表达式是一个可传递的代码块, 可以在以后执行一次或多次.</p>
<p>在<a href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83">前面的章节中</a>我们已经了解了如何按指定时间间隔完成工作. 将这个工作放在<code>ActionListener</code>的<code>actionPerformed()</code>方法中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在想要反复执行这个代码时, 可以构造<code>Worker</code>类的一个实例, 然后将这个实例提交到一个<code>Timer</code>对象. 这里的重点是<code>actionPerformed()</code>方法包含希望以后执行的代码.</p>
<p>或者可以考虑如何用一个定制比较器完成排序. 如果想按长度而不是默认的字典顺序对字符串排序, 可以向<code>sort()</code>方法传入一个<code>Comparator</code>对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String first, String second)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first.length() - second.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Arrays.sort(string, <span class="keyword">new</span> <span class="title class_">LengthComparator</span>());</span><br></pre></td></tr></table></figure>

<p><code>comparator()</code>方法并不会被立即调用. 实际上, 在数组完成排序之前, <code>sort()</code>方法会一直调用<code>compare()</code>方法, 只要元素的顺序不正确就会重新排列元素. 将比较元素所需的代码段放在<code>sort()</code>方法中, 这个代码与其余的排序逻辑继承.</p>
<p>这两个例子有一些二共同点, 即都是将一个代码块传递到某个对象(一个定时器, 或者一个<code>sort()</code>方法). 这个代码块会在将来某个时间调用.</p>
<p>到目前为止, 在Java中传递一个代码段并不容易, 不能直接传递代码段, 毕竟Java是一种面向对象的语言. 所以必须构造一个对象, 这个对象的类需要有一个方法能包含所需的代码. 但是, lambda表达式解决了这个问题.</p>
<h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h4><p>再考虑上一节讨论的例子. 在<code>compare()</code>方法中, 我们需要实现计算:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p><code>first</code>和<code>second</code>是什么? 它们都是字符串. Java是一种类型语言, 所以我们还需要指定它们的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second)</span><br><span class="line">    -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>这就是我们编写的第一个lambda表达式. lambda表达式就是一个代码块, 以及必须传入代码的变量规范. 其编写规范为: 参数, 箭头(<code>-&gt;</code>)以及一个表达式. 如果代码要完成的计算无法放在一个表达式中, 就可以像写方法一样, 把这些代码放在<code>&#123;&#125;</code>中, 并包含显式的<code>return</code>语句. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.length() &lt; second.length()&gt;) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (first.length() &gt; second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 如果一个lambda表达式只在某些分支中返回一个值, 而在另外一些分支不返回值, 这是不合法的.</p>
</blockquote>
<p>即使lambda表达式没有参数, 仍然要提供空括号, 就像无参数方法一样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">0</span>; i--) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以推导出一个lambda表达式的参数类型, 则可以忽略其类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>在这里, 编译器可以推导出<code>first</code>和<code>second</code>必然是字符串, 因为这个lambda表达式将赋给一个字符串比较器.</p>
<p>如果方法只有一个参数, 而且这个参数的类型可以推到得出, 那么甚至还可以忽略小括号:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">    System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>

<p>无需指定lambda表达式的返回类型. lambda表达式的返回类型总是会由上下文推导得出. 例如, 下面的表达式可以在需要<code>int</code>类型结果的上下文中使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first, String second) -&gt; first.length() - second.length()</span><br></pre></td></tr></table></figure>

<p>下面程序中的程序显示了如何在一个比较器和一个动作监听器中使用lambda表达式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] planets = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>,</span><br><span class="line">                                         <span class="string">&quot;Mars&quot;</span>, <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>,</span><br><span class="line">                                         <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted in dictionary order:&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(planets);</span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by length:&quot;</span>);</span><br><span class="line">        Arrays.sort(planets, (first, second) -&gt; first.length() - second.length());</span><br><span class="line">        System.out.println(Arrays.toString(planets));</span><br><span class="line">        </span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">100</span>, event -&gt; System.out.println(<span class="string">&quot;The time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit program&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>lambda表达式与接口是兼容的. 对于哪些只有一个抽象方法的接口, 需要这种接口的对象时, 就可以提供一个lambda表达式. 这种接口称为函数式接口(function interface).</p>
<p>为了展示如何转换为函数式接口, 下面考虑<code>Arrays.sort()</code>方法. 它的第二个参数需要一个<code>Comparator</code>实例, <code>Comparator</code>就是只有一个方法的接口, 所以可以提供一个lambda表达式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words, (first, second) - &gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>

<p>在底层, <code>Arrays.sort()</code>方法会接收实现了<code>Comparator&lt;String&gt;</code>的某个类的对象. 在这个对象上调用<code>compare()</code>方法会执行这个lambda表达式的体. 这些对象和类的管理完全取决于具体实现, 与使用传统的内联类相比, 这样可能会高效许多. 我们可以将lambda表达式看作是一个函数, 而不是一个对象; 另外要接收lambda表达式可以传递到函数式接口, 这让lambda表达式很有吸引力. 具体的实现语法很简单, 下面就是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与使用实现了<code>ActionListener</code>接口的类相比, 这个代码的可读性要好得多.</p>
<p>实际上, 这就是Java中lambda表达式的上限了.</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>有时, 可能已经有现成的方法可以完成我们想要传递到其他代码的某个动作. 例如, 假设我们希望只要出现一个定时器事件就打印这个事件对象. 当然, 为此也可以调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure>

<p>但是, 如果直接把<code>println()</code>方法传递到<code>Timer</code>构造函数就好了. 实现方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, System.out::println);</span><br></pre></td></tr></table></figure>

<p>表达式<code>System.out::println</code>是一个方法引用(method reference), 它等价于lambda表达式<code>x -&gt; System.out.println(x)</code>.</p>
<h4 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h4><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h4><h4 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈<code>Comparator</code></h4><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类是定义在另一个类中的类. 为什么需要使用内部类呢? 其主要原因有以下三点:</p>
<ol>
<li>内部类方法可以访问该定义所在的作用域中的数据, 包括私有的数据;</li>
<li>内部类可以对同一个包中的其他类隐藏起来;</li>
<li>当想要定义一个回调函数且不想编写大量代码时, 使用匿名(anonymous)内部类比较便捷.</li>
</ol>
<h4 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h4><p>内部类的语法比较复杂, 故我们选择用一个简单但不太实用的例子说明内部类的使用方法. 下面将进一步分析<code>TimerTest</code>示例, 并抽象出一个<code>TalkingClock</code>类. 构造一个语音时钟时需要提供两个参数: 发布通告的间隔和开关铃声的标志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkingClock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkingClock</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 并不是每一个<code>TalkingClock</code>对象中都有一个<code>TimePrinter</code>实例域. 只有在<code>TalkingClock</code>类中的方法构造了后它才存在.</p>
<p>下面是<code>TimePrinter</code>类的详细内容. 需要注意一点: <code>actionPerformer()</code>方法在发出铃声之前检查了<code>beep</code>标志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerPrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ActionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>令人惊讶的事情发生了: 按理来说, <code>TimePrinter</code>类没有实例域或者名为<code>beep</code>的变量, 但<code>TimePrinter</code>中的方法还是调用了这个变量. 但真正令人惊讶的是, <strong>正是</strong><code>beep</code><strong>引用创建了</strong><code>TalkingClock</code><strong>对象中</strong><code>TimePrinter</code><strong>的域</strong>. 内部类既可以访问自身的数据域, 也可以访问创建它的外围类对象的数据域.</p>
<p>为了能够实现这个功能, 内部类的对象中总有一个隐式引用, 它指向了创建它的外部类对象.</p>
<p>外围类的的引用在构造函数中设置. 编译器修改了所有的内部类的构造函数, 添加一个外围类引用的参数. 因为<code>TimePrinter</code>类没有定义构造器, 所以编译器为这个类生成了一个默认的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TimerPrinter</span><span class="params">(TalkingClock clock)</span> &#123;</span><br><span class="line">    outer = clock;  <span class="comment">// 这里的outer是为了讲解方便而设置的引用. 实际编写的程序中没有这个东西</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面讨论一下内部类的访问权限问题. 如果有一个常规的<code>TimePrinter</code>类, 它需要调用<code>TalkingClock</code>类的公用方法访问变量<code>beep</code>; 但要是使用了内部类, 我们就不需要提供能够被公开访问的方法了.</p>
<p>下面是一个测试内部类的完整程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">innerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TalkingClock</span> <span class="variable">clock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TalkingClock</span>(<span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line">        clock.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;Quit Program?&quot;</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TalkingClock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> interval;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> beep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TalkingClock</span><span class="params">(<span class="type">int</span> interval, <span class="type">boolean</span> beep)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interval = interval;</span><br><span class="line">        <span class="built_in">this</span>.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;At the tone, the time is &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h4><p>如果想要在内部类中调用外部类引用, 我们需要使用的语法还是有些复杂的. 表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.<span class="built_in">this</span></span><br></pre></td></tr></table></figure>

<p>表示外围类引用. 例如, 可以像下面这样编写<code>TimePrinter</code>内部类的<code>actionPerformed()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (TalkingClock.<span class="built_in">this</span>.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来, 可以采用下列语法格式更加明确地编写内部对象的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>(construcion parameters)</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="built_in">this</span>.<span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br></pre></td></tr></table></figure>

<p>在这里, 最新构造的<code>TimePrinter</code>对象的外围类引用被设置为创建内部类对象的方法中的<code>this</code>引用. 这是一种最常见的情况. 通常, <code>this</code>限定词是多余的. 不过, 可以通过显式地命名将外围类引用设置为其他的对象. 比如, 如果<code>TimePrinter</code>是一个公有内部类, 对于任意的<code>TalkingClock</code>都可以构造一个<code>TimePrinter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TalkingClock</span> <span class="variable">jabberer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TalkingClock</span>(<span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line">TalkingClock.<span class="type">TimePrinter</span> <span class="variable">listener</span> <span class="operator">=</span> jabberer.<span class="keyword">new</span> <span class="title class_">TimerPrinter</span>();</span><br></pre></td></tr></table></figure>

<p>需要注意, 在外围类的作用域之外, 可以这样引用内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部类中声明的所有静态域都必须是<code>final</code>. 原因很简单: 我们希望一个静态域只有一个实例, 但对于每个外部对象, 大家会分别有一个单独的内部类实例. 如果这个域不是<code>final</code>的的话, 他可能就不是唯一的.<br>内部类中不能有<code>static</code>方法. 我们也不知道Java语言的设计者为何做出这种限制, 但是遵循就好了.</p>
</blockquote>
<h4 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h4><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><h4 id="由外部方法访问变量"><a href="#由外部方法访问变量" class="headerlink" title="由外部方法访问变量"></a>由外部方法访问变量</h4><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>本章的最后讨论一下代理(proxy). 利用代理可以在运行时创建一个实现了一组给定接口的新类. 这种功能只有在无法确定需要实现哪个接口时才有必要使用.</p>
<h2 id="异常、断言和日志"><a href="#异常、断言和日志" class="headerlink" title="异常、断言和日志"></a>异常、断言和日志</h2><p>人总会遇到错误的. 如果一个用户在运行程序期间遭遇了因程序错误或种种外部因素而导致的数据丢失, 他就有可能不会再使用这个程序了. 为了避免这类事情的发生, 至少应该做到以下几点:</p>
<ol>
<li>向用户通告错误;</li>
<li>保存所有的工作结果;</li>
<li>允许用户以妥善的形式退出程序.</li>
</ol>
<p>我们接下来就来学习如何做到这几点.</p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>大家都希望程序在出现错误时, 它能够采取一些理智的行为. 如果由于出现错误而使得欧协操作没有完成, 程序应该:</p>
<ol>
<li>返回到一种安全状态, 并能够让用户执行一些其他的命令;</li>
<li>允许用户保存所有操作的结果, 并以妥善的方式终止程序.</li>
</ol>
<p>讲真, 这并不容易. 毕竟检测(或引发)错误条件的代码通常举例那些能够让数据恢复到安全状态、或者能够保存用户的操作结果, 并正常推出程序的代码很远. 异常处理的任务就是将控制权从错误产生的位置转移到能够处理这种情况的错误处理器. 为了能够在程序中处理异常情况, 我们需要研究一下程序中可能出现的错误和问题, 以及哪类问题需要关注.</p>
<ol>
<li>用户输入错误: 除了那些不可避免的键盘输入错误外, 有些用户喜欢各行其是, 不遵循程序的要求. 例如, 假设有一个用户请求连接一个URL, 而语法却不正确. 在程序代码中应该对此进行检查, 如果没有检查, 网络层就会给出警告.</li>
<li>设备错误: 硬件并不总是那么충!성!, 也会时不时出问题;</li>
<li>物理限制: 磁盘满了, 可用存储空间已被用完;</li>
<li>代码错误: 程序方法有可能无法正确执行.</li>
</ol>
<p>对于方法中的一个错误, 传统的做法是返回一个特殊的错误码, 由调用方法分析; 但并不是在任何情况下都能够返回一个错误码的,  有可能无法明确地将有效数据与无效数据加以区分. 一个返回整型的方法就不能简单地通过返回-1表示错误, 因为-1很可能是一个完全合法的结果.</p>
<p>在Java中, 如果某个方法不能够采用正常的途径完成它的任务, 就可以通过另外一个路径退出方法. 在这种情况下, 方法并不返回任何值, 而是抛出(throw)一个封装了错误信息的对象, 方法本身也会立刻退出, 而调用这个方法的代码也无法继续执行. 取而代之的是异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler).</p>
<h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>在Java中, 异常对象都是<code>Throwable</code>类的子类. 甚至, 如果Java的内置类不够用, 用户还可以创建自己的异常类. 但需要注意的是, 虽然所有的异常都是从<code>Throwable</code>继承而来, 但是它们在下一层就立即分解为两个分支: <code>Error</code>和<code>Exception</code>.</p>
<p><code>Error</code>类层次结构描述了Java运行时系统的内部错误和资源耗尽错误. 应用程序不应该抛出这种类型的对象. 如果出现了这样的内部错误, 除了通告给用户并安全中止程序, 程序自己也做不了其他的事情了. 这种情况很少见.</p>
<p>在设计Java程序时, 需要关注<code>Exception</code>层次结构. 这个层次结构又再次分解为两个分支: 一个分支派生于<code>RuntimeException</code>, 另一个分支包含其他异常. 划分两个分支的规划是: 又程序错误导致的异常属于<code>RuntimeException</code>, 而程序本身没有问题, 但由于像I&#x2F;O错误这类问题导致的异常属于其他异常.</p>
<p>派生于<code>RuntimeException</code>的异常包含下面几种情况:</p>
<ol>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问<code>null</code>指针</li>
</ol>
<p>非<code>RuntimeException</code>的异常包括:</p>
<ol>
<li>试图在文件尾部后面读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找<code>Class</code>对象, 但这个字符串表示的类根本不存在.</li>
</ol>
<p>Java将派生于<code>Error</code>类或<code>RuntimeException</code>类的所有异常称为<strong>非受查</strong>(unchecked)异常, 并将其他所有的异常称为<strong>受查</strong>(checked)异常. 这是两个很有用的术语, 我们在后面还会频繁地用到它们.</p>
<h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>方法应该在其首部声明所有可能抛出的异常. 这样可以从首部反映出这个方法可能抛出哪类受查异常. 以<code>FileInputStream</code>类的一个构造函数的声明为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>

<p>这个声明表示这个构造函数将根据给定的<code>String</code>参数产生一个<code>FileInputStream</code>对象, 但也可能抛出一个<code>FileNotFouundException</code>异常. 如果该构造函数真的抛出了该类异常, 系统就会开始搜索异常处理器, 以便知道如何处理<code>FileNotFouundException</code>对象.</p>
<p>并不需要将所有有可能抛出的异常都进行声明. 至于何时应该使用<code>throws</code>声明异常, 何种异常值得被<code>throws</code>, 有如下四个标准可供参考:</p>
<ol>
<li>调用一个抛出受查异常的方法;</li>
<li>程序运行中发现错误, 并且利用<code>throws</code>语句抛出一个受查异常;</li>
<li>程序出现错误;</li>
<li>JVM和运行时的库出现的内部错误.</li>
</ol>
<p>如果出现前两种情况之一, 则必须告知调用该方法的程序员有可能抛出异常, 因为任何一个抛出异常的方法都有可能是一个死亡陷阱. 如果没有处理器捕获这个异常, 当前执行的现成就会结束.</p>
<p>对于那些可能被他人使用的Java方法, 应该根据<strong>异常规范</strong>(exception specification), 在方法的首部声明这个方法可能抛出的异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法有可能抛出多个受查异常类型, 那么就必须在方法的首部列出所有的异常类, 每个异常类之间用逗号隔开, 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundExceptoin, EOFException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 不需要声明Java的内部错误, 即从<code>Error</code>继承的错误. 任何程序代码都有抛出那些异常的潜能, 我们也无法控制它们.</p>
<p>同样地, 也不应该声明从<code>RuntimeException</code>继承的那些非受查异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnimation</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawImage</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException &#123;   <span class="comment">// bad style</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些运行时错误完全在我们的控制之下. 如果特别关注数组下标引发的错误, 就应该将更多的时间花费在编写正确的程序上, 而不是等着程序运行出错.</p>
<p>总而言之, 一个方法必须声明所有可能抛出的<strong>受查异常</strong>, 而非受查异常要么不受控制(<code>Error</code>), 要么应当在编写过程中避免(<code>RuntimeException</code>). 如果方法没有声明所有可能发生的受查异常, 编译器就会报错.</p>
<p>当然, 从前面的示例中也可以知道: 除了声明异常, 我们还可以捕获异常. 这样会使异常不被抛到方法之外, 也不需要<code>throws</code>规范. 稍后我们就会了解到如何决定一个异常是被捕获, 还是被抛出让其他的处理器进行处理.</p>
<blockquote>
<p>注意: 如果在子类中覆盖了父类的一个方法, 子类方法中声明的受查异常不能比父类方法声明的异常更加通用(也就是说, 子类方法中可以抛出更特定的异常, 或者根本不抛出任何异常). 这也意味着, 如果父类方法没有抛出任何受查异常, 子类方法也不能抛出任何受查异常.</p>
</blockquote>
<p>如果类中的一个方法声明将会抛出一个异常, 而这个异常是某个特定类的实例时, 则这个方法就有可能抛出一个这个类的异常, 或者这个类的任意一个子类的异常.</p>
<h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p>假设在程序代码中发生了一些很糟糕的事情: 一个名为<code>readData()</code>的方法正在读取一个首部具有下列信息的文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-length: <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>然而, 在读到733个字符之后文件就结束了. 我们认为这是一种不正常的情况, 希望抛出一个异常. 我们接下来就来研究一下如何抛出这个异常.</p>
<p>首先, 我们需要决定应该抛出什么类型的异常. 在阅读Java API文档之后我们会发现, 将上述异常归结为<code>IOException</code>下的<code>EOFException</code>是一种很好的选择. 文档将该类异常介绍为: “在输入过程中, 遇到了一个未预期的EOF(注: EOF, 即’End of File’, 指文件结尾)后的信号”. 下面是抛出异常的语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br></pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EOFException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>下面将这些代码放在一起:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">readDate</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext()) &#123;    <span class="comment">// EOF enountered</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>EOFException</code>类中还有含有一个字符串参数的构造器. 这个构造器可以更加细致的描述异常出现的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gripe</span> <span class="operator">=</span> <span class="string">&quot;Content-length: &quot;</span> + len + <span class="string">&quot;, Received: &quot;</span> + n;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>(gripe);</span><br></pre></td></tr></table></figure>

<p>综上, 我们可以看出, 对于一个已经存在的异常类, 将其抛出非常容易, 只需:</p>
<ol>
<li>找到一个合适的异常类;</li>
<li>创建这个类的一个对象;</li>
<li>将对象抛出</li>
</ol>
<p>即可. 一旦方法抛出了异常, 这个方法就不可能返回到调用者, 我们也就不必为返回的默认值或错误代码担忧.</p>
<h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>如果标准异常类库中没有能够充分描述我们问题的异常, 我们就只能自己创建处于我们自己的异常. 我们需要做的是定义一个继承了<code>Exception</code>的类, 或者继承自<code>Exception</code>子类的类. 习惯上, 定义的类应该包含两个构造函数: 一个是默认的构造器, 另一个则是带有详细描述信息的构造类(如父类<code>Throwable</code>的<code>toString()</code>方法, 其能偶打印出输入的详细信息, 对我们进行调试工作十分有用).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以抛出自己定义的异常类型了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowTest</span> &#123;</span><br><span class="line">    String <span class="title function_">readDate</span><span class="params">(BufferedReader in)</span> <span class="keyword">throws</span> FileFormatException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n &lt; len) </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileFormatException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>有些代码必须捕获异常, 而这需要进行周密的计划. 接下来我们就来介绍如何捕获异常.</p>
<h4 id="小·捕获异常"><a href="#小·捕获异常" class="headerlink" title="小·捕获异常"></a>小·捕获异常</h4><p>如果某个异常在发生时没有在任何地方进行捕获, 那程序就会中止执行, 并在控制台上打印出异常信息; 对于图形界面程序也有类似的过程.</p>
<p>想要捕获一个异常, 必须设置<code>try/catch</code>语句块. 最简单的<code>try</code>语句块如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    codes;</span><br><span class="line">    more codes;</span><br><span class="line">    more more codes;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    handler <span class="keyword">for</span> <span class="built_in">this</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>try</code>语句块中的任何代码抛出了一个在<code>catch</code>子句中说明的异常类, 那么</p>
<ol>
<li>程序将跳过<code>try</code>语句块的其余代码;</li>
<li>程序将执行<code>catch</code>子句中的处理器代码.</li>
</ol>
<p>如果在<code>try</code>语句块中的代码没有抛出任何异常, 程序将跳过<code>catch</code>子句.</p>
<p>如果方法中的任何代码抛出了一个在<code>catch</code>子句中没有声明的异常类型, 那么方法也会立刻退出.</p>
<p>下面是一个演示捕获异常的处理过程, 下面给出一个读取数据的典型代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// balabala</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然, 我们也可以不<code>catch</code>这个异常, 将异常扔给方法的使用者处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read1</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// balabalabala</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说, 我们应该捕获那些知道如何处理的异常, 而将那些不知道如何处理的异常继续进行传递. 但是, 如果编写一个覆盖父类的方法, 而这个方法有没有抛出异常, 则这个方法就只能捕获自己内部的异常.</p>
<h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><p>可在<code>try</code>语句块中捕获多个异常类型, 并针对不同类型的异常做出不同的处理.</p>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>在<code>catch</code>子句中可以再抛出一个异常, 这样做的目的是改变异常的类型. 如果开发了一个供其他程序员使用的子系统, 那么, 用于表示子系统故障的异常类型可能会产生多种解释. <code>ServletException</code>就是这样一个异常类型的例子. 执行<code>servlet</code>的代码可能不想知道发生错误的细节原因, 但希望明确地知道<code>servlet</code>是否有问题.</p>
<p>下面给出了捕获异常并将它再次抛出的基本方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the database</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里, <code>ServletException</code>用带有异常信息文本的构造函数来构造. 不过, 还有一种更好的处理方式, 并将原始异常设置为新异常的”原因”:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the database</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">se</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此, 在捕获到异常时, 就可以使用下面这条语句重新得到原始异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> se.getCause();</span><br></pre></td></tr></table></figure>

<p>强烈建议使用这种包装技术. 这样就能够让用户抛出子系统中的高级异常, 而不会丢失原始异常的细节.</p>
<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h4><p><code>finally</code>子句中的代码总是会被执行, 不论是否有异常被捕获. 这是一项很有用的语法, 尤其是在编写数据库程序的时候, 其能够确保与数据库的连接能够被恰当的关闭.</p>
<p>在下列代码中, 不论如何程序都会在最后关闭文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(...);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code>语句可以只有<code>finally</code>子句, 而没有<code>catch</code>子句.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论如何, <code>finally</code>子句中的代码都会被执行. 但是, 如果<code>try</code>子句中的代码抛出了一个异常, 必须有另外的<code>catch</code>将他捕获.</p>
<p>事实上, 我们认为在需要关闭资源时, 用这种方式使用<code>finally</code>子句是一种不错的选择.</p>
<blockquote>
<p>强烈建议解耦合<code>try/catch</code>和<code>try/finally</code>语句块. 这样可以提高代码的清晰度. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      in.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部的<code>try</code>语句块只有一个职责, 就是确保关闭输入流; 外部的<code>try</code>语句块也只有一个职责, 就是确保报告出现的错误. 这种方法除表达清晰外还有一个优点, 就是可以报告<code>finally</code>子句中出现的错误.</p>
<p>还需注意的是, 如果<code>try</code>和<code>finally</code>子句中均有<code>return</code>语句, 则<code>finally</code>子句中的<code>return</code>将覆盖掉<code>try</code>中的返回值.</p>
</blockquote>
<h4 id="带资源的try语句"><a href="#带资源的try语句" class="headerlink" title="带资源的try语句"></a>带资源的<code>try</code>语句</h4><p>对于担心因关闭资源报错而丢失更有价值的异常信息的朋友们来说, Java提供了一个很有用的快捷方式. <code>AutoCloseable</code>接口中有一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>

<p>带资源的<code>try</code>语句(try-with-resources)的最简形式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>try</code>块退出时, 程序会自动调用<code>res.close()</code>. 下面是一个典型的例子, 我们读取了一个文件中的所有单词:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        System.out.println(in.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管这个块是正常退出了, 又或是发现了一个异常, 程序都会调用<code>in.close()</code>方法, 就好像使用了<code>finally</code>块一样.</p>
<p>还可以指定多个资源. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/usr/share/dict/words&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">     <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;out.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要是需要关闭资源, 我们就应该尽可能地使用带资源的<code>try</code>语句.</p>
<h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹(stack trace)是一个方法调用过程的列表, 它包含了程序执行过程中方法调用的特定位置. 我们在前面就已经见到它, 其在Java程序正常终止时就会显示出来.</p>
<p>可以调用<code>Throwable</code>类的<code>printStackTrace()</code>方法访问堆栈轨迹的文本描述信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">t.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out));</span><br><span class="line"><span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> out.toString();</span><br></pre></td></tr></table></figure>

<p>还有一种更加灵活的<code>getStackTrace()</code>方法, 它会得到<code>StackTraaceElement</code>对象的一个数组, 并可以在我们的程序中分析这个对象数组. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement frame : frames) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StackTraceElement</code>类中含有能够获得文件名和当前执行的代码行号的方法. 同时, 其还含有能够获得类名和方法名的方法. <code>toString()</code>方法将产生一个格式化的字符串, 其中包含所获得的信息.</p>
<p>静态的<code>Thread.getAllStackTrace()</code>方法能够产生所有线程的堆栈轨迹. 下面给出使用这个方法的具体方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line"><span class="keyword">for</span> (Thread t : map.keySet()) &#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    <span class="comment">// balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个打印堆栈轨迹的例子: 如果计算<code>factorial(3)</code>, 将会打印下列内容:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">3</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">factorial(<span class="number">2</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">factorial(<span class="number">1</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">15</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.factorial(stackTrace.java:<span class="number">23</span>)</span><br><span class="line">stackTrace.main(stackTrace.java:<span class="number">9</span>)</span><br><span class="line">return <span class="number">1</span></span><br><span class="line">return <span class="number">2</span></span><br><span class="line">return <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stackTrace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;Enter n: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        </span><br><span class="line">        factorial(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factorial(&quot;</span> + n + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">        StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement f : frames) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;return &quot;</span> + r);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><p>下面是几个使用异常机制的几个技巧.</p>
<h4 id="异常处理不能代替简单的测试"><a href="#异常处理不能代替简单的测试" class="headerlink" title="异常处理不能代替简单的测试"></a>异常处理不能代替简单的测试</h4><p>以退栈操作为例: 使用<code>isEmpty()</code>方法检测一个栈是否为空所需的时间远小于”尝试进行退栈操作却发现栈为空后抛出异常再捕获”的时间. <strong>只在异常情况下使用异常机制</strong>.</p>
<h4 id="不要过分地细化异常"><a href="#不要过分地细化异常" class="headerlink" title="不要过分地细化异常"></a>不要过分地细化异常</h4><h4 id="利用异常层次结构"><a href="#利用异常层次结构" class="headerlink" title="利用异常层次结构"></a>利用异常层次结构</h4><p>不要只抛出<code>RuntimeException</code>异常. 应该寻找更加适当的子类或创建自己的异常类.</p>
<p>不要只捕获<code>Thowable</code>异常, 否则, 会使程序代码更难读、更难维护. 考虑受查异常与非受查异常的区别. 已检查异常本来就很庞大, 不要为逻辑错误抛出这些异常.</p>
<p>将一种异常转换成另一种更加适合的异常时不要犹豫. 例如, 在解析某个文件中的一个整数时, 捕获’NumberFormatException’异常, 然后将它转换成<code>IOException</code>或<code>MySubsystemException</code>的子类.</p>
<h4 id="不要压制异常"><a href="#不要压制异常" class="headerlink" title="不要压制异常"></a>不要压制异常</h4><p>在Java中, 往往强烈地倾向于关闭异常. 如果编写了一个调用另一个方法的方法, 那么另一个方法就会时刻提醒编译器其有可能抛出异常, 不论这个可能性是大是小. 如果这个要抛出的异常根本无关紧要, 我们就可以关闭这个异常:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// codes threatening to throw checked exceptions</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// shut down</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此就可以顺利编译我们的代码了. 如果运行顺利, 那就运行顺利😅; 如果抛出异常, 它也会被自动忽略. 如果认为异常十分重要, 就应该在<code>catch</code>子块中为其进行处理.</p>
<h4 id="尽早抛出出现的异常"><a href="#尽早抛出出现的异常" class="headerlink" title="尽早抛出出现的异常"></a>尽早抛出出现的异常</h4><p>在用无效的参数调用一个方法时, 返回一个虚拟的数值, 还是抛出一个异常, 哪种处理方式更好? 例如, 在栈空时, <code>Stack.pop()</code>方法是返回一个<code>null</code>, 还是抛出一个异常? 我们认为: 在出错的地方抛出一个<code>EmptyStackException</code>异常要比在后面抛出一个<code>NullPointerException</code>异常更好.</p>
<h4 id="不要羞于传递异常"><a href="#不要羞于传递异常" class="headerlink" title="不要羞于传递异常"></a>不要羞于传递异常</h4><p>有些异常应当被传递给更高层次的使用者 ,不要羞于传递它们.</p>
<h3 id="断言的使用"><a href="#断言的使用" class="headerlink" title="断言的使用"></a>断言的使用</h3><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>记录日志API能够很好地帮助我们观察程序的运行过程. 记录日志API有着如下优点:</p>
<ol>
<li>可以很容易地取消全部日志记录, 或者仅仅取消某个级别的日志, 而且打开和关闭这个操作也很容易;</li>
<li>可以很简单地禁止日志记录的输出, 因此将这些日志代码留在程序中的开销很小;</li>
<li>日志记录可以被定向到不同的处理器, 用于在控制台中显示, 用于存储在文件中等;</li>
<li>日志记录器和处理器都可以对记录进行过滤. 过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项;</li>
<li>日志记录可以采用不同的方式格式化, 例如纯文本或XML;</li>
<li>应用程序可以使用多个日志记录器, 它们使用类似包名的这种具有层次结构的名字, 例如<code>com.mycompany.myapp</code>;</li>
<li>在默认情况下, 日志系统的配置由配置文件控制. 如果需要的话, 应用程序可以替换这个配置.</li>
</ol>
<h4 id="基本日志"><a href="#基本日志" class="headerlink" title="基本日志"></a>基本日志</h4><p>要生成简单的日志记录, 我们可以使用全局日志记录器(global logger)并调用其<code>info()</code>方法 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">&quot;File-&gt;Open menu item selected&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在<code>main()</code>方法开始的地方(或者其他适当的地方)调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().serLevel(Level.OFF);</span><br></pre></td></tr></table></figure>

<p>则所有的日志均会被取消.</p>
<h4 id="高级日志"><a href="#高级日志" class="headerlink" title="高级日志"></a>高级日志</h4><h4 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h4><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><h4 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h4><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><h4 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h4><h4 id="日志记录说明"><a href="#日志记录说明" class="headerlink" title="日志记录说明"></a>日志记录说明</h4><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><h3 id="为什么要使用泛型程序设计"><a href="#为什么要使用泛型程序设计" class="headerlink" title="为什么要使用泛型程序设计"></a>为什么要使用泛型程序设计</h3><p>泛型程序设计(generic programming)意味着编写的代码可以被很多不同类型的对象使用.</p>
<p>实际上, 在Java添加泛型类之前, 其中已经有了一个<code>ArrayList</code>类. 下面我们来看一下泛型程序设计的机制是如何演变的, 并进一步体会泛型对于用户和实现者来说的意义.</p>
<h4 id="类型参数的好处"><a href="#类型参数的好处" class="headerlink" title="类型参数的好处"></a>类型参数的好处</h4><p>在Java中增加泛型类之前, 泛型程序设计是利用继承实现的. <code>ArrayList</code>类只维护一个<code>Object</code>引用的数组:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有两个问题. 在获取一个值时必须进行强制类型转换是其一; 无法对保存进<code>ArrayList</code>的对象进行错误检查是其二.</p>
<p>但是泛型能够解决这两个问题, 因为其提供了一个更好的解决方案: 类型参数(type parameters). <code>ArrayList</code>类有一个类型参数用来指示元素的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>这让我们一看就知道这个<code>ArrayList</code>中装的是<code>String</code>对象.</p>
<blockquote>
<p>在Java SE 7及以后的版本中, 构造函数可以省略泛型类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>编译器也可以知道, 从此类<code>ArrayList</code>中提取出来的元素均应为<code>String</code>对象.</p>
<p>此外, 编译器还知道<code>ArrayList&lt;String&gt;</code>中的<code>add()</code>方法中有一个类型为<code>String</code>的参数. 这比使用<code>Object</code>类型的参数安全一些.</p>
<p>这就是类型参数的魅力: 让程序具有更好的可读性和安全性.</p>
<h4 id="谁想成为泛型程序员"><a href="#谁想成为泛型程序员" class="headerlink" title="谁想成为泛型程序员"></a>谁想成为泛型程序员</h4><p>实际上, 泛型的编写工作非常困难. 绝大多数程序员只是应用泛型这一工具, 而对泛型是如何实现的知之甚少. 后面将通过定义一个简单的泛型类向大家简单介绍泛型的编写方式和运作机制. 如果想要深入理解泛型, 还需要进一步阅读其他书籍.</p>
<h3 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h3><p>一个泛型类(generic class)就是具有一个或多个类型变量的类. 本节使用一个简单的<code>Pair</code>类作为例子. 对于这个类来说, 我们只关注泛型, 对数据储存问题持无关心态度. 下面是<code>Pair</code>类的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">        second = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pair</code>类引入了一个类型变量<code>T</code>, 用尖括号(<code>&lt;&gt;</code>)括起来, 并放在类名的后面. 泛型类可以有多个类型变量. 例如, 可以定义<code>Pair</code>类, 其中第一个域和第二个域使用不同的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> lcass Pair&lt;T, U&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T first;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型变量使用大写形式, 且比较短. 这是很常见的. 在Java库中, 通常使用变量<code>E</code>表示集合的元素类型, <code>K</code>和<code>V</code>分别表示表的关键字与值的类型. <code>T</code>(需要时还可用临近的字母<code>U</code>和<code>S</code>)表示”任意类型”.</p>
</blockquote>
<p>使用具体的类型替换类型变量就可以实例化泛型类型. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;</span><br></pre></td></tr></table></figure>

<p>可以将结果想象成带有构造器的普通类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;()</span><br><span class="line">Pair&lt;String&gt;(String, String)</span><br></pre></td></tr></table></figure>

<p>和方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFirst</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">String <span class="title function_">getSecond</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serFirst</span><span class="params">(String)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(String)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说, <strong>泛型类可看作普通类的工厂</strong>.</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>前面已经介绍了如何定义一个泛型类. 实际上, 还可以定义一个带有类型参数的简单方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArralAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是在普通类中定义的, 而不是在泛型类中定义的. 然而, 这是一个泛型方法, 可以从尖括号和类型变量中看出这一点. 注意, 类型变量放在修饰符(这里是<code>public static</code>)的后面, 返回类型的前面.</p>
<p>泛型方法可以定义在普通类中, 也可以定义在泛型类中.</p>
<p>当调用一个泛型方法时, 在方法名前的尖括号中放入具体的类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下(实际上也是大多数情况下), 方法调用中可以省略<code>&lt;String&gt;</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Q.&quot;</span>, <span class="string">&quot;Public&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过偶尔也会出现一些问题, 比如下面这个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>编译器会委婉地指出, 解释这段代码有两种合法方法. 编译器通过将参数打包为一个<code>Double</code>和两个<code>Integer</code>对象, 然后共同寻找这些类的共同父类, 结果找到了两个符合条件的类: <code>Number</code>和<code>Comparable</code>接口, 其本身也是一个泛型类型. 解决方法就是将所有的参数写为<code>double</code>值.</p>
<h3 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h3><p>有时, 类或方法需要对类型变量加以约束. 下面是一个典型的例子. 我们需要计算数组中的最小元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">smallest</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="number">0</span>) smallest = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们真的这么写代码的话, 编译器会报错. 原因在于我们不能保证泛型<code>&lt;T&gt;</code>都实现了<code>Comparable</code>接口. 我们可以通过对类型变量<code>T</code>设置限定(bound)实现这一点:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>事实上, <code>Comparable</code>接口本身就是一个泛型类型. 后面会具体讨论如何在<code>Comparable</code>接口中适当的使用类型参数.</p>
<p>现在, 泛型的<code>min</code>方法就只能被实现了<code>Comparable</code>接口的类的数组调用.</p>
<p>或许各位或有些奇怪——在此为什么使用关键字<code>extends</code>而不是<code>implements</code>? 毕竟, <code>Comparable</code>是一个接口. 实际上, <code>&lt;T extends BoundingType&gt;</code>表示<code>T</code>应该是绑定类型的<strong>子类型</strong>(subtype). <code>T</code>和绑定类型既可以是类, 也可以是接口. 选择关键字<code>extends</code>的原因是更接近子类的概念, 并且Java的设计者也不打算在语言中再添加新的关键字.</p>
<p>一个类型变量或通配符可以有多个限定, 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>限定类型用<code>&amp;</code>分隔, 而逗号用来分割类型变量.</p>
<p>在Java的继承中, 可以根据需要拥有多个接口超类型, 但限定中至多有一个类. 如果用一个类作为限定, 它必须是限定列表中的第一个.</p>
<p>下面重新编写了一个泛型方法<code>minmax</code>, 用于计算泛型数组的最大值和最小值, 并返回<code>Pair&lt;T&gt;</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LocalDate[] birthdays = &#123;</span><br><span class="line">                LocalDate.of(<span class="number">1906</span>, <span class="number">12</span>, <span class="number">9</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1815</span>, <span class="number">12</span>, <span class="number">10</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1903</span>, <span class="number">12</span>, <span class="number">3</span>),</span><br><span class="line">                LocalDate.of(<span class="number">1900</span>, <span class="number">6</span>, <span class="number">22</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays);</span><br><span class="line">        System.out.println(<span class="string">&quot;min = &quot;</span> + mm.getFirst());</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + mm.getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; Pair&lt;T&gt; <span class="title function_">minmax</span><span class="params">(T[] a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">            <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(min, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型代码和虚拟机"><a href="#泛型代码和虚拟机" class="headerlink" title="泛型代码和虚拟机"></a>泛型代码和虚拟机</h3><h3 id="约束与局限性"><a href="#约束与局限性" class="headerlink" title="约束与局限性"></a>约束与局限性</h3><ol>
<li>不能用基本类型实例化类型参数</li>
<li>运行时类型查询只适用于原始类型</li>
<li>不能创建参数化类型的数组</li>
<li><code>Varargs</code>警告</li>
<li>不能实例化类型变量</li>
<li>不能构造泛型数组</li>
<li>泛型类的静态上下文中类型变量无效</li>
<li>不能抛出或捕获泛型类的实例</li>
<li>可以消除对受查异常的检查</li>
<li>注意擦除后的冲突</li>
</ol>
<h3 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h3><p>考虑一个类和子类, 如<code>Employee</code>和<code>Manager</code>, 那么<code>Pair&lt;Manager&gt;</code>和<code>Pair&lt;Employee&gt;</code>的一个子类吗? 不是的. 无论<code>S</code>与<code>T</code>之间有什么关系, 通常<code>Pair&lt;S&gt;</code>和<code>Pair&lt;T&gt;</code>之间都不会有什么联系.</p>
<h3 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h3><p>固定的泛型类型系统使用起来并没有那么令人愉快, 这一点类型系统的研究人员已经知道一段时间了. Java的设计者设计了一种巧妙且安全的”解决方案”: 通配符类型. 我们接下来就来认识一下它.</p>
<h4 id="通配符的概念"><a href="#通配符的概念" class="headerlink" title="通配符的概念"></a>通配符的概念</h4><p>通配符类型中, 允许类型参数变化. 例如, 通配符类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt;</span><br></pre></td></tr></table></figure>

<p>表示任何泛型<code>Pair</code>类型, 其类型参数应为<code>Employee</code>的子类, 如<code>Pair&lt;Manager&gt;</code>, 但不是<code>Pair&lt;String&gt;</code>.</p>
<p>假设要编写一个打印雇员对的方法, 像这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">second</span> <span class="operator">=</span> p.getSecond();</span><br><span class="line">    System.out.println(first.getName() + <span class="string">&quot; and &quot;</span> + second.getName() + <span class="string">&quot; are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述, 不能将<code>pair&lt;Manager&gt;</code>传递给这个方法. 解决方法便是使用通配符类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span><br></pre></td></tr></table></figure>

<p>类型<code>Pair&lt;Manager&gt;</code>是<code>Pair&lt;? extends Employee&gt;</code>的子类型.</p>
<h4 id="通配符的父类型限定"><a href="#通配符的父类型限定" class="headerlink" title="通配符的父类型限定"></a>通配符的父类型限定</h4><p>通配符限定于类型变量限定十分类似, 但是, 还有以恶个附加的能力, 即可以指定一个父类型限定(supertype bound), 如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="built_in">super</span> Manager</span><br></pre></td></tr></table></figure>

<p>这个通配符限制为<code>Manager</code>的所有父类型(已有的<code>super</code>关键字十分准确地描述了这种联系).</p>
<p>为什么要这样做呢? 带有超类型限定的通配符只能为方法提供参数, 而不能使用返回值.</p>
<p>下面是一个典型的示例: 有一个经理的数组, 并且想把奖金最高和最低的经理放在一个<code>Pair</code>对象中. <code>Pair</code>的类型是什么? 在这里, <code>Pair&lt;Employee&gt;</code>是合理的, <code>Pair&lt;Object&gt;</code>也是合理的. 下面的方法将可以接收任何适当的<code>Pair</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minmaxBonus</span><span class="params">(Manager[] a, Pair&lt;? <span class="built_in">super</span> Manager&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (max.getBonus() &gt; a[i].getBonus()) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直观地讲, 带有超类型的通配符可以像泛型对象写入, 带有子类型限定的通配符可以从泛型对象读取.</p>
<p>下面 是超类型限定的另一种应用. <code>Comparable</code>接口本身就是一个泛型类型. 声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此, 类型变量指示了<code>other</code>参数的类型. 例如, <code>String</code>类实现<code>Comparable&lt;String&gt;</code>, 它的<code>compareTo()</code>方法就被声明为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span></span><br></pre></td></tr></table></figure>

<p>通过在接口中使用泛型, 我们就避免了在使用<code>Object</code>类时出现的强制类型转换问题.</p>
<p>由于<code>Comparable</code>是一个泛型类型, 或许可以将<code>ArrayAlg</code>类的<code>min</code>方法做得更好一些? 可以这样声明:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure>

<p>看起来, 这样写比只使用<code>T extends Comparable</code>更彻底, 并且对许多类来讲, 工作得更好.</p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>还可以使用无限定的通配符, 例如<code>Pair&lt;?&gt;</code>. 乍看起来, 这好像与原始的<code>Pair</code>类型一样. 实际上, 有很大的不同. 类型<code>Pair&lt;?&gt;</code>有以下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? getFirst()</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(?)</span></span><br></pre></td></tr></table></figure>

<p><code>getFirst()</code>的返回值只能赋给一个<code>Object</code>. <code>setFirst()</code>方法不能被调用, 甚至不能用<code>Object</code>调用. <code>Pair&lt;?&gt;</code>和<code>Pair</code>的不同在于: 可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setObject()</code>方法.</p>
<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><h3 id="反射和泛型"><a href="#反射和泛型" class="headerlink" title="反射和泛型"></a>反射和泛型</h3><p>反射允许我们在运行时分析任意的对象. 如果对象是泛型类的实例, 关于泛型类型参数则得不到太多信息, 因为它们会被擦除. 在下面的小节中, 可以了解利用反射可以获得泛型类的什么信息.</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><h4 id="将集合的接口与实现分离"><a href="#将集合的接口与实现分离" class="headerlink" title="将集合的接口与实现分离"></a>将集合的接口与实现分离</h4><p>与现代的数据结构类库的常见情况一样, Java集合类库也将接口与实现分离. 首先, 我们看一下队列(queue)这一数据结构是如何分离的.</p>
<p>队列接口指出可以在队列的尾部添加元素, 在队列的头部删除元素, 并且可以查找队列中元素的个数. 当需要收集对象, 并按照”先进先出”的规则检索对象时就应该使用队列.</p>
<p>队列接口的最简形式可能会类似于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Quece</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口并没有说明队列是如何实现的. 队列通常有两种实现方法: 一种是使用循环数组; 另一种是使用链表. 每一个实现都可以通过一个实现了<code>Queue</code>接口的类表示.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;    <span class="comment">// not an actual library class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    CircularArrayQueue(<span class="type">int</span> capacity) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> E[] elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;   <span class="comment">// not an actual library class</span></span><br><span class="line">    <span class="keyword">private</span> link head;</span><br><span class="line">    <span class="keyword">private</span> link tail;</span><br><span class="line"></span><br><span class="line">    LinkListQueue() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在程序中使用队列时, 一旦构建了集合就不需要知道究竟使用了哪种实现. 因此, 只有在构建集合对象时, 使用具体的类才有意义. 可以使用接口类型存放集合的引用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">CircularArrayQueue</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>利用这种方法, 一旦改变了想法, 就可以轻松地使用另外一种不同的实现. 只需要对程序的一个地方做出修改, 即调用构造器的地方. 如果觉得<code>LinkedListQueue</code>是个更好的选择, 就可以将代码修改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Customer&gt; expressLane = <span class="keyword">new</span> <span class="title class_">LinkedListQueue</span>&lt;&gt;();</span><br><span class="line">expressLane.add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Harry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>为什么选择这种实现, 而不选择另一种实现呢? 接口本身并不能说明哪种实现的效率究竟如何. 循环数组比链表要高效, 因此多数人优先选择循环数组. 然而, 通常这样做也需要付出一定的代价.</p>
<p>循环数组是一个有限集合, 容量有限; 如果程序中要收集的对象数量没有上限, 则最好使用链表来实现.</p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h4><p>在Java类库中, 集合类的基本接口是<code>Collection</code>接口. 这个接口有两个基本方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这两个方法外, 还有几个方法, 稍后会继续介绍.</p>
<p><code>add()</code>方法用于向集合中添加元素. 如果添加元素确实改变了结合, 就返回<code>true</code>; 反之, 则返回<code>false</code>. 例如, 如果试图向集合中添加一个对象, 而这个对象在集合中已经存在, 这个添加请求就没有实效, 因为集合中不允许有重复的对象.</p>
<p><code>iterator()</code>方法用于返回一个实现了<code>Iterator</code>接口的对象. 可以使用这个迭代器对象依次访问集合中的元素.</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>Iterator</code>接口包含四个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consermer&lt;? <span class="built_in">super</span> E&gt; action)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反复调用<code>next()</code>方法, 可以逐个访问集合中的每个元素. 不过在调用之前, 还是需要使用<code>hasNext()</code>方法来检验是否可以继续执行<code>next()</code>方法. 如果想要查看集合中的所有元素, 就请求一个迭代器, 并在<code>hasNext()</code>返回<code>true</code>时反复地调用<code>next()</code>方法. 例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>for each</code>循环可以更加简练地表示同样的循环操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : c) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将<code>for each</code>循环简单地翻译为带有迭代器的循环.</p>
<p><code>for each</code>循环可以与任何实现了<code>Iterable</code>接口的对象一起工作, 这个接口只有一个抽象方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Collection</code>接口扩展了<code>Iterable</code>接口. 因此, 对于标准类库中的任何集合都可以使用<code>for each</code>循环.</p>
<h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>数组的储存方式为在连续的存储位置上存放对象引用, 而<strong>链表</strong>则将对象存放在独立的结点中. 每个节点还存放着序列中下一个节点的引用. 在Java程序设计语言中, 所有链表实际上都是双向链接的, 即每个节点还存放着向前驱节点的引用.</p>
<p>由此, 从链表中间删除一个元素是一件很轻松的事情, 仅需要更新被删除元素附近的链接即可.</p>
<p>在下面的代码示例中, 先添加三个元素, 然后再将第二个元素删除:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">staff.add(<span class="string">&quot;Amy&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;Carl&quot;</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> staff.iterator();</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> iter.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> iter.next();</span><br><span class="line">iter.remove();</span><br></pre></td></tr></table></figure>

<p>但是, 链表与泛型集合之间的最大区别, 就是链表是一个<strong>有序集合</strong>. 这意味着每个队形的位置十分重要.</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2></div><div class="article-licensing box"><div class="licensing-title"><p>Java核心技术卷1</p><p><a href="http://example.com/2022/06/19/Java核心技术卷1/">http://example.com/2022/06/19/Java核心技术卷1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Arnold Miao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-06-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-06-27</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">算法入门</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/06/12/java/"><span class="level-item">Java学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Arnold Miao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Arnold Miao</p><p class="is-size-6 is-block">Learner</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China, Asia</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-11T00:53:31.000Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/%E3%80%8A%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E7%9A%84%E5%B4%87%E9%AB%98%E5%AE%A2%E4%BD%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《意识形态的崇高客体》读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-09T05:23:28.000Z">2022-07-09</time></p><p class="title"><a href="/2022/07/09/MySQL%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">MySQL自学笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-09T02:18:36.000Z">2022-07-09</time></p><p class="title"><a href="/2022/07/09/%E5%9B%BE%E8%A7%A3HTTP/">图解HTTP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-28T02:32:59.000Z">2022-06-28</time></p><p class="title"><a href="/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">算法入门</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-19T06:29:11.000Z">2022-06-19</time></p><p class="title"><a href="/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/">Java核心技术卷1</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 Arnold Miao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>