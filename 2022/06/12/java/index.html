<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java学习笔记 - 小苗的个人博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="小苗的个人博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小苗的个人博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="基本概念Java的工作方式Java的目标是写出一个能在任何设备上运行的应用程序. 源代码编写源代码文件. 编译器用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出. 输出编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关. Java虚拟机(JVM)通过Java虚拟机可以读取和执行字节码. 要做的事编写源代码文件, 用jav"><meta property="og:type" content="blog"><meta property="og:title" content="Java学习笔记"><meta property="og:url" content="http://example.com/2022/06/12/java/"><meta property="og:site_name" content="小苗的个人博客"><meta property="og:description" content="基本概念Java的工作方式Java的目标是写出一个能在任何设备上运行的应用程序. 源代码编写源代码文件. 编译器用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出. 输出编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关. Java虚拟机(JVM)通过Java虚拟机可以读取和执行字节码. 要做的事编写源代码文件, 用jav"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:published_time" content="2022-06-12T13:12:09.000Z"><meta property="article:modified_time" content="2022-06-19T06:29:31.430Z"><meta property="article:author" content="Arnold Miao"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/06/12/java/"},"headline":"Java学习笔记","image":["http://example.com/img/og_image.png"],"datePublished":"2022-06-12T13:12:09.000Z","dateModified":"2022-06-19T06:29:31.430Z","author":{"@type":"Person","name":"Arnold Miao"},"publisher":{"@type":"Organization","name":"小苗的个人博客","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"基本概念Java的工作方式Java的目标是写出一个能在任何设备上运行的应用程序. 源代码编写源代码文件. 编译器用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出. 输出编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关. Java虚拟机(JVM)通过Java虚拟机可以读取和执行字节码. 要做的事编写源代码文件, 用jav"}</script><link rel="canonical" href="http://example.com/2022/06/12/java/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-12T13:12:09.000Z" title="2022/6/12 21:12:09">2022-06-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-19T06:29:31.430Z" title="2022/6/19 14:29:31">2022-06-19</time></span><span class="level-item">2 hours read (About 21150 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java学习笔记</h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Java的工作方式"><a href="#Java的工作方式" class="headerlink" title="Java的工作方式"></a>Java的工作方式</h3><p>Java的目标是写出一个能在任何设备上运行的应用程序.</p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>编写源代码文件.</p>
<h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>用编译器运行源代码. 编译器会检查错误, 如果有就要改正, 以获得正确的输出.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>编译器会产出字节码. 任何支持Java的装置都能够把它转译为可执行的内容. 编译后的字节码与平台无关.</p>
<h4 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机(JVM)"></a>Java虚拟机(JVM)</h4><p>通过Java虚拟机可以读取和执行字节码.</p>
<h3 id="要做的事"><a href="#要做的事" class="headerlink" title="要做的事"></a>要做的事</h3><p>编写源代码文件, 用javac编译程序, 并在某个Java虚拟机上执行编译过的字节码.</p>
<h3 id="Java的程序结构"><a href="#Java的程序结构" class="headerlink" title="Java的程序结构"></a>Java的程序结构</h3><p><strong>类</strong>存放在<strong>源文件</strong>中; <strong>方法</strong>存放在<strong>类</strong>中; <strong>语句</strong>存放在<strong>方法</strong>中.</p>
<h4 id="什么是源文件"><a href="#什么是源文件" class="headerlink" title="什么是源文件"></a>什么是源文件</h4><p>源文件(扩展名为<code>.java</code>)带有类的定义. 类用来表示程序的一个组件. 先程序或许只会有一个类. 类的内容必须包在花括号里面.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildInvite</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Frame</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">        <span class="type">Label</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Party at Tim&#x27;s!&quot;</span>);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;You bet&quot;</span>);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Shoot me&quot;</span>);</span><br><span class="line">        <span class="type">Panel</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Panel</span>();</span><br><span class="line">        p.add(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h4><p>类中带有一个或多个方法. 方法必须在类的内部声明.</p>
<h4 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h4><p>在方法的花括号中编写方法应该执行的指令. 方法代码是由一组语句所组成的, 可以把方法想象成是一个函数或过程.</p>
<h3 id="剖析类"><a href="#剖析类" class="headerlink" title="剖析类"></a>剖析类</h3><p>当Java虚拟机启动执行时, 它会寻找你在命令列所制定的类. 然后它会锁定一个向下面这样一个特定的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着Java虚拟机就会执行<code>main</code>方法在花括号间的所有指令. 每个Java程序可能会有很多类, 但是<code>main()</code>函数只能有一个.</p>
<h3 id="编写带有main-的类"><a href="#编写带有main-的类" class="headerlink" title="编写带有main()的类"></a>编写带有<code>main()</code>的类</h3><p>在Java中的所有东西都会属于某个类, 而<code>main()</code>是程序的七点. 不管有多少个类, 一定都会有一个<code>main()</code>来作为程序的起点.</p>
<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MyFirstApp.java</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><h3 id="main-中的常见方法"><a href="#main-中的常见方法" class="headerlink" title="main()中的常见方法"></a><code>main()</code>中的常见方法</h3><h4 id="声明、设定、调用方法等普通语句"><a href="#声明、设定、调用方法等普通语句" class="headerlink" title="声明、设定、调用方法等普通语句"></a>声明、设定、调用方法等普通语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Dirk&quot;</span>;</span><br><span class="line">x = x * <span class="number">17</span>;</span><br><span class="line">System.out.print(<span class="string">&quot;x is &quot;</span> + x);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="comment">// 注释</span></span><br></pre></td></tr></table></figure>

<h4 id="反复做某事"><a href="#反复做某事" class="headerlink" title="反复做某事"></a>反复做某事</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">12</span>) &#123;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x = x + <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x is now &quot;</span> + x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在适当条件下做某件事"><a href="#在适当条件下做某件事" class="headerlink" title="在适当条件下做某件事"></a>在适当条件下做某件事</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x must be 10&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x isn&#x27;t 10&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((x &lt; <span class="number">3</span>) &amp; (name.equals(<span class="string">&quot;Dirk&quot;</span>))) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Gently&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;this line runs no matter what&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="重复与循环"><a href="#重复与循环" class="headerlink" title="重复与循环"></a>重复与循环</h3><p>Java中有三种循环结构: while循环、do-while循环和for循环. 我们先从while循环介绍起.</p>
<p>循环的关键在于条件测试. 在Java中, 条件测试的结果是<code>boolean</code>值——不是<code>true</code>就是<code>false</code>.</p>
<p>可以用<strong>比较运算符</strong>来执行简单的<code>boolean</code>值测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环能够顺利运行</span></span><br><span class="line">    <span class="comment">// 因为x确实大于3</span></span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> z= <span class="number">27</span>;</span><br><span class="line"><span class="keyword">while</span> (z == <span class="number">17</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环不能顺利运行</span></span><br><span class="line">    <span class="comment">// 因为z不等于17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他语言不同, Java中的<code>integer</code>与<code>boolean</code>两种类型并不相容, 故不能写出形如<code>while (i) &#123;...&#125;</code>之类的代码.</p>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>在Java中<code>if</code>与<code>while</code>循环都是<code>boolean</code>测试, 但功能不同.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x must be 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This runs no matter what&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以在程序中加入<code>else</code>条件, 实现真正的条件选择.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x must be 3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x is NOT 3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This runs no matter what&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开始编写程序——专家术语生成器"><a href="#开始编写程序——专家术语生成器" class="headerlink" title="开始编写程序——专家术语生成器"></a>开始编写程序——专家术语生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Party</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] wordListOne = &#123;&#125;;</span><br><span class="line">        String[] wordListTwo = &#123;&#125;;</span><br><span class="line">        String[] wordListThree = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">oneLength</span> <span class="operator">=</span> wordListOne.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">twoLength</span> <span class="operator">=</span> wordListTwo.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threeLength</span> <span class="operator">=</span> wordListThree.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">rand1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * oneLength);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rand2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * twoLength);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rand3</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * threeLength);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">phrase</span> <span class="operator">=</span> wordListOne[rand1] + <span class="string">&quot; &quot;</span> + wordListTwo[rand2] + <span class="string">&quot; &quot;</span> + wordListThree[rand3];</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;What we need is a &quot;</span> + phrase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String数组"><a href="#String数组" class="headerlink" title="String数组"></a><code>String</code>数组</h4><p>编写该程序的第一步是创建出三个<code>String</code>数组, 也即保存术语的容器. 数组的声明和创建是很简单的, 下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] pets = &#123;<span class="string">&quot;Fido&quot;</span>, <span class="string">&quot;Zeus&quot;</span>, <span class="string">&quot;Bin&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>每个元素放在引号中, 彼此间应以逗号隔开.</p>
<h4 id="数组长度获取"><a href="#数组长度获取" class="headerlink" title="数组长度获取"></a>数组长度获取</h4><p>为了在每个数组中能够随机地跳出一个单字, 我们需要得知每个数组的大小. 我们可以直接”询问”数组其长度:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> pets.length;</span><br></pre></td></tr></table></figure>

<p>执行后, <code>x</code>的值为3.</p>
<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p>我们需要三个随机数. Java本身有一组立即可用的数学方法. <code>random()</code>方法会返回<strong>介于0和1之间</strong>的值, 所以我们呢需要将此值乘以数组的元素数量, 之后再取证.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">24.6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="组合字符串"><a href="#组合字符串" class="headerlink" title="组合字符串"></a>组合字符串</h4><p>我们可以用”<code>+</code>“运算符将字符串对象连接在一起. 使用索引数字可以将数组中的元素提取出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> pets[<span class="number">0</span>]; <span class="comment">// &quot;Fido&quot;</span></span><br><span class="line">s = s + <span class="string">&quot;&quot;</span> + <span class="string">&quot;is a dog!&quot;</span>; <span class="comment">// &quot;Fido is a dog!&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="输出到屏幕"><a href="#输出到屏幕" class="headerlink" title="输出到屏幕"></a>输出到屏幕</h4><p>最后, 我们将结果输出到命令列上即可.</p>
<h2 id="拜访对象村"><a href="#拜访对象村" class="headerlink" title="拜访对象村"></a>拜访对象村</h2><p>我们要离开过程化的世界, 开始建立自己的对象.</p>
<h3 id="以对象来思考"><a href="#以对象来思考" class="headerlink" title="以对象来思考"></a>以对象来思考</h3><p>当我们设计类时, 要记得<strong>对象是靠类的模型塑造出来的</strong>, 即:</p>
<ol>
<li>对象是已知的事物</li>
<li>对象会执行的动作</li>
</ol>
<p>其中, <strong>对象本身已知的事物</strong>被称为<strong>实例变量(instance variable)</strong>, <strong>对象可以执行的动作</strong>被称为<strong>方法(methods)</strong>.</p>
<p>总而言之, <strong>类是对象的蓝图</strong>.</p>
<h3 id="创建你的第一个对象"><a href="#创建你的第一个对象" class="headerlink" title="创建你的第一个对象"></a>创建你的第一个对象</h3><p>要做到”会运用对象”, 我们需要两个类, 一个是被操作与对象的类, 另一个是用来测试该类的类. 后者常被命名为”受测类名称” + <code>TestDrive</code>.</p>
<h4 id="编写类"><a href="#编写类" class="headerlink" title="编写类"></a>编写类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    String breed;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ruff! Ruff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写测试用类"><a href="#编写测试用类" class="headerlink" title="编写测试用类"></a>编写测试用类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Dog源代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在测试用类中建立对象并存取对象的变量和方法"><a href="#在测试用类中建立对象并存取对象的变量和方法" class="headerlink" title="在测试用类中建立对象并存取对象的变量和方法"></a>在测试用类中建立对象并存取对象的变量和方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Dog源代码</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();  <span class="comment">// 建立并存取Dog对象</span></span><br><span class="line">        d.size = <span class="number">40</span>;        <span class="comment">// 调用Dog类的方法</span></span><br><span class="line">        d.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快离开main"><a href="#快离开main" class="headerlink" title="快离开main"></a>快离开<code>main</code></h3><p>真正的Java程序只会让对象与对象交互. 在Java程序中, <code>main()</code>有两种用处:</p>
<ol>
<li>测试真正的类</li>
<li>启动你的Java应用程序</li>
</ol>
<p>这里用一个例子展示Java程序如何”预览”以及对象和对象间如何互动.</p>
<h4 id="猜数字游戏"><a href="#猜数字游戏" class="headerlink" title="猜数字游戏"></a>猜数字游戏</h4><p>该游戏涉及到<code>game</code>与<code>player</code>两个对象. 其中, <code>game</code>会产生介于0~9之间的随机数字, 而3个player对象会猜测该数字.</p>
<p>类: <code>GuessGame.class</code>、<code>Player.class</code>和<code>GameLauncher.class</code>.</p>
<p>程序逻辑:</p>
<ol>
<li><code>GameLauncher</code>这个类带有<code>main()</code>方法, 是应用程序的入口点.</li>
<li><code>main()</code>中会创建出<code>GuessGame</code>对象, 并调用它的<code>startGame()</code>方法</li>
<li><code>startGame()</code>方法是游戏的起点. 它会创建三个<code>player</code>对象, 然后挑出要猜测的随机数字. 它会要求<code>player</code>猜测并检测结果, 过程会被列出来.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameLauncher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuessGame</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuessGame</span>();</span><br><span class="line">        game.startGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guess</span><span class="params">()</span> &#123;</span><br><span class="line">        number = (<span class="type">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m guessing &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    Player p1;</span><br><span class="line">    Player p2;</span><br><span class="line">    Player p3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startGame</span><span class="params">()</span> &#123;</span><br><span class="line">        p1 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        p2 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        p3 = <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guessp3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p1isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p2isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">p3isRight</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">targetNumber</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m thinking of a number between 0 and 9 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Number to guess is &quot;</span> + targetNumber);</span><br><span class="line"></span><br><span class="line">            p1.guess();</span><br><span class="line">            p2.guess();</span><br><span class="line">            p3.guess();</span><br><span class="line"></span><br><span class="line">            guessp1 = p1.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player one guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            guessp2 = p2.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player two guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            guessp3 = p3.number;</span><br><span class="line">            System.out.println(<span class="string">&quot;Player three guessed &quot;</span> + guessp1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessp1 == targetNumber) &#123;</span><br><span class="line">                p1isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp2 == targetNumber) &#123;</span><br><span class="line">                p2isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guessp3 == targetNumber) &#123;</span><br><span class="line">                p3isRight = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p1isRight || p2isRight || p3isRight) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;We have a winner!&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player One got it right? &quot;</span> + p1isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player Two got it right? &quot;</span> + p2isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Player Three got it right? &quot;</span> + p3isRight);</span><br><span class="line">                System.out.println(<span class="string">&quot;Game is over.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Players will have to try again.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="认识变量"><a href="#认识变量" class="headerlink" title="认识变量"></a>认识变量</h2><p>变量有两种: <strong>primitive主数据类型</strong>和<strong>引用</strong>.</p>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>为了让类型安全能够发挥作用, 我们必须声明所有变量的类型, 制定他是一个<code>int</code>类型或是一个<code>Dog</code>类型. 变量有两种: primitive主数据类型与对象引用. 其中, primitive主数据类型用来保存基本类型的值, 包括整数、布尔类型和浮点数等; 而对象引用保存的是对象的引用.</p>
<h3 id="primitive主数据类型"><a href="#primitive主数据类型" class="headerlink" title="primitive主数据类型"></a>primitive主数据类型</h3><p>primitive主数据类型有着不同的大小与名称, 如四种大小不同的整数类型<code>long</code>, <code>int</code>, <code>short</code>和<code>byte</code>.</p>
<h3 id="避开关键字"><a href="#避开关键字" class="headerlink" title="避开关键字"></a>避开关键字</h3><p>Java中的变量命名规则如下:</p>
<ol>
<li>名称必须以字母、下划线或$符号开头, 不能用数字开头</li>
<li>除了第一个字符, 变量名称的其他位置上都可以用数字</li>
<li>避开Java保留字</li>
</ol>
<h3 id="变量与对象"><a href="#变量与对象" class="headerlink" title="变量与对象"></a>变量与对象</h3><p>我们已经指导如何声明primitive主数据类型变量. 但是非primitive主数据类型的变量又该如何处理呢? 有以下要点:</p>
<ol>
<li>事实上没有”对象变量”这样的东西存在</li>
<li>只有**引用(reference)**到对象的变量</li>
<li>对象引用变量保存的是<strong>存取对象的方法</strong></li>
<li>它并不是对象的容器, 而是类似指向对象的指针, 或者可以说是地址.</li>
</ol>
<p>对象的声明、创建于幅值有三个步骤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<h4 id="声明一个引用变量"><a href="#声明一个引用变量" class="headerlink" title="声明一个引用变量"></a>声明一个引用变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog myDog</span><br></pre></td></tr></table></figure>

<p>要求Java虚拟机分配空间给引用变量, 并将变量命名为myDog.</p>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>要求Java虚拟机分配堆空间给新建立的<code>Dog</code>对象.</p>
<h4 id="连接对象和引用"><a href="#连接对象和引用" class="headerlink" title="连接对象和引用"></a>连接对象和引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>将新的<code>Dog</code>赋值给<code>myDog</code>这个引用变量.</p>
<h3 id="生活在垃圾处理堆上"><a href="#生活在垃圾处理堆上" class="headerlink" title="生活在垃圾处理堆上"></a>生活在垃圾处理堆上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="type">Book</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br></pre></td></tr></table></figure>

<p>声明两个<code>Book</code>的引用变量并创建两个<code>Book</code>对象, 然后将<code>Book</code>对象赋值给引用变量. 现在这两个<code>Book</code>对象储存在堆上.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">d</span> <span class="operator">=</span> c;</span><br></pre></td></tr></table></figure>

<p>声明新的<code>Book</code>引用变量, 但不床啊金新的<code>Book</code>对象而将变量<code>c</code>的值赋值给变量<code>d</code>. 这表示”将<code>c</code>的字节组合拷贝给变量<code>d</code>“. 此时的<code>c</code>和<code>d</code><strong>引用到同一对象</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = b;</span><br></pre></td></tr></table></figure>

<p>将变量<code>b</code>的值拷贝给变量<code>c</code>. 此时, <code>b</code>和<code>c</code>两者都引用相同的对象.</p>
<h3 id="堆上的生与死"><a href="#堆上的生与死" class="headerlink" title="堆上的生与死"></a>堆上的生与死</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line"><span class="type">Book</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br></pre></td></tr></table></figure>

<p>声明两个<code>Book</code>的引用变量并创建两个<code>Book</code>对象, 然后将<code>Book</code>对象赋值给引用变量. 现在这两个<code>Book</code>对象生活在堆上.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br></pre></td></tr></table></figure>

<p>将变量<code>c</code>的值赋给变量<code>b</code>. 两个变量带有相同的值. 此时, 对象1被抛弃且能够作垃圾收集器(GC).</p>
<p>此时, 对象1已经没有引用, 称为无法存取的变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>将<code>null</code>值赋给<code>c</code>. 这代表它不再引用任何事物, 但还是可以被制定引用其他<code>Book</code>的引用变量.</p>
<p>对象2还引用到, 随意不能够作垃圾收集器.</p>
<h3 id="数组犹如杯架"><a href="#数组犹如杯架" class="headerlink" title="数组犹如杯架"></a>数组犹如杯架</h3><ol>
<li>声明一个<code>int</code>数组变量.<br><code>int[] nums;</code></li>
<li>创建大小为七的数组, 并将它赋值给之前声明为<code>int[]</code>的变量<code>nums</code>.<br><code>nums = new int[7];</code></li>
<li>赋予<code>int</code>数组的每一个元素一个<code>int</code>值.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">4</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">5</span>] = <span class="number">6</span>;</span><br><span class="line">nums[<span class="number">6</span>] = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数组也是对象"><a href="#数组也是对象" class="headerlink" title="数组也是对象"></a>数组也是对象</h4><p>数组能够让人使用位置索引来快速、随机地存取其中的元素.</p>
<p>注意, 在Java中, 一旦数组被声明出来, 我们就只能在其中装入所声明类型的元素.</p>
<h4 id="创建Dog数组"><a href="#创建Dog数组" class="headerlink" title="创建Dog数组"></a>创建<code>Dog</code>数组</h4><p>首先声明一个<code>Dog</code>数组变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog[] pets;</span><br></pre></td></tr></table></figure>

<p>创建大小为7的<code>Dog</code>数组, 并赋值给钱买你所声明出的<code>Dog[]</code>类型变量<code>pets</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">7</span>];</span><br></pre></td></tr></table></figure>

<p>创建新的<code>Dog</code>对象并将它们赋值给数组的元素.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pets[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">pets[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>如何存取<code>Dog</code>数组中的<code>Dog</code>对象? 我们只需要数组索引(位置)就可以操作 特定对象了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog[] myDogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">3</span>];</span><br><span class="line">myDogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">myDogs[<span class="number">0</span>].name = <span class="string">&quot;Fido&quot;</span>;</span><br><span class="line">myDogs[<span class="number">0</span>].bark();</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog1.bark();</span><br><span class="line">        dog1.name = <span class="string">&quot;Bart&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Dog[] myDogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        myDogs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDogs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDogs[<span class="number">2</span>] = dog1;</span><br><span class="line"></span><br><span class="line">        myDogs[<span class="number">0</span>].name = <span class="string">&quot;Fred&quot;</span>;</span><br><span class="line">        myDogs[<span class="number">1</span>].name = <span class="string">&quot;Marge&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;last dog&#x27;s name is &quot;</span>);</span><br><span class="line">        System.out.println(myDogs[<span class="number">2</span>].name);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; myDogs.length) &#123;</span><br><span class="line">            myDogs[x].bark();</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; says Ruff!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法操作实例变量"><a href="#方法操作实例变量" class="headerlink" title="方法操作实例变量"></a>方法操作实例变量</h2><p>类所描述的是<strong>对象知道什么</strong>与<strong>执行什么</strong>. 任一类的每个实例都带有相同的方法, 但是方法可以根据实例变量的值来表现不同的行为. 我们可以通过给对象传值的方法控制对象的具体行为.</p>
<h3 id="传值给方法"><a href="#传值给方法" class="headerlink" title="传值给方法"></a>传值给方法</h3><p>程序中有两种参数, 即</p>
<ol>
<li>实参(argument)</li>
<li>形参(parameter)</li>
</ol>
<p>它们的主要区别在于: <strong>方法会运用形参, 调用的一方会传入实参.</strong></p>
<p>实参是传给方法的值; 当它传入方法后就成了形参.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">d.bark(<span class="number">3</span>);  <span class="comment">// 此处的&quot;3&quot;即为实参</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(name + <span class="string">&quot; says Ruff!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(<span class="type">int</span> numOfBarks)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (numOfBarks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ruff&quot;</span>);</span><br><span class="line">        numOfBarks = numOfBarks - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从方法中获得返回值"><a href="#从方法中获得返回值" class="headerlink" title="从方法中获得返回值"></a>从方法中获得返回值</h3><p>方法可以有返回值, 也可以没有返回值. 被设定为<code>void</code>的方法无返回值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以指定一个方法的返回值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">giveSecret</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法声明有返回值, 就必须返回所声明类型的值.</p>
<h3 id="同时向方法传入多个参数"><a href="#同时向方法传入多个参数" class="headerlink" title="同时向方法传入多个参数"></a>同时向方法传入多个参数</h3><p>方法可以有多个参数. 在声明时需用逗号分开, 传入的时候也是用逗号分开, 并以正确数量、类型和顺序来传递参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TestStuff</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStuff</span>();</span><br><span class="line">    t.takeTwo(<span class="number">12</span>, <span class="number">34</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">takeTwo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line">    System.out.println(<span class="string">&quot;Total is &quot;</span> + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将变量当作参数传入, 只要类型相符就可以.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bar</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    t.takeTwo(foo, bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">takeTwo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + y;</span><br><span class="line">    System.out.println(<span class="string">&quot;Total is &quot;</span> + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java是<strong>通过值传递的</strong>, 也就是说<strong>通过拷贝传递</strong>.</p>
<h3 id="运用参数于返回类型"><a href="#运用参数于返回类型" class="headerlink" title="运用参数于返回类型"></a>运用参数于返回类型</h3><p><code>Getter</code>和<code>Setter</code>可让你执行<code>get</code>和<code>set</code>. <code>Getter</code>的目的只有一个, 就是返回实例变量的值; 而<code>Setter</code>的目的就是取用一个参数来设定实例变量的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElectricGuitar</span> &#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">int</span> numOfPickups;</span><br><span class="line">    <span class="type">boolean</span> rockStarUsesIt;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String aBrand)</span> &#123;</span><br><span class="line">        brand = aBrand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">getNumOfPickups</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numOfPickups;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNumOfPickups</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        numOfPickups = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">getRockStarUsesIt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rockStarUsesIt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRockStarUsesIt</span><span class="params">(<span class="type">boolean</span> yesOrNo)</span> &#123;</span><br><span class="line">        rockStarUsesIt = yesOrNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>在介绍封装前, 我们需要先介绍<strong>暴露</strong>, 即可以通过圆点运算符存取对象中的变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">27</span>;</span><br></pre></td></tr></table></figure>

<p>如此简单的存取方法可能会因使用者的不当操作导致实例变量被不当赋值, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theCat.height = <span class="number">0</span>;  <span class="comment">// 现实中哪有身高为0的猫呢</span></span><br></pre></td></tr></table></figure>

<p>所以我们需要创建<code>Setter</code>这个方法给所有的实例变量, 并寻求某种方法强制其他程序都必须通过<code>Setter</code>来设定变量而不是直接的存取.</p>
<p>注: 对封装优点的具体解释可以看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors">这里</a>.</p>
<p>有了<code>Setter</code>, 我们就可以防止<code>Cat</code>被设定成无法接收的高度.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> ht)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ht &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        height = ht;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据隐藏"><a href="#数据隐藏" class="headerlink" title="数据隐藏"></a>数据隐藏</h3><p>如何隐藏数据呢: 答案是使用公有与私有这两个存取修饰符(access modifier).</p>
<p>以下就是封装的基本原则: <strong>将你的实例变量标记为私有的(private), 并提供公有的(public)<code>getter</code>与<code>setter</code>来控制存取动作</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodDog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GoodDog</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodDog</span>();</span><br><span class="line">        one.setSize(<span class="number">70</span>);</span><br><span class="line">        <span class="type">GoodDog</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodDog</span>();</span><br><span class="line">        two.setSize(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog one: &quot;</span> + one.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog two: &quot;</span> + two.getSize());</span><br><span class="line">        one.bark();</span><br><span class="line">        two.bark();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">14</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Ruff! Ruff!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Yip! Yip!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中对象的方法"><a href="#数组中对象的方法" class="headerlink" title="数组中对象的方法"></a>数组中对象的方法</h3><p>数组中的对象就如同其他的对象一样, 唯一的差别就是: 数组中的对象需要用索引取得而已.</p>
<h3 id="声明与初始化实例变量"><a href="#声明与初始化实例变量" class="headerlink" title="声明与初始化实例变量"></a>声明与初始化实例变量</h3><p>实例变量永远都会有默认值. 如果我们没有明确的赋值给实列变量, 或者没有调用<code>setter</code>, 实例变量还是会有值.</p>
<table>
<thead>
<tr>
<th>实例变量类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>intergers</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>floating points</code></td>
<td><code>0.0</code></td>
</tr>
<tr>
<td><code>booleans</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>references</code></td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h3 id="实例变量与局部变量之间的差别"><a href="#实例变量与局部变量之间的差别" class="headerlink" title="实例变量与局部变量之间的差别"></a>实例变量与局部变量之间的差别</h3><h4 id="实例变量是声明在类内而不是方法中"><a href="#实例变量是声明在类内而不是方法中" class="headerlink" title="实例变量是声明在类内而不是方法中"></a>实例变量是声明在类内而不是方法中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">15.2</span>;   <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> String breed;           <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="comment">// more code ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量是声明在方法中的"><a href="#局部变量是声明在方法中的" class="headerlink" title="局部变量是声明在方法中的"></a>局部变量是声明在方法中的</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddThing</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> a + b;  <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量在使用前必须初始化"><a href="#局部变量在使用前必须初始化" class="headerlink" title="局部变量在使用前必须初始化"></a>局部变量在使用前必须初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;  <span class="comment">// 无法编译</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> x + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的比较-primitive主数据类型或引用"><a href="#变量的比较-primitive主数据类型或引用" class="headerlink" title="变量的比较(primitive主数据类型或引用)"></a>变量的比较(primitive主数据类型或引用)</h3><p>如果我们想要知道两个primitive主数据类型是否相等, 只需要使用<code>==</code>运算符即可; 如果我们想要知道两个引用变量是否引用到堆上的同一个对象, 也是使用同样的方法即可. 但如果想要知道两个对象是否真的相等, 则需要使用<code>equals()</code>这个方法, 且相等的意义也需要视对象的类型而定.</p>
<h2 id="编写程序——以战舰游戏为例"><a href="#编写程序——以战舰游戏为例" class="headerlink" title="编写程序——以战舰游戏为例"></a>编写程序——以战舰游戏为例</h2><p>我们可以通过设计一个战舰游戏来讲解如何编写一个”真正的”Java程序.</p>
<p><strong>游戏目标</strong>: 以最少的猜测次数打掉计算机所安排的达康公司(Dot Com)网站. 计算机会根据你的表现来评分.</p>
<p><strong>初始设置</strong>: 程序启动后, 计算机会在虚拟的$7 \times 7$方格上安排三个达康网站. 安排完成后, 游戏会要求你开始猜坐标.</p>
<p><strong>进行游戏</strong>: 因为我们还没偶学到图形接口的程序设计, 所以这一版会在命令栏上进行. 计算机会提示你输入所猜测的位置(格子), 输入应为”A3”或”C5”等. 计算机会反馈命中”Hit”、脱靶”Miss”或击沉”Sunk”等回应. 当清楚所有的达康后, 计算机会列出得分情况.</p>
<h3 id="高层设计"><a href="#高层设计" class="headerlink" title="高层设计"></a>高层设计</h3><p>我们需要类和方法, 但是具体需要哪些类和方法呢? 我们需要通过明晰游戏流程来获得这些信息.</p>
<ol>
<li>玩家启动游戏<ol>
<li>计算机创建3个达康网站</li>
<li>将此3个达康网站停在虚拟战场上</li>
</ol>
</li>
<li>游戏开始, 重复下列操作直到全歼达康网站<ol>
<li>提示玩家输入坐标</li>
<li>检查命中情况</li>
</ol>
</li>
<li>游戏结束, 根据猜测次数打分</li>
</ol>
<h3 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h3><p>乍一看, 本程序需要两个类, 即<code>Game</code>类和<code>DotCom</code>类. 但是我们先编写一个简单的一维版游戏, 并将其命名为”Simple Dot Com Game”.</p>
<h3 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h3><p>当我们在创建Java的类以当作”学习经验”时, 程序会像下面这样:</p>
<ol>
<li>找出类应该做的事情</li>
<li>列出实例变量和方法</li>
<li>编写方法的伪码</li>
<li>编写方法的测试用程序</li>
<li>实现类</li>
<li>测试方法</li>
<li>除错或重新设计</li>
</ol>
<h4 id="伪码"><a href="#伪码" class="headerlink" title="伪码"></a>伪码</h4><p>伪码大致上包括三部分: <strong>实例变量的声明</strong>、<strong>方法的声明</strong>和<strong>方法的逻辑</strong>. 伪码最重要的部分是方法的逻辑, 因为它定义出会发生”什么事”. 这个部分会在稍后真正编写程序代码时转译成”如何”发生.</p>
<h4 id="为SimpleDotCom编写测试码"><a href="#为SimpleDotCom编写测试码" class="headerlink" title="为SimpleDotCom编写测试码"></a>为<code>SimpleDotCom</code>编写测试码</h4><p>在开始编写方法之前, 我们需要先写出测试方法用的程序代码. 这一概念来自极限编程方法论(XP), 该方法论帮助程序员更快写出程序代码.</p>
<p>我们首先写出<code>SimpleDotCom</code>对象的测试码. 对于该类而言, 我们关心的只有<code>checkYourself()</code>方法, 但为了让该方法正确运行, 我们还需要实现<code>setLocationCells()</code>方法以便让<code>checkYourself()</code>方法正确执行. 对于<code>checkYourself()</code>方法来说, 有如下几个部分需要进行测试:</p>
<ol>
<li><code>SimpleDotCom</code>对象的初始化</li>
<li>赋值位置(带有三个<code>int</code>的数组, 如<code>&#123;2,3,4&#125;</code>)</li>
<li>创建代表玩家猜想的字符串</li>
<li>传入伪造的玩家猜测以调用<code>checkYourself()</code>方法</li>
<li>列出结果以观察结果是否正确</li>
</ol>
<p><code>SimpleDotCom</code>的测试码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">dot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        dot.setLocationCells(locations);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userGuess</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> dot.checkYourself(userGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testResult</span> <span class="operator">=</span> <span class="string">&quot;failed&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.equals(<span class="string">&quot;hits&quot;</span>)) &#123;</span><br><span class="line">            testResult = <span class="string">&quot;passed&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(testResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkYourself-方法"><a href="#checkYourself-方法" class="headerlink" title="checkYourself()方法"></a><code>checkYourself()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotCom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkYourself</span><span class="params">(String stringGuess)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> Integer.parseInt(stringGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;miss&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cell : locationCells) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123;</span><br><span class="line">                result = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line"></span><br><span class="line">                numOfHits++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHits == locationCells.length) &#123;</span><br><span class="line">            result = <span class="string">&quot;kill&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDotCom与SimpleDotComTester的最终版本"><a href="#SimpleDotCom与SimpleDotComTester的最终版本" class="headerlink" title="SimpleDotCom与SimpleDotComTester的最终版本"></a><code>SimpleDotCom</code>与<code>SimpleDotComTester</code>的最终版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">dot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        dot.setLocationCells(locations);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userGuess</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> dot.checkYourself(userGuess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotCom</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] locationCells;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numOfHits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocationCells</span><span class="params">(<span class="type">int</span>[] locs)</span> &#123;</span><br><span class="line">        locationCells = locs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkYourself</span><span class="params">(String stringGuess)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> Integer.parseInt(stringGuess);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;miss&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cell : locationCells) &#123;</span><br><span class="line">            <span class="keyword">if</span> (guess == cell) &#123;</span><br><span class="line">                result = <span class="string">&quot;hits&quot;</span>;</span><br><span class="line">                numOfHits++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfHits == locationCells.length) &#123;</span><br><span class="line">            result = <span class="string">&quot;kill&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="游戏的main-方法"><a href="#游戏的main-方法" class="headerlink" title="游戏的main()方法"></a>游戏的<code>main()</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDotComGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numOfGuesses</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">GameHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameHelper</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDotCom</span> <span class="variable">theDotCom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDotCom</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] locations = &#123;randomNum, randomNum+<span class="number">1</span>, randomNum+<span class="number">2</span>&#125;;</span><br><span class="line">        theDotCom.setLocationCells(locations);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAlive</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (isAlive == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">guess</span> <span class="operator">=</span> helper.getUserInput(<span class="string">&quot;enter a number&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> theDotCom.checkYourself(guess);</span><br><span class="line">            numOfGuesses++;</span><br><span class="line">            <span class="keyword">if</span> (result.equals(<span class="string">&quot;kill&quot;</span>)) &#123;</span><br><span class="line">                isAlive = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;You took &quot;</span> + numOfGuesses + <span class="string">&quot; guesses&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最后一个类-GameHelper"><a href="#最后一个类-GameHelper" class="headerlink" title="最后一个类: GameHelper"></a>最后一个类: <code>GameHelper</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInput</span><span class="params">(String prompt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">inputLine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.print(prompt + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            <span class="keyword">if</span> (inputLine.length() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IOException: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于for循环"><a href="#关于for循环" class="headerlink" title="关于for循环"></a>关于<code>for</code>循环</h3><h4 id="基础for循环"><a href="#基础for循环" class="headerlink" title="基础for循环"></a>基础<code>for</code>循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会以如下方式解读这行代码:</p>
<ol>
<li>创建变量<code>i</code>并赋值为<code>0</code></li>
<li>只要<code>i</code>小于<code>100</code>就重复执行</li>
<li>在每趟城府过程最后把<code>i</code>加<code>1</code></li>
</ol>
<h4 id="加强版的for循环"><a href="#加强版的for循环" class="headerlink" title="加强版的for循环"></a>加强版的<code>for</code>循环</h4><p>自Java 5.0开始, Java就有了一种加强版的<code>for</code>循环, 能够很容易地逐个运行数组或其他集合(collection)的元素.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String name:nameArray) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会以如下方式解读这行代码:</p>
<ol>
<li>创建名称为<code>name</code>的<code>String</code>变量</li>
<li>将<code>nameArray</code>的第一个元素值赋给<code>name</code></li>
<li>执行重复的内容</li>
<li>赋值给下一个元素<code>name</code></li>
<li>重复执行直至所有元素都被运行为止</li>
</ol>
<h2 id="认识Java的API"><a href="#认识Java的API" class="headerlink" title="认识Java的API"></a>认识Java的API</h2><h3 id="ArrayList的操作"><a href="#ArrayList的操作" class="headerlink" title="ArrayList的操作"></a><code>ArrayList</code>的操作</h3><p>创建:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Egg&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Egg&gt;();</span><br></pre></td></tr></table></figure>

<p>加入元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Egg</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Egg</span>();</span><br><span class="line">myList.add(s);</span><br></pre></td></tr></table></figure>

<p>再加入元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Egg</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Egg</span>();</span><br><span class="line">myList.add(b);</span><br></pre></td></tr></table></figure>

<p>查询大小:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">theSize</span> <span class="operator">=</span> myList.size();</span><br></pre></td></tr></table></figure>

<p>查询特定元素:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isIn</span> <span class="operator">=</span> myList.contains(s);</span><br></pre></td></tr></table></figure>

<p>查询特定元素的位置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> myList.indexOf(b);</span><br></pre></td></tr></table></figure>

<p>判断几何是否为空:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> myList.isEmpty();</span><br></pre></td></tr></table></figure>

<p>删除元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myList.remove(s);</span><br></pre></td></tr></table></figure>

<h3 id="使用函数库-Java-API"><a href="#使用函数库-Java-API" class="headerlink" title="使用函数库(Java API)"></a>使用函数库(Java API)</h3><p>在Java的API中, 类被包装在包中. 要使用API中的类, 我们必须知道他被放在哪个包中.</p>
<p>在使用API时, 我们必须知名程序代码中所用到的类的完整名称, 如<code>java.util.ArrayList</code>; 同时, 必须告诉Java使用的到底是哪个<code>ArrayList</code>. 你可以每次使用的时候都把包名打完整, 也可以直接<code>import</code>, 省时省力:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><h3 id="继承的运行方式"><a href="#继承的运行方式" class="headerlink" title="继承的运行方式"></a>继承的运行方式</h3><p>在设计继承时, 我们将共同的程序代码放在某个类中, 然后告诉其他的类, 说此类是它们的父类. 当某个类集成了另一个类的时候, 也就是子类继承自父类. 用Java的方式说, 这是”子类继承父类”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> worksAtHospital;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FamliyDoctor</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> makesHouseCalls;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">giveAdvice</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Surgeon</span> <span class="keyword">extends</span> <span class="title class_">Doctor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">treatPatient</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeIncision</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承层次的设计——以设计动物仿真程序为例"><a href="#继承层次的设计——以设计动物仿真程序为例" class="headerlink" title="继承层次的设计——以设计动物仿真程序为例"></a>继承层次的设计——以设计动物仿真程序为例</h3><p>假设要设一个仿真系统程序, 可以让用户设定将一群动物丢到某种环境中以观察会发生什么事情.</p>
<p>我们已经被告知一部分会用的动物(狮子、河马、老虎、狗、猫和狼), 但是并不知道以后还会有多少中动物会被加进来. 每一个动物都会用一个对象来表示, 且动物会在环境中活动, 执行任何被设计的行为.</p>
<p>我们首先要辨别出所有动物都有的、抽象的共同特征, 然后以这些共同特征设计出能够让所有动物加以扩充的类.</p>
<h4 id="找出具有共同属性和行为的对象"><a href="#找出具有共同属性和行为的对象" class="headerlink" title="找出具有共同属性和行为的对象"></a>找出具有共同属性和行为的对象</h4><p>狮子、河马、老虎、狗、猫和狼间各有什么异同? 这些类型又有什么相关性?</p>
<h4 id="设计代表共同状态与行为的类"><a href="#设计代表共同状态与行为的类" class="headerlink" title="设计代表共同状态与行为的类"></a>设计代表共同状态与行为的类</h4><p>我们有五个实例变量:</p>
<ol>
<li><code>picture</code>: 动物JPEG图像的名称</li>
<li><code>food</code>: 此动物所吃的食物</li>
<li><code>hunger</code>: 代表饥饿程度的<code>int</code>值</li>
<li><code>boundaries</code>: 代表动物活动范围区域的长宽</li>
<li><code>location</code>: 动物在活动区域中的X与Y坐标</li>
</ol>
<p>还有四个方法:</p>
<ol>
<li><code>makeNoise()</code>: 动物发出声音的行为程序</li>
<li><code>eat()</code>: 动物遇到事物时的行为程序</li>
<li><code>sleep()</code>: 睡眠的行为程序</li>
<li><code>roam()</code>: 不再进食或睡眠时的行为程序</li>
</ol>
<p>由于六个动物都是动物, 我们可以用<code>Animal</code>作为共同父类的名称.</p>
<h4 id="决定子类是否需要让某项行为有特定不同的运作方式"><a href="#决定子类是否需要让某项行为有特定不同的运作方式" class="headerlink" title="决定子类是否需要让某项行为有特定不同的运作方式"></a>决定子类是否需要让某项行为有特定不同的运作方式</h4><p>再仔细考虑后, 我们认为, <code>eat()</code>和<code>makeNoise()</code>应该由各个子类自行覆盖.</p>
<h4 id="通过寻找使用共同行为的子类来找出更多抽象化的机会"><a href="#通过寻找使用共同行为的子类来找出更多抽象化的机会" class="headerlink" title="通过寻找使用共同行为的子类来找出更多抽象化的机会"></a>通过寻找使用共同行为的子类来找出更多抽象化的机会</h4><p>我们观察到<code>Wolf</code>和<code>Dog</code>间、<code>Lion</code>、<code>Tiger</code>和<code>Cat</code>间有某些共同的行为.</p>
<h4 id="完成类的继承层次"><a href="#完成类的继承层次" class="headerlink" title="完成类的继承层次"></a>完成类的继承层次</h4><p>我们使用全科和猫科动物的分类来做出<code>Canine</code>和<code>Feline</code>两个类. 每个类中都有各自的<code>roam()</code>方法.</p>
<h4 id="调用哪个方法"><a href="#调用哪个方法" class="headerlink" title="调用哪个方法?"></a>调用哪个方法?</h4><p>当调用对象引用的方法时, 我们会调用到与该对象类型最接近的方法.</p>
<h4 id="子类能够继承哪些东西"><a href="#子类能够继承哪些东西" class="headerlink" title="子类能够继承哪些东西?"></a>子类能够继承哪些东西?</h4><p>子类可以继承父类的成员, 但父类可以通过<strong>存取权限</strong>决定子类是否能够继承某些特定的成员. 此处只介绍如下所示的四种存取权限, 其限制程度从左到右依次降低:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">default</span> <span class="keyword">protected</span> <span class="keyword">public</span></span><br></pre></td></tr></table></figure>

<p><code>private</code>类型的成员不会被继承, 而<code>public</code>类型的成员会被继承.</p>
<h4 id="使用继承的几个条件"><a href="#使用继承的几个条件" class="headerlink" title="使用继承的几个条件"></a>使用继承的几个条件</h4><ol>
<li>当某个类比其父类更具有特定意义时使用继承</li>
<li>在行为程序(实现程序代码)应该被多个相同基本类型类所共享时, 应考虑使用继承</li>
<li>继承有时候并不是达成重用行为程序的最佳方式</li>
<li>如果两者间不能通过IS-A测试就不要应用继承关系. 一定要确定子类是父类一种更特定的类型才可以</li>
</ol>
<h4 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h4><p>通过设计继承的过程我们可以累计面向对象的经验. 通过提取出一组类间共同的抽象性, 我们能够排除掉重复的程序代码而将这个部分放在父类中.</p>
<ol>
<li>避免了重复的程序代码</li>
<li>定义出共同的协议</li>
</ol>
<p>继承可以确保某个父型之下的所有类都有父型所持有的全部方法, 也就是说, <strong>我们会通过继承来定义相关类间的共同协议</strong>.</p>
<p>当我们定义出一组类的父型时, 我们可以用子型的任何类来填补任何需要或期待父型的位置.</p>
<h3 id="多态的运行"><a href="#多态的运行" class="headerlink" title="多态的运行"></a>多态的运行</h3><p>若要观察多态是如何运行的, 我们就需要先复习一下一般声明引用和创建对象的方法:</p>
<ol>
<li>声明一个引用变量</li>
<li>创建对象</li>
<li>连接对象和引用</li>
</ol>
<p>重点在于, 引用类型与对象的类型必须相符.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p>但是在<strong>多态</strong>下, <strong>引用与对象可以是不同的类型</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p><strong>运用多态时, 引用类型可以是实际对象类型的父类</strong>. 当我们声明一个引用变量时, 任何对该引用变量类型可通过IS-A测试的对象都可以被赋值给该引用. 换句话说, 任何<code>extends</code>过声明引用变量类型的对象都可以被赋值给这个引用变量. 这样我们就可以创建出多态数组一类的东西.</p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明Animal类型的数组</span></span><br><span class="line">Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 但我们可以放任何Animal类的子类进去</span></span><br><span class="line">animals[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animals[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">animals[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">animals[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">animals[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Lion</span>();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 我们可以将数组的元素调出来当作Animal对象来操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">    animals[i].eat();</span><br><span class="line">    animals[i].roam();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数和返回类型也可以多态</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveShot</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PetOwner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Vet</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vet</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">        v.giveShot(d);  <span class="comment">// 执行Dog的makeNoise()</span></span><br><span class="line">        v.giveShot(h);  <span class="comment">// 执行Hippo的makeNoise()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将程序代码编写成使用多态参数的程序, 即将参数声明成父类类型, 我们就可以在运行时传入任何的子类对象; 此外, 在引进新子类后, 我们也不必修改以前的程序.</p>
<p>如果你想<strong>放置某个类被做出子类</strong>, 有三种方法可供选择:</p>
<ol>
<li>进行存取控制</li>
<li>使用<code>final</code>修饰符——它表示这里是继承树的末端, 不能被继承</li>
<li>让类只拥有<code>private</code>的构造程序(constructor)</li>
</ol>
<h3 id="覆盖的规则"><a href="#覆盖的规则" class="headerlink" title="覆盖的规则"></a>覆盖的规则</h3><p>如果想要在子类中覆盖掉父类中的某些方法, 我们需要先遵守以下规则:</p>
<ol>
<li>参数必须相同, 且返回类型必须要兼容</li>
<li>不能降低方法的存取权限</li>
</ol>
<h3 id="方法的重载-Overload"><a href="#方法的重载-Overload" class="headerlink" title="方法的重载(Overload)"></a>方法的重载(Overload)</h3><p>重载的意义是<strong>两个方法的名称相同, 但参数不同</strong>. 这也是其与多态的区别所在.</p>
<p>重载可以有同一方法的多个不同参数版本以方便调用. 它有着下列特点:</p>
<ol>
<li>返回类型可以不同</li>
<li>不能只改变返回类型</li>
<li>可以更改存取权限</li>
</ol>
<p>下面是一个合法的重载范例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloads</span> &#123;</span><br><span class="line">    String uniqueID;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">addNum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUniqueID</span><span class="params">(String theID)</span> &#123;</span><br><span class="line">        uniqueID = theID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUniqueID</span><span class="params">(<span class="type">int</span> ssNumber)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + ssNumber;</span><br><span class="line">        setUniqueID(numString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p><strong>继承只是个开始</strong>. 要使用多态, 我们还需要接口. 我们需要超越简单的继承并前进到只有通过设计与编写接口规格才能达成的适应性与扩展性. 到底<strong>接口</strong>是什么呢? 它是一种<strong>100%纯抽象的类</strong>. 什么是<strong>抽象类</strong>? 它是<strong>无法初始化的类</strong>.</p>
<h3 id="有些类不该初始化"><a href="#有些类不该初始化" class="headerlink" title="有些类不该初始化"></a>有些类不该初始化</h3><p>在前面的章节中, 我们为了介绍继承的概念写了一个仿真动物行为的例子. 在这个例子中, 我们通过继承<code>Animal</code>类建立了具体的动物类, 并以此创建了各动物类的对象. 但是, 如果我们要创建<code>Animal</code>类的对象, 会发生什么呢?</p>
<p>答案是不会发生什么. 但是, 这个世界上毕竟没有叫做”动物”的动物, 我们硬要把它当作对象创建出来也毫无意义; 但是我们又需要<code>Animal</code>类来继承和产生多态. 但是要限制只有它的子类才能被初始化.</p>
<p>在Java中, 通过标记类为抽象类, 编译器就知道这个类不能被初始化, 即被<code>new</code>出来. 具体实施方法就是在类的声明前面加上抽象类关键词<code>abstract</code>即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Canine</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roam</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当设计好继承结构后, 我们必须要决定哪些类是抽象的, 哪些又是具体的. 抽象类除了被继承之外, 是没有用途、没有值且没有目的的.</p>
<h3 id="抽象的方法"><a href="#抽象的方法" class="headerlink" title="抽象的方法"></a>抽象的方法</h3><p>除了类之外, 我们也可以将方法标记为<code>abstract</code>的. 抽象的类代表此类必须要被<code>extend</code>过, <strong>抽象的方法代表此方法一定要被覆盖过</strong>.</p>
<p><strong>抽象的方法没有实体</strong>, 所以抽象方法的代码是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">// 没有方法体, 直接以分号结束</span></span><br></pre></td></tr></table></figure>

<p>如果我们声明了一个抽象的方法, 我们就必须<strong>将包含这个方法的类表姐为抽象的</strong>.</p>
<p>此外, <strong>我们必须实现所有抽象的方法</strong>.</p>
<h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><p>假设我们不知道有<code>ArrayList</code>这种类而想要自行编写维护<code>list</code>的类以保存<code>Dog</code>对象. 在第一轮我们指挥写出<code>add()</code>方法. 我们使用大小为五的简单<code>Dog</code>数组<code>Dog[]</code>来保存新加入的<code>Dog</code>对象. 当<code>Dog</code>对象超过五个时, 我们还是可以调用<code>add()</code>方法, 但是什么都不会发生. 如果没有越界, <code>add()</code>会把<code>Dog</code>装到可用的数组位置中, 然后递增可用索引<code>nextIndex</code>.</p>
<h4 id="自创Dog专用的list"><a href="#自创Dog专用的list" class="headerlink" title="自创Dog专用的list"></a>自创<code>Dog</code>专用的<code>list</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDogList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex &lt; dogs.length) &#123;</span><br><span class="line">            dogs[nextIndex] = d;</span><br><span class="line">            System.out.println(<span class="string">&quot;Dog added at &quot;</span> + nextIndex);</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="还要给Cat用"><a href="#还要给Cat用" class="headerlink" title="还要给Cat用?"></a>还要给<code>Cat</code>用?</h4><p>如果我们发现现在还要写一个给<code>Cat</code>用的<code>list</code>, 我们是另外单独创建一个<code>MyCatList</code>类; 还是创建一个单独的<code>DogAndCat</code>类, 用<code>addCat(Cat c)</code>与<code>addDog(Dog d)</code>来同时处理两个不同的数组实例呢?</p>
<p>都不是. 我们编写一个不同的<code>AnimalList</code>类让它处理<code>Animal</code>所有的子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnimalList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex &lt; animals.length) &#123;</span><br><span class="line">            animals[nextIndex] = a;</span><br><span class="line">            System.out.println(<span class="string">&quot;Animal added at &quot;</span> + nextIndex);</span><br><span class="line">            nextIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果要为所有类写一个list呢"><a href="#如果要为所有类写一个list呢" class="headerlink" title="如果要为所有类写一个list呢?"></a>如果要为所有类写一个<code>list</code>呢?</h4><p>如果要为所有类写一个这样的<code>list</code>, 我们就需要为所有的类找到一个父类. 但是, 真的有这样的类吗?</p>
<p>实际上是有的, 这个类就是<code>Object</code>类.</p>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a><code>Object</code>类</h3><p>在Java中, 所有的类都是从<code>Object</code>这个类中继承下来的. <code>Object</code>类是所有类的源头, 是所有类的父亲.</p>
<h4 id="终极对象中都有什么"><a href="#终极对象中都有什么" class="headerlink" title="终极对象中都有什么?"></a>终极对象中都有什么?</h4><ol>
<li><code>equals(Object o)</code>: 检测两个对象是否是”相等”的</li>
<li><code>getClass()</code>: 告诉使用者对象是从哪里被初始化的</li>
<li><code>hashCode()</code>: 返回对象的哈希值</li>
<li><code>toString()</code>: 列出类的名称和一个我们并不关系的数字</li>
</ol>
<h4 id="那么-代价是什么呢"><a href="#那么-代价是什么呢" class="headerlink" title="那么, 代价是什么呢?"></a>那么, 代价是什么呢?</h4><p>在开始以<code>Object</code>类型使用所有适用性参数和返回类型之前, 我们应该考虑到使用<code>Object</code>类型作为引用的一些问题. 此处并不涉及制作出<code>Object</code>类型的实例, 这是在说以<code>Object</code>类型作为引用的其他类型.</p>
<p>当我们将对象装进<code>ArrayList&lt;Dog&gt;</code>中时, 它会被当作<code>Dog</code>来输入与输出; 但若你把它声明成<code>ArrayList&lt;Object&gt;</code>时会怎样? 如果我们创造出一个可以保存任何一种对象的<code>ArrayList</code>, 并尝试将<code>Dog</code>对象取出并赋值给<code>Dog</code>的引用时会发生什么事?</p>
<p>答案是<strong>无法通过编译</strong>. <strong>任何从<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作<code>Object</code>类型的引用而不管它原来是什么</strong>.</p>
<p>如果想要将被编译器看作是<code>Object</code>类的<code>Dog</code>对象转回来, 我们可以从<code>Object</code>中拷贝出一个<code>Dog</code>引用, 并将其赋值给<code>Dog</code>引用变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> al.get(index);</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) <span class="number">0</span>;</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure>

<p>如果你不能确定他是<code>Dog</code>, 我们可以用<code>instanceof</code>这个运算符来检查. 如果类型抓换错了, 程序会弹出ClassCastException异常并终止程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此, Java中引用变量的类型的重要性可见一斑. 我们只能在引用变量的类确实有该方法时才能够调用它.</p>
<p>但是, 如果我们想要在某个已经继承了一个父类的类中再引入其他类的功能呢? 我们要再继承一个父类的内容吗? 显然是不行的, 因为如果两个父类中有名称相同的方法的话, 子类会不知道究竟应该继承哪一个. 实际上, Java也不支持继承两个父类的方法. Java提供的解决方式为: 接口.</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口(interface)是专为解决上述情况而生的. 它采用的方法也很简单: 将全部的方法都设为抽象的.</p>
<p>由此我们知道, 应该如下定义一个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">beFriendly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要实现一个接口的话, 应该编写如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Canine</span> <span class="keyword">implements</span> <span class="title class_">Pet</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>相比继承, 接口还有一个特点, 即<strong>不同继承树的类也可以实现相同的接口</strong>. 当我们把一个类当作是多态类型运用时, 相同的类型必定来自同一个继承树; 但当我们用接口来作为多态类型时, 对象就可以来自任何地方了.</p>
<p>此外, <strong>类还可以实现多个接口</strong>, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Pet</span>, Saveable, Paintable &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断应该设计类、子类、抽象类还是接口呢"><a href="#如何判断应该设计类、子类、抽象类还是接口呢" class="headerlink" title="如何判断应该设计类、子类、抽象类还是接口呢"></a>如何判断应该设计类、子类、抽象类还是接口呢</h3><ol>
<li>如果新的类无法对其他的类通过IS-A测试时, 就设计不继承其他类的类;</li>
<li>只要在需要某类的特殊化版本时, 以覆盖或增加新的方法来继承现有的类;</li>
<li>当你需要定义一群子类的模板, 又不想让程序员初始化此模板时, 设计出抽象的类给它们用;</li>
<li>如果想要定义出类可以扮演的角色, 使用接口.</li>
</ol>
<h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><p><code>super</code>关键字能够实现在子类中调用父类方法的功能.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Report</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">runReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设计报告</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuzzwordsReport</span> <span class="keyword">extends</span> <span class="title class_">Report</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">runReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.runReport();  <span class="comment">// 调用父类方法</span></span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buzzwordCompliance</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h2><h3 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h3><p>在Java中, 内存被分为两种区域: 对象的生存空间<strong>堆</strong>(heap)以及方法调和变量的生存空间<strong>栈</strong>(stack). 注意: 并不是所有变量都生活在栈中. 变量分为实例变量和局部变量. 实例变量是被声明在类而不是方法中的变量, 它们被存储于所述的对象中; 局部变量, 又称栈变量, 被声明在方法中. 只有局部变量(栈变量)被储存在栈中, 其余变量均被储存在堆中.</p>
<h4 id="栈上的方法"><a href="#栈上的方法" class="headerlink" title="栈上的方法"></a>栈上的方法</h4><p>当我们调用一个方法时, 该方法会被放在调用栈的栈顶. 实际被堆上栈的是堆栈块, 它带有方法的状态.</p>
<h4 id="栈上的对象引用"><a href="#栈上的对象引用" class="headerlink" title="栈上的对象引用"></a>栈上的对象引用</h4><p>非primitive变量保存的只是对象的引用, 而不是对象本身. 故只有保存引用的变量自己被放在了栈上; 对象自己是在堆中待着的.</p>
<h4 id="堆上的实例变量"><a href="#堆上的实例变量" class="headerlink" title="堆上的实例变量"></a>堆上的实例变量</h4><p>在我们想要新建一个对象时, Java必须为这个对象在堆上找一个位置. 对象中的实例变量会被存放在其中.</p>
<p>但是, 如果实例变量自己也是个对象呢? 如果对象带有一个其他类的对象呢? 如果对象带有其他对象的引用变量呢?</p>
<p>实际上, Java只会为引用变量留出空间. 至于”另一个对象”, 则需要考虑它是什么时候被创建的: 如果声明了对象却没有被赋值, 则只会留下变量的空间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Antenna ant;</span><br></pre></td></tr></table></figure>

<p>自横刀引用变量被赋值一个新的对象, 堆上才会有这个新对象的空间.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Antenna</span> <span class="variable">ant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Antenna</span>();</span><br></pre></td></tr></table></figure>

<h3 id="创建对象详解——构造函数"><a href="#创建对象详解——构造函数" class="headerlink" title="创建对象详解——构造函数"></a>创建对象详解——构造函数</h3><p>我们都知道, 声明对象并赋值有三个步骤: 声明引用变量、创建对象以及连接对象和引用. 但是新对象究竟是如何诞生的呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Duck</span> <span class="variable">myDuck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br></pre></td></tr></table></figure>

<p>我们在创建<code>Duck</code>对象的时候编写了<code>new Duck()</code>代码. 看上去就像调用了一个叫做<code>Duck()</code>的方法. 但实际上不是的, 我们只是调用了<code>Duck</code>的<strong>构造函数</strong>.</p>
<p>构造函数看起来很像方法, 但实际上并不是. 它会在我们初始化一个对象的时候执行.</p>
<p>我们可以自己编写构造函数, 也可以让编译器帮我们编写一个. 通常, 编译器编写的构造函数是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中我们能够看到构造函数与方法的区别:</p>
<ol>
<li>方法每返回类型, 但是构造函数没有返回类型</li>
<li>构造函数的名称一定要与类的名称相同.</li>
</ol>
<h3 id="构造Duck"><a href="#构造Duck" class="headerlink" title="构造Duck"></a>构造<code>Duck</code></h3><p>构造函数的一项关键特征是它会在对象能够被赋值给引用之前就执行. 在任何人取得对象的遥控器之前, 对象有机会对构造过程给予协助.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在运行后会输出一个Quack. 这证明我们可以借助构造函数干涉对象构件过程.</p>
<h3 id="新建Duck状态的初始化"><a href="#新建Duck状态的初始化" class="headerlink" title="新建Duck状态的初始化"></a>新建<code>Duck</code>状态的初始化</h3><p>大部分的人都是使用构造函数来初始化对象的状态. 也就是说, 设置和给对象的实例变量赋值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">    size = <span class="number">34</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在开发者知道<code>Duck</code>类应该有多大时是没有问题的. 但如果是要由使用<code>Duck</code>的程序员来决定时怎么办? 那我们就需要使用类的<code>set</code>方法来设置了. 但这会让<code>Duck</code>暂时处于没有大小数值的状态(实例变量没有默认值), 且需要两行才能完成赋值, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        d.setSize(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某种对象不应该在状态被初始化之前就使用, 就不要让任何人能够在没有初始化的情况下取得该种对象. 以<code>Duck</code>为例, 让用户先构造出<code>Duck</code>对象再来设定大小是很危险的. 如果用户不知道这件事, 或者干脆忘了要调用<code>set</code>方法, 那<code>Duck</code>对象就会陷入没有大小的混沌状态.</p>
<p>最好的解决办法就是将初始化的程序代码放在构造函数中, 然后将构造函数设定成需要参数的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> duckSize)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">        size = duckSize;</span><br><span class="line">        System.out.println(<span class="string">&quot;Size is &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseDuck</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Duck的产后护理"><a href="#Duck的产后护理" class="headerlink" title="Duck的产后护理"></a><code>Duck</code>的产后护理</h3><h4 id="一定要有不需要参数的构造函数"><a href="#一定要有不需要参数的构造函数" class="headerlink" title="一定要有不需要参数的构造函数"></a>一定要有不需要参数的构造函数</h4><p>还是以<code>Duck</code>为例. 让程序员自己定义<code>Duck</code>的大小固然是好, 但是如果程序员自己也不知道大小, 我们还强迫人家在构造函数里填一个值就未免有些强人所难了. 所以我们需要构件一个不需要参数的构造函数: 一个可以指定<code>Duck</code>的大小, 一个使用默认值而无需指定大小.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> duckSize)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quack&quot;</span>);    <span class="comment">// 嘎</span></span><br><span class="line">        size = duckSize;</span><br><span class="line">        System.out.println(<span class="string">&quot;Size is &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">27</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外, 就算一个类不可能提供默认值, 我们也要提供无参数的构造函数.</p>
<h4 id="编译器不是什么时候都会帮你写构造函数的"><a href="#编译器不是什么时候都会帮你写构造函数的" class="headerlink" title="编译器不是什么时候都会帮你写构造函数的"></a>编译器不是什么时候都会帮你写构造函数的</h4><p>在我们写了一个有参数的构造函数后, 编译器就不会再插手构造函数的编写工作. 如果我们还想写一个没有参数的构造函数, 就只能自行编写.</p>
<p>此外, 如果类有一个以上的构造函数, 则参数一定要不一样. 编译器看的是参数的<strong>类型和顺序</strong>, 而不是参数的名字. 我们完全可以编写出参数类型相同但是顺序不同的构造函数.</p>
<h3 id="父类的空间——父类与子类的构造函数"><a href="#父类的空间——父类与子类的构造函数" class="headerlink" title="父类的空间——父类与子类的构造函数"></a>父类的空间——父类与子类的构造函数</h3><p>在创建某个对象时, 对象会取得所有实例变量所需的空间, 其中必然包括一路继承下来的东西. 在创建新对象的同时, <strong>所有继承下来的构造函数都会被执行</strong>.</p>
<p>执行<code>new</code>命令的指令是个大事, 因为它会引起构造函数的连锁反应. 此外, 抽象类也有构造函数. 虽然不能对抽象的类执行<code>new</code>操作, 但是抽象类也是父类, 其构造函数会在具体子类创建时执行.</p>
<p>至于原因: 在构造函数中使用<code>super</code>调用父类的构造函数的部分. 要记得子类可能会根据父类的状态来继承方法(即父类的实例变量). 完整的对象需要同样玩这个的父类核心, 故子类必须调用父类的构造函数. 构造函数在执行的时候, 第一件事就是去执行它的父类的构造函数, 这会向上推到<code>Object</code>这个类为止.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making an Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hippo</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hippo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making a Hippo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHippo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting ...&quot;</span>);</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting ...</span><br><span class="line">Making an Animal</span><br><span class="line">Making a Hippo</span><br></pre></td></tr></table></figure>

<h4 id="如何调用父类的构造函数"><a href="#如何调用父类的构造函数" class="headerlink" title="如何调用父类的构造函数"></a>如何调用父类的构造函数</h4><p>以<code>Duck</code>的构造函数来说, 它不是通过<code>Animal()</code>, 而是通过<code>super()</code>来调用父类<code>Animal</code>的构造函数的, 如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">(<span class="type">int</span> newSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类的构造函数调用<code>super()</code>后, 编译器会将父类的构造函数放在堆栈的最上方. 而父类的构造函数又会调用父类的父类的构造函数, 直到<code>Object</code>类的构造函数为止. 在<code>Object</code>的构造函数运行完毕后, 其子类的构造函数就会一路弹出, 直到最初的构造函数.</p>
<p>如果我们没有调用<code>super()</code>, 编译器就会帮我们在构造函数中加入<code>super()</code>, 以调用父类的构造函数. 但是编译器添加的构造函数一定是没有参数的<code>super()</code>, 就算父类有带参数的构造函数也是这样.</p>
<p>注意, <code>super()</code><strong>只能放在构造函数的第一行上</strong>.</p>
<h4 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h4><p>父类的部分必须在子类创建完成之前就必须完整地成型, 因为子类对象可能需要动用到从父类继承下来的东西. 父类的构造函数必须在子类的构造函数之前结束.</p>
<h4 id="有参数的父类构造函数"><a href="#有参数的父类构造函数" class="headerlink" title="有参数的父类构造函数"></a>有参数的父类构造函数</h4><p>如果父类的构造函数有参数怎么办? 能够传递值进去吗? 如果不行的话, 则没有无参数构造函数的类将不能被继承. 想象这个场景: 所有的动物都有名字. 所以, <code>Animal</code>类有个<code>getName()</code>可以返回<code>name</code>实例变量的值. 此实例变量是被标记为<code>private</code>的, 但<code>Hippo</code>这个子类把<code>getName()</code>这个方法继承下来了. 问题来了: <code>Hippo</code>有<code>getName()</code>这个方法但是没有<code>name</code>实例变量. <code>Hippo</code>要靠<code>Animal</code>的部分来维持<code>name</code>实例变量, 然后从<code>getName()</code>来返回这个值. 但<code>Animal</code>要如何获得这个值呢? 唯一的机会是通过<code>super()</code>来引用父类, 所以要从这里把<code>name</code>的值传进去, 让<code>Animal</code>把它存到私有的<code>name</code>实例变量中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// Every animal has a name.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">// Hippo会继承这个get方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String theName)</span> &#123; <span class="comment">// 有参数的构造函数, 用来设定name</span></span><br><span class="line">        name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hippo</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hippo</span><span class="params">(String name)</span> &#123; <span class="comment">// 如果不传给这个构造函数值, 编译器会报错</span></span><br><span class="line">        <span class="built_in">super</span>(name);    <span class="comment">// 传给Animal的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHippo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting ...&quot;</span>);</span><br><span class="line">        <span class="type">Hippo</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hippo</span>(<span class="string">&quot;Buffy&quot;</span>);</span><br><span class="line">        System.out.println(h.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用重载版本——从某个构造函数调用重载版的另一个构造函数"><a href="#调用重载版本——从某个构造函数调用重载版的另一个构造函数" class="headerlink" title="调用重载版本——从某个构造函数调用重载版的另一个构造函数"></a>调用重载版本——从某个构造函数调用重载版的另一个构造函数</h3><p>如果某个重载版的构造函数除了不能处理不同类型的参数之外, 可以处理所有的工作, 那要怎么般? 我们不能让相同的程序代码出现在每个构造函数中, 所以我们可以将程序代码只摆在某个构造函数中(包括对<code>super()</code>的调用). 如此一来, 多有的构造函数就都会有限调用该构造函数, 让他来执行真正的构造函数.</p>
<p>为此, 我们需要使用<code>this()</code>或<code>this(aString)</code>或<code>this(27, x)</code>. 换句话说, <strong><code>this()</code>是对对象本身的调用</strong>. 需要注意的是:</p>
<ol>
<li><code>this()</code>只能出现在构造函数中;</li>
<li><code>this()</code>必须为构造函数的第一句语句;</li>
<li><code>super()</code>和<code>this()</code>不能同时调用.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mini</span> <span class="keyword">extends</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mini</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Color.Red);    <span class="comment">// 无参数的构造函数以默认的颜色调用真正的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mini</span><span class="params">(Color c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Mini&quot;</span>);      <span class="comment">// 真正的构造函数</span></span><br><span class="line">        color = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的死亡"><a href="#对象的死亡" class="headerlink" title="对象的死亡"></a>对象的死亡</h3><p>对象的生命周期完全取决于其引用的状态. 如果引用还存在, 则对象也会继续待在堆上; 如果引用”死掉”了, 对象就会被从堆上移除.</p>
<p>那变量又会存在多久呢? 这取决于它是局部变量还是实例变量: 局部变量只存在于声明该变量的方法中; 实例变量的寿命与对象相同.</p>
<h4 id="“life”和”scope”的差别"><a href="#“life”和”scope”的差别" class="headerlink" title="“life”和”scope”的差别"></a>“life”和”scope”的差别</h4><ol>
<li>“life”: 只要变量的堆栈还存在于堆栈上, 局部变量就算或者, 即活到方法执行完毕为止;</li>
<li>“scope’: 局部变量的范围只限于声明它的方法之内. 当此方法调用别的方法时, 该变量还活着, 但不在目前的范围内. 执行其他方法完毕返回时, 范围也就跟着回来.</li>
</ol>
<h4 id="引用变量的死亡"><a href="#引用变量的死亡" class="headerlink" title="引用变量的死亡"></a>引用变量的死亡</h4><p>引用变量的死活判断与primitive主数据类型变量相同. 真正的问题在于: <strong>变量的生命周期如何影响对象的生命周期</strong>?</p>
<p>只要有或者的引用, 对象也就会活着. 如果某个对象的引用已经不在它的范围中, 但该引用还是活着的, 则此对象就会继续活在堆上.</p>
<p>如果对象的唯一引用死了, 对象就会从堆中被踢开. 引用变量会跟随堆栈块一道解散, 被踢开的对象也就此出局, 成为了”可被垃圾回收器回收的”. 有三种方法能够将对象变为可被回收的:</p>
<ol>
<li>对象的引用变量所在的方法被弹出堆栈;</li>
<li>对象的引用变量被复制到其他的对象上;</li>
<li>对象的引用变量被赋了<code>null</code>.</li>
</ol>
<h2 id="数字与静态"><a href="#数字与静态" class="headerlink" title="数字与静态"></a>数字与静态</h2><h3 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a><code>Math</code>方法</h3><p>想要执行<code>Math</code>中的方法并不需要创建<code>Math</code>的实例变量. 实际上我们也创建不出来, 因为它们的都是”静态”的. 我们用到的只有这个类本身.</p>
<h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>Java是面向对象的. 但如果有需求(通常是实用方法), 则不需要类的实例. 关键词<code>static</code>可以标记出不需要实例的方法. 一个静态的方法意味着”一种不依靠实例变量也就不需要对象的行为”.</p>
<h4 id="带有静态方法的含义"><a href="#带有静态方法的含义" class="headerlink" title="带有静态方法的含义"></a>带有静态方法的含义</h4><p>带有静态方法的类一般都不打算被初始化. 这样的类的构造函数一般都被限制为<code>private</code>. 但这并不意味着有一个或多个静态方法的类就不可以被初始化, 毕竟只要有<code>main()</code>的类都算作是有静态方法的类.</p>
<p>由此可知, 我们可以自由地在类中组合静态与非静态方法. 然而任何非静态方法都需要某种实例来操作. 取得新对象的方法也只有通过<code>new</code>或者序列化(deserialization)以及我们暂时设计不到的Java Reflection API. 除此之外, 别无他发. 实际上, 由谁来新建是一个很有意思的问题. 我们会在下面讨论它.</p>
<h4 id="静态方法不能调用非静态变量"><a href="#静态方法不能调用非静态变量" class="headerlink" title="静态方法不能调用非静态变量"></a>静态方法不能调用非静态变量</h4><p>静态的方法实在无关特定类的实例情况下执行的. 因为静态的方法是通过类的名称来调用, 所以静态的方法无法引用到该类的任何实力变量. 在此情况下, 静态的方法也不会知道可以使用哪个实例变量值.</p>
<h4 id="静态方法也不能调用非静态方法"><a href="#静态方法也不能调用非静态方法" class="headerlink" title="静态方法也不能调用非静态方法"></a>静态方法也不能调用非静态方法</h4><p>与非静态变量的情况类似, 静态方法也不能调用非静态方法: 实例不存在, 对应的方法也就不存在.</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>假设我们要在执行过程中计算有多少<code>Duck</code>的实例已经被建立出来, 应该怎么作? 在构造函数中递增某个实例变量的值?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">duckCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码不行, 因为<code>duckCount</code>是个实例变量, 对象与对象间相互不影响, 所以行不通.</p>
<p>但是, 我们可以将<code>duckCount</code>声明为<code>static</code>变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">duckCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Duck</span><span class="params">()</span> &#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样, 所有的<code>duckCount</code>值就都是相等的. 每当我们创建一个<code>duckCount</code>对象时, <code>duckCount</code>就加1, 由此实现数量的统计.</p>
<h4 id="静态变量的起始动作"><a href="#静态变量的起始动作" class="headerlink" title="静态变量的起始动作"></a>静态变量的起始动作</h4><p>静态项目的初始化有两项保证:</p>
<ol>
<li>静态变量会在该类的任何对象创建之前就完成初始化;</li>
<li>静态变量会在该类的任何静态方法执行之前就初始化.</li>
</ol>
<h4 id="静态final变量是常数"><a href="#静态final变量是常数" class="headerlink" title="静态final变量是常数"></a>静态<code>final</code>变量是常数</h4><p>一个被标记为<code>final</code>的变量代表它一旦被初始化之后就不会被改动. 也就是说, 类加载之后静态<code>final</code>变量就一直会维持原值. 以<code>Math.PI</code>为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>此变量被标记为<code>public</code>, 因此可供各方读取;</li>
<li>此变量被标记为<code>static</code>, 因此你不需要<code>Math</code>的实例;</li>
<li>此变量被标记为<code>final</code>, 因为圆周率是不变的.</li>
</ol>
<p>没有其他的方法再可以将一个变量标记为不变的, 但是又约定俗成的命名惯例可以帮助我们这些人类认出来, 即<strong>常熟变量的名称应该要都是大写字母</strong>.</p>
<h4 id="静态final变量的初始化"><a href="#静态final变量的初始化" class="headerlink" title="静态final变量的初始化"></a>静态<code>final</code>变量的初始化</h4><p>有两种方法. 一是在声明的时候:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FOO_X</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二是在静态初始化程序中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> BAR_SIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BAR_SIGN = (<span class="type">double</span>) Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有按上述两种方式中的一种为静态<code>final</code>变量初始化的话, 如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> BAR_SIGN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会报错, 要求你初始化这个变量.</p>
<h3 id="final的其他用法"><a href="#final的其他用法" class="headerlink" title="final的其他用法"></a><code>final</code>的其他用法</h3><p><code>final</code>不只用在静态变量上. 我们也可以用<code>final</code>关键字来修饰非静态的变量, 其中包括实例变量、局部变量以及方法的参数. 他们都代表被修饰的值不能变动. 我们也可以使用<code>final</code>来防止方法的覆盖或创建子类.</p>
<p>总结一下:</p>
<ol>
<li><code>final</code>的变量代表其值不能被修改;</li>
<li><code>final</code>的方法代表该方法不能被覆盖;</li>
<li><code>final</code>的类代表该类不能被继承.</li>
</ol>
<h3 id="primitive主数据类型的包装"><a href="#primitive主数据类型的包装" class="headerlink" title="primitive主数据类型的包装"></a>primitive主数据类型的包装</h3><p>我们有时想要把primitive主数据类型当作对象来处理. 如Java 5.0之前, 我们无法直接将primitive主数据类型装入<code>ArrayList</code>或<code>HashMap</code>中. 但是, 每个primitive主数据类型都有一个包装用的类, 且这些包装类都放在<code>Java.lang</code>这个包中, 无需import. 这些包装类与其对应的primitive主数据类型如下表所示:</p>
<table>
<thead>
<tr>
<th>primitive主数据类型名称</th>
<th>包装类名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
</tbody></table>
<p>包装过程如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">iWrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br></pre></td></tr></table></figure>

<p>解包装过程如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">unWrapped</span> <span class="operator">=</span> iWrap.intValue();</span><br></pre></td></tr></table></figure>

<h4 id="autoboxing-不必将primitive主数据类型与对象分得那么清楚"><a href="#autoboxing-不必将primitive主数据类型与对象分得那么清楚" class="headerlink" title="autoboxing: 不必将primitive主数据类型与对象分得那么清楚"></a><code>autoboxing</code>: 不必将primitive主数据类型与对象分得那么清楚</h4><p>从5.0版本开始加入的<code>autoboxing</code>功能能够自动将primitive主数据类型转换成包装过的对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNumsNewWay</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; listOfNumbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    listOfNumbers.add(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> listOfNumbers.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="“无处不在的”autoboxing"><a href="#“无处不在的”autoboxing" class="headerlink" title="“无处不在的”autoboxing"></a>“无处不在的”<code>autoboxing</code></h4><ol>
<li>方法的参数</li>
<li>返回值</li>
<li><code>boolean</code>表达值</li>
<li>数值运算</li>
<li>赋值</li>
</ol>
<h4 id="包装的静态实用方法"><a href="#包装的静态实用方法" class="headerlink" title="包装的静态实用方法"></a>包装的静态实用方法</h4><p>除了一般类的操作外, 包装也有一组实用的静态方法. 我们在之前已经使用过一个: <code>Integer.parseInt()</code>. 这个方法取用<code>Strinig</code>并返回primitive主数据类型值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;420.24&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>).booleanValue(); <span class="comment">// 将String转换为boolean的唯一方法</span></span><br></pre></td></tr></table></figure>

<p>反过来, 我们也可以将primitive主数据类型值转换成<code>String</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">42.5</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">doubleString1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + d;  <span class="comment">// &quot;+&quot;运算符是Java中唯一一个重载过的运算符</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">42.5</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">doubleString2</span> <span class="operator">=</span> Double.toString(d);</span><br></pre></td></tr></table></figure>

<h2 id="异常处理——以创建MIDI音乐播放器为例"><a href="#异常处理——以创建MIDI音乐播放器为例" class="headerlink" title="异常处理——以创建MIDI音乐播放器为例"></a>异常处理——以创建MIDI音乐播放器为例</h2><h3 id="JavaSound-API"><a href="#JavaSound-API" class="headerlink" title="JavaSound API"></a>JavaSound API</h3><p>如果我们想要创建一个MIDI音乐播放器, 我们首先需要知道如何让Java”发生”. JavaSound API解决了这一问题.</p>
<h4 id="Sequencer对象"><a href="#Sequencer对象" class="headerlink" title="Sequencer对象"></a><code>Sequencer</code>对象</h4><p>在我们要能够发出任何声音之前, 必须先要取得<code>Sequencer</code>对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sequencer</span> <span class="variable">sequencer</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">        System.out.println(<span class="string">&quot;We got a sequencer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 上述代码会在执行时报错, 无法通过编译. 为什么呢?</p>
<h3 id="调用有风险的方法"><a href="#调用有风险的方法" class="headerlink" title="调用有风险的方法"></a>调用有风险的方法</h3><p>假设我们调用了一个不是自己写的方法. 该方法在执行某些有风险的任务时可能会出现状况. 我们必须意识到: 该方法是有风险的, 所以, 我们需要写出可以在发生状况时加以处理的程序代码, 未雨绸缪.</p>
<p>Java的异常处理机制是一个简洁且轻量化的例外状况处理方式. 它能够将处理错误状况的程序代码摆在一个容易阅读的为止上.</p>
<p>如何得知某个方法会抛出异常呢? 我们可以在方法的声明中的<code>throws</code>语句中看到.</p>
<p>我们在<code>getSequencer()</code>方法的说明中, 我们看到, <code>getSequencer()</code>可能会抛出<code>MidiUnavailableException</code>异常. 编译器需要确定我们知道这种风险的存在, 而告知其的方法便是将有风险的程序代码包含在<code>try/catch</code>块中.</p>
<p><code>try/catch</code>块会告诉编译器你确实知道所调用的方法会有风险, 并且也已经准备好要处理它, 它只会注意你有没有表示你会注意到异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">sequencer</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            System.out.println(<span class="string">&quot;We got a sequencer.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MidiUnavailableException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bummer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常也是一种对象"><a href="#异常也是一种对象" class="headerlink" title="异常也是一种对象"></a>异常也是一种对象</h4><p>异常也是一种对象, 且<code>Exception</code>类型的对象可以是任何它的子类的实例, 所以我们<code>catch</code>住的也是对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 危险动作</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">    <span class="comment">// 尝试恢复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="谁抛出的异常"><a href="#谁抛出的异常" class="headerlink" title="谁抛出的异常?"></a>谁抛出的异常?</h4><p>现在我们只需要知道: 当我们的程序代码调用有风险的方法时, 也就是声明有异常的方法时, 就是该方法把异常丢给你的.</p>
<p>实际上, 两者都有可能是我们自己写的. 但事实上, 谁写的程序其实并不重要; 重要的是在哪个方法抛出异常以及由哪个方法抓住他.</p>
<p>在编写可能会抛出异常的方法时, 它们都必须声明由异常.</p>
<h5 id="有风险、会抛出异常的程序代码"><a href="#有风险、会抛出异常的程序代码" class="headerlink" title="有风险、会抛出异常的程序代码"></a>有风险、会抛出异常的程序代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boid <span class="title function_">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException &#123;</span><br><span class="line">    <span class="keyword">if</span> (abandonAllHope) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用该方法的程序代码"><a href="#调用该方法的程序代码" class="headerlink" title="调用该方法的程序代码"></a>调用该方法的程序代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crossFingers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        anObject.takeRisk();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(BadException ex) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aaargh&quot;</span>);</span><br><span class="line">        ex.printStackTrace();   <span class="comment">// 如果无法从异常中恢复, 至少也可以用printStackTrace()来列出有用的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="受检查的与不受检查的异常"><a href="#受检查的与不受检查的异常" class="headerlink" title="受检查的与不受检查的异常"></a>受检查的与不受检查的异常</h4><p>编译器会核对除了<code>RuntimeExceptions</code>之外的每件事. 编译器保证:</p>
<ol>
<li>如果你有抛出异常, 则你一定要使用<code>throw</code>来声明这件事;</li>
<li>如果你调用会抛出异常的方法, 你必须得确认你知道异常的可能性. 将调用包在<code>try/catch</code>块中是一种满足编译器的方法.</li>
</ol>
<p>除了<code>RuntimeExceptions</code>这种特例之外, 编译器会关照<code>Exception</code>所有的子类. 任何继承过<code>RuntimeExceptions</code>的类都不会受编译器关于是否声明它会抛出<code>RuntimeExceptions</code>的检查. 同样的, 也不会管调用方是否认识到可能会在运行期间遇到异常.</p>
<h3 id="异常与流程控制"><a href="#异常与流程控制" class="headerlink" title="异常与流程控制"></a>异常与流程控制</h3><p>当要调用有风险的方法时, 有一两件事可能会发生. 该方法要么成功执行了<code>try</code>块中的内容, 要么将异常丢回调用方的方法.</p>
<h4 id="finally块-无论如何都要执行的部分"><a href="#finally块-无论如何都要执行的部分" class="headerlink" title="finally块: 无论如何都要执行的部分"></a><code>finally</code>块: 无论如何都要执行的部分</h4><p><code>finally</code>块是用来存放不管有没有异常都得执行的程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    turnOvenOn();</span><br><span class="line">    x.bake();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BakingException ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    turnOvenOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 就算<code>try</code>块或<code>catch</code>块中有<code>return</code>命令, <code>finally</code>还是会执行. 流程会跳到<code>finally</code>块然后再执行<code>return</code>命令.</p>
<h3 id="一次抛出多个异常"><a href="#一次抛出多个异常" class="headerlink" title="一次抛出多个异常"></a>一次抛出多个异常</h3><p>如果有必要的话, 方法可以抛出多个异常. 但该方法的声明必须要含有全部可能的检查异常(若两个或两个以上的异常有共同的父类时, 可以只声明该父类就行).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Laundry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> PantsException, LingerieException &#123;</span><br><span class="line">        <span class="comment">// 有可能抛出两个异常的程序代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Laundry</span> <span class="variable">laundry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Laundry</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            laundry.doLaundry();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(PantsException pex) &#123;</span><br><span class="line">            <span class="comment">// 恢复程序代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">            <span class="comment">// 恢复程序代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常也是多态的"><a href="#异常也是多态的" class="headerlink" title="异常也是多态的"></a>异常也是多态的</h3><p>异常除了可以被抛出外与对象无异, 故异常也可以能够以多态的方式来引用. 举例来说, <code>LingerieException</code>对象能够被赋值给<code>ClothingException</code>的引用. <code>PantsException</code>也能够被赋值给<code>Exception</code>的引用. 这样的好处是方法可以不必明确声明每个可能抛出的异常, 只声明父类就可以了. 对于<code>catch</code>块来说, 也可以不用对每个可能的异常做处理, 只要有一个或少数几个<code>catch</code>可以处理所有的异常就足够了.</p>
<h4 id="以异常的父型来声明会抛出的异常"><a href="#以异常的父型来声明会抛出的异常" class="headerlink" title="以异常的父型来声明会抛出的异常"></a>以异常的父型来声明会抛出的异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLaundry</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以所抛出的异常父型来catch异常"><a href="#以所抛出的异常父型来catch异常" class="headerlink" title="以所抛出的异常父型来catch异常"></a>以所抛出的异常父型来<code>catch</code>异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;    <span class="comment">// 可以catch任何ClothingException的子类</span></span><br><span class="line">    <span class="comment">// 解决方案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;    <span class="comment">// 只能catch两种子类</span></span><br><span class="line">    <span class="comment">// 解决方案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合理使用父型"><a href="#合理使用父型" class="headerlink" title="合理使用父型"></a>合理使用父型</h4><p>我们固然可以直接在<code>catch</code>中写一个<code>Exception</code>类直接抓取所有的异常, 但如果需要异常的不同做出不同的处理的话, 我们还是需要具体地写一下<code>catch</code>代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125; <span class="keyword">catch</span>(TeeShirtException tex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(LingerieException lex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ClothingException cex) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有catch块时要从小排到大"><a href="#有catch块时要从小排到大" class="headerlink" title="有catch块时要从小排到大"></a>有<code>catch</code>块时要从小排到大</h4><p>如题, 否则小的(在继承树上靠下的)异常就永远无法被正常解决.</p>
<h3 id="实在是不想处理异常"><a href="#实在是不想处理异常" class="headerlink" title="实在是不想处理异常"></a>实在是不想处理异常</h3><h4 id="duck"><a href="#duck" class="headerlink" title="duck"></a>duck</h4><p>如果自己实在是不想处理异常的话, 我们可以直接duck掉异常, 即表示自己会再throw掉此异常即可.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> ReallyBadException &#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ducking只是在踢皮球"><a href="#ducking只是在踢皮球" class="headerlink" title="ducking只是在踢皮球"></a>ducking只是在踢皮球</h4><p>duck只是把Exception甩到上一级. 我们可以一级一级地将Exception向上甩吗, 但如果<code>main()</code>也把Exception给duck掉, 那编译器就直接死机了.</p>
<p>我们可以把Exception向上甩, 但是总有一天我们要catch它的.</p>
<h3 id="异常处理的规则"><a href="#异常处理的规则" class="headerlink" title="异常处理的规则"></a>异常处理的规则</h3><ol>
<li><code>catch</code>与<code>finally</code>不能没有<code>try</code>;</li>
<li><code>try</code>与<code>catch</code>之间不能有程序</li>
<li><code>try</code>一定要有<code>catch</code>或<code>finally</code></li>
<li>只带有<code>finally</code>的<code>try</code>必须要声明异常</li>
</ol>
<h3 id="回到音乐播放程序"><a href="#回到音乐播放程序" class="headerlink" title="回到音乐播放程序"></a>回到音乐播放程序</h3><h4 id="第一版音乐播放程序"><a href="#第一版音乐播放程序" class="headerlink" title="第一版音乐播放程序"></a>第一版音乐播放程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest1</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest1</span>();</span><br><span class="line">        test1.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">player</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line"></span><br><span class="line">            <span class="type">Sequence</span> <span class="variable">seq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Track</span> <span class="variable">track</span> <span class="operator">=</span> seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line"></span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第二版音乐播放程序"><a href="#第二版音乐播放程序" class="headerlink" title="第二版音乐播放程序"></a>第二版音乐播放程序</h4><p>这一版的音乐播放程序可以通过在控制台输入数字来改变播放的声音.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MusicTest2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicTest2</span>();</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Do not forget the instrument and note args.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">instrument</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">note</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            test2.play(instrument, note);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(<span class="type">int</span> instrument, <span class="type">int</span> note)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Sequencer</span> <span class="variable">player</span> <span class="operator">=</span> MidiSystem.getSequencer();</span><br><span class="line">            player.open();</span><br><span class="line">            <span class="type">Sequence</span> <span class="variable">seq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sequence</span>(Sequence.PPQ, <span class="number">4</span>);</span><br><span class="line">            <span class="type">Track</span> <span class="variable">track</span> <span class="operator">=</span> seq.createTrack();</span><br><span class="line"></span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            first.setMessage(<span class="number">192</span>, <span class="number">1</span>, instrument, <span class="number">0</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">changeInstrument</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(first, <span class="number">1</span>);</span><br><span class="line">            track.add(changeInstrument);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            a.setMessage(<span class="number">144</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(a, <span class="number">1</span>);</span><br><span class="line">            track.add(noteOn);</span><br><span class="line"></span><br><span class="line">            <span class="type">ShortMessage</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortMessage</span>();</span><br><span class="line">            b.setMessage(<span class="number">128</span>, <span class="number">1</span>, note, <span class="number">100</span>);</span><br><span class="line">            <span class="type">MidiEvent</span> <span class="variable">noteOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MidiEvent</span>(b, <span class="number">16</span>);</span><br><span class="line">            track.add(noteOff);</span><br><span class="line">            player.setSequence(seq);</span><br><span class="line">            player.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图形用户接口"><a href="#图形用户接口" class="headerlink" title="图形用户接口"></a>图形用户接口</h2><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p>一切都要从window开始说起.</p>
<p><code>JFrame</code>是一个代表屏幕上window的对象. 我们可以把<code>button</code>、<code>checkbox</code>和<code>text</code>字段等接口放在window上面. 标准的<code>menu</code>也可以放在上面, 并且能够放置最小化、最大化以及关闭等图标.</p>
<p>在我们创建出<code>JFrame</code>后, 我们就可以把组件(widget)放在上面了. 有很多的Swing组件可供选择, 绝大多数都简单易懂.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建frame</span></span><br><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">// 创建widget(组件)</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"><span class="comment">// 将widget添加到frame上</span></span><br><span class="line">frame.getContentPane().add(button);</span><br><span class="line"><span class="comment">// 显示出来</span></span><br><span class="line">frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">frame.setVisible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="年轻人的第一个GUI"><a href="#年轻人的第一个GUI" class="headerlink" title="年轻人的第一个GUI"></a>年轻人的第一个GUI</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建frame和button</span></span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在window关闭后自动关闭程序</span></span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将button加到frame的pane上</span></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定frame的大小</span></span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示frame</span></span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户接口事件"><a href="#用户接口事件" class="headerlink" title="用户接口事件"></a>用户接口事件</h3><p>如何让按钮在用户按下时执行特定的工作? 我们需要两个东西:</p>
<ol>
<li>被按下时要执行的方法</li>
<li>检测按钮被按下的方法</li>
</ol>
<h4 id="取得用户的事件"><a href="#取得用户的事件" class="headerlink" title="取得用户的事件"></a>取得用户的事件</h4><p>假设我们想要把按钮上的文字在用户按下按钮时从”click me”变成”I’ve been clicked”. 我们需要先编写改变按钮文字的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeIt</span><span class="params">()</span> &#123;</span><br><span class="line">    button.setText(<span class="string">&quot;I&#x27;ve been clicked&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是, 在我们写好了这个方法之后, 我们又应该在什么时候执行这个方法呢? 我们怎么知道按钮被按下去了呢?</p>
<p>在Java中, 取得与处理用户操作事件的过程称为even-handling. 如果用户按下了按钮, 就会产生事件. 这是一个关于用户想要采用启动按钮功能的事件.</p>
<h4 id="事件的监听"><a href="#事件的监听" class="headerlink" title="事件的监听"></a>事件的监听</h4><p>如果想要知道按钮的事件, 就会监听事件的接口. 监听接口是介于监听(我们)与事件源(按钮)之间的桥梁.</p>
<p>Swing的GUI组件是事件的来源. 以Java的术语来说, 事件来源是个可以将用户操作(点击鼠标、按键以及关闭窗口等)转换成事件的对象. 这些事件源会在用户做出相关动作时(按下按钮)产生事件对象. 程序在大多数情况下是事件的接受方而不是创建方. 也就是说, 我们会花比较多的事件当监听者而不是事件来源.</p>
<p>每个事件类型都有相对应的监听者接口. 如果没有, 就要自己写一个.</p>
<p>某些接口不只有一个方法, 因为事件本身就有不同的形态.</p>
<h4 id="监听和事件源如何沟通"><a href="#监听和事件源如何沟通" class="headerlink" title="监听和事件源如何沟通"></a>监听和事件源如何沟通</h4><h5 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h5><p>如果类想要知道按钮的<code>ActionEvent</code>, 我们就需要实现<code>ActionListener</code>这个接口. 按钮需要知道我们关注的部分, 因此要通过调用<code>addActionListener(this)</code>并传入<code>ActionListener</code>的引用(此例中就是我们自己的这个程序, 所有传了一个<code>this</code>进去)来向按钮注册. 按钮会在该事件发生时调用该接口上的方法. 而作为一个<code>ActionListener</code>, 编译器会确保你实现此接口的<code>actionPerformed()</code>.</p>
<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><p>按钮是<code>ActionEvent</code>的来源, 因此它必须要知道有哪些对象是需要事件通知的. 此按钮有个<code>addActionListener</code>方法可以提供对事件有兴趣的对象(<code>listener</code>)一种表达此兴趣的方法.</p>
<p>当按钮的<code>addActionListener()</code>方法被调用时(因为某个<code>listener</code>的调用), 它的参数会被按钮存到清单中. 当用户按下按钮时, 按钮会通过调用清单上每个监听的<code>actionPerformed()</code>来启动事件.</p>
<h4 id="取得按钮的ActionEvent"><a href="#取得按钮的ActionEvent" class="headerlink" title="取得按钮的ActionEvent"></a>取得按钮的<code>ActionEvent</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">    JButton button;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleGUI</span> <span class="variable">gui</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGUI</span>();</span><br><span class="line">        gui.go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">        button = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        button.addActionListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        frame.getContentPane().add(button);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span> &#123;</span><br><span class="line">        button.setText(<span class="string">&quot;I&#x27;ve been clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回到图形上"><a href="#回到图形上" class="headerlink" title="回到图形上"></a>回到图形上</h3><h4 id="在GUI上面加东西的三种方法"><a href="#在GUI上面加东西的三种方法" class="headerlink" title="在GUI上面加东西的三种方法"></a>在GUI上面加东西的三种方法</h4><ol>
<li>在<code>frame</code>上放置<code>widget</code></li>
<li>在<code>widget</code>上绘制2D图形</li>
<li>在<code>widget</code>上绘制JPEG图</li>
</ol>
<h3 id="年轻人的第一个绘图组件"><a href="#年轻人的第一个绘图组件" class="headerlink" title="年轻人的第一个绘图组件"></a>年轻人的第一个绘图组件</h3><p>如果我们要在屏幕放上自己的图形, 最好的方式是自己创建出有绘图功能的<code>widget</code>. 这一需求可以通过创建<code>JPanel</code>的子类并覆盖掉<code>paintComponent()</code>这个方法.</p>
<p>所有绘图程序代码都在<code>paintComponent()</code>里面. 当你的<code>panel</code>所处的<code>frame</code>显示的时候, <code>paintComponent()</code>就会被调用. 如果用户缩小window或选择最小化, Java虚拟机也会知道调用它来重新绘制.</p>
<p>需要强调的是, 我们自己是不会调用这个方法的. 它的参数是个与实际屏幕有关的<code>Graphics</code>对象. 这个对象无法被取得, 它必须由系统来交给我们. 但是, 我们还是可以调用<code>reapint()</code>来要求系统重新绘制显示装置, 然后才会产生<code>paintComponent()</code>的调用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123; <span class="comment">// 创建JPanel子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;    <span class="comment">// 系统调用Graphics类</span></span><br><span class="line">        g.setColor(Color.orange);</span><br><span class="line">        g.fillRect(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在paintComponent-中可以做的事情"><a href="#在paintComponent-中可以做的事情" class="headerlink" title="在paintComponent()中可以做的事情"></a>在<code>paintComponent()</code>中可以做的事情</h4><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><h2 id="序列化和文件的输入-x2F-输出"><a href="#序列化和文件的输入-x2F-输出" class="headerlink" title="序列化和文件的输入&#x2F;输出"></a>序列化和文件的输入&#x2F;输出</h2><p>储存状态的选择有很多种. 我们暂且只讨论两种:</p>
<ol>
<li>序列化(serialization): 在数据只被自己写的Java程序使用时使用</li>
<li>纯文本文件: 在数据需要被其他程序引用时使用</li>
</ol>
<p>此外还有种种进行输入&#x2F;输出的方法, 但它们的基本原理都是类似的: 把数据写到某处——这个某处可以是磁盘上的文件, 也可以是来自网络上的串流. 读取数据的方向则刚好相反.</p>
<h3 id="储存状态"><a href="#储存状态" class="headerlink" title="储存状态"></a>储存状态</h3><p>假设有个程序, 是个幻想冒险游戏. 在游戏运行的过程中, 游戏的任务会累计经验值、宝物和体力等. 我们需要一种方法来保存人物的状态, 并在重新开启时能够将状态回复到上次存储时的原状. 有两种方法可供选择:</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>创建一个文件, 让序列化的三种对象写到此文件中.这个文件在以文本文件形式阅读时是无意义的.</p>
<p>序列化的文件难以阅读, 但它比纯文本文件更容易程序恢复原有的状态, 且更为安全, 因为一般人根本不会知道要如何修改数据.</p>
<h4 id="写入纯文本文件"><a href="#写入纯文本文件" class="headerlink" title="写入纯文本文件"></a>写入纯文本文件</h4><p>创建文件, 写入三行文字, 每个人物一行, 以逗号来分开属性.</p>
<h3 id="储存对象"><a href="#储存对象" class="headerlink" title="储存对象"></a>储存对象</h3><h4 id="将序列化对象写入文件"><a href="#将序列化对象写入文件" class="headerlink" title="将序列化对象写入文件"></a>将序列化对象写入文件</h4><p>下面是将对象序列化(存储)的方法步骤.</p>
<p>首先, 创建出<code>FileOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;MyGame.ser&quot;</span>);   <span class="comment">// 如果文件不存在, 它会自动被创建出来</span></span><br></pre></td></tr></table></figure>

<p>其次, 创建<code>ObjectOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileStream); <span class="comment">// 允许我们写入对象, 但无法直接连接文件, 所以需要参数的指引</span></span><br></pre></td></tr></table></figure>

<p>然后, 写入对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将变量所引用的对象序列化并写入MyGame.ser这个文件</span></span><br><span class="line">os.writeObject(characterOne);</span><br><span class="line">os.writeObject(characterTwo);</span><br><span class="line">os.writeObject(characterThree);</span><br></pre></td></tr></table></figure>

<p>最后, 关闭<code>ObjectOutputStream</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.close();</span><br></pre></td></tr></table></figure>

<h3 id="数据-在串流中移动"><a href="#数据-在串流中移动" class="headerlink" title="数据, 在串流中移动"></a>数据, 在串流中移动</h3><p>Java的输入&#x2F;输出API带有连接类型的串流, 它代表来源于目的地之间的连接, 连接串流将串流于其他串流连接起来.</p>
<p>一般来说, 串流要两两连接才能做出有意义的事情——其中一个表示连接, 另一个则是要被调用方法的. 这要归功于良好的面向对象设计——每个类只需要做好一件事就好了.</p>
<h2 id="网络与线程"><a href="#网络与线程" class="headerlink" title="网络与线程"></a>网络与线程</h2><h3 id="聊天程序概述"><a href="#聊天程序概述" class="headerlink" title="聊天程序概述"></a>聊天程序概述</h3><ol>
<li>客户端必须要认识服务器</li>
<li>服务器必须要认识所有的客户端</li>
</ol>
<p>工作方式:</p>
<ol>
<li>客户端连接到服务器</li>
<li>服务器建立连接并把客户端加到来宾清单中</li>
<li>另外一个用户连接上来</li>
<li>用户A送出信息到聊天服务器上</li>
<li>服务器将信息送给所有的来宾</li>
</ol>
<h3 id="网络Socket连接"><a href="#网络Socket连接" class="headerlink" title="网络Socket连接"></a>网络<code>Socket</code>连接</h3><p>要让客户端能够工作, 有三件事必须先学:</p>
<ol>
<li>如何建立客户端与服务器之间的初始链接</li>
<li>如何传送信息到服务器</li>
<li>如何接受来自服务器的信息</li>
</ol>
<p>这里有很多的底层工作问题, 但是Java API的网络功能包(java.net)还是提供了解决问题的方案. 但还是推荐深入研究一下TCP&#x2F;IP协议, 否则出错了也不知道怎么错的.</p>
<p>此外, 有个潜藏在简单版聊天客户程序中的问题是我们从未遇见过的: 同时做两件事情. 我们在后面会详细论述.</p>
<h4 id="建立Socket连接"><a href="#建立Socket连接" class="headerlink" title="建立Socket连接"></a>建立<code>Socket</code>连接</h4><p>要连接到其他的机器上, 我们需要<code>Socket</code>连接. <code>Socket</code>是个代表两台机器之间网络连接的对象(<code>java.net.Socket</code>).</p>
<p>要创建<code>Socket</code>连接, 我们需要知道两样关于服务器的信息: 它在哪里以及用哪个端口来收发数据, 即<strong>IP地址</strong>与<strong>端口号</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;196.164.1.103&quot;</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p><code>Socket</code>连接的建立代表两台机器之间存有对方的信息, 包括网络地址和TCP的端口号.</p>
<h4 id="读取socket"><a href="#读取socket" class="headerlink" title="读取socket"></a>读取<code>socket</code></h4><p>我们使用串流来实现<code>Socket</code>沟通, 与上一章所用的串流相同. Java的好处就在于大部分的输入&#x2F;输出并不在乎链接串流的上游实际是什么. 因此, 我们可以使用<code>BufferedReader</code>, 不管串流来自文件还是<code>Socket</code>.</p>
<h5 id="建立对服务器的Socket连接"><a href="#建立对服务器的Socket连接" class="headerlink" title="建立对服务器的Socket连接"></a>建立对服务器的<code>Socket</code>连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="建立连接到Socket上低层输入串流的InputStreamReader"><a href="#建立连接到Socket上低层输入串流的InputStreamReader" class="headerlink" title="建立连接到Socket上低层输入串流的InputStreamReader"></a>建立连接到<code>Socket</code>上低层输入串流的<code>InputStreamReader</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(chatSocket.getInputStream());</span><br></pre></td></tr></table></figure>

<h4 id="建立BufferedReader来读取"><a href="#建立BufferedReader来读取" class="headerlink" title="建立BufferedReader来读取"></a>建立<code>BufferedReader</code>来读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(stream);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> reader.readLine();</span><br></pre></td></tr></table></figure>

<h5 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><code>PrintWriter</code></h5><p>我们除了<code>BufferedReader</code>外, 还有一个选择, 即使用<code>PrintWriter</code>. 由于我们每次写入都只是写入一个字符串, 所有使用<code>PrintWriter</code>是最标准的做法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">chatSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(chatSocket.getOutputStream());</span><br><span class="line"></span><br><span class="line">writer.println(<span class="string">&quot;message to send&quot;</span>);</span><br><span class="line">writer.print(<span class="string">&quot;another message&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="DailyAdviceClient客户端程序"><a href="#DailyAdviceClient客户端程序" class="headerlink" title="DailyAdviceClient客户端程序"></a><code>DailyAdviceClient</code>客户端程序</h3><p>这个程序会建立<code>Socket</code>, 通过其他串流来制作<code>BufferedReader</code>, 并从服务器应用程序(用56747端口服务的任何程序)上读取一行信息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DailyAdviceClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">56747</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">InputStreamReader</span> <span class="variable">streamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream());</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(streamReader);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">advice</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;Today you should: &quot;</span> + advice);</span><br><span class="line"></span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DailyAdviceClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DailyAdviceClient</span>();</span><br><span class="line">        client.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 如果我们直接运行这个程序的话, 它一定会报错. 不是端口的问题(除非我们的56747端口真的被占用了), 是服务器代码没写的问题. 我们需要先运行服务器的代码, 然后再运行这个代码.</p>
<h3 id="编写简单的服务器程序"><a href="#编写简单的服务器程序" class="headerlink" title="编写简单的服务器程序"></a>编写简单的服务器程序</h3><p>编写服务器应用程序要用到哪些东西呢? 一对<code>Socket</code>即可. 它们是一个会等待用户请求(当用户创建<code>Socket</code>时)的<code>ServerSocket</code>以及与用户通信用的<code>Socket</code>.</p>
<h4 id="服务器应用程序对特定端口创建出ServerSocket"><a href="#服务器应用程序对特定端口创建出ServerSocket" class="headerlink" title="服务器应用程序对特定端口创建出ServerSocket"></a>服务器应用程序对特定端口创建出<code>ServerSocket</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">56747</span>);</span><br></pre></td></tr></table></figure>

<h4 id="客户端对服务器应用程序建立Socket连接"><a href="#客户端对服务器应用程序建立Socket连接" class="headerlink" title="客户端对服务器应用程序建立Socket连接"></a>客户端对服务器应用程序建立<code>Socket</code>连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;196.165.1.103&quot;</span>, <span class="number">56747</span>);</span><br></pre></td></tr></table></figure>

<h4 id="服务器创建出与客户端通信的新Socket"><a href="#服务器创建出与客户端通信的新Socket" class="headerlink" title="服务器创建出与客户端通信的新Socket"></a>服务器创建出与客户端通信的新<code>Socket</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> serverSock <span class="title function_">accept</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><code>accept()</code>方法会在等待用户的<code>Socket</code>连接时闲置着. 当用户连上来时, 此方法会返回一个<code>Socket</code>(在不同的端口上)以便与客户端通信. <code>Socket</code>与<code>ServerSocket</code>的端口不相同, 因此<code>ServerSocket</code>可以空出来等待其他的用户.</p>
<h3 id="DailyAdviceClient客户端程序-2-0"><a href="#DailyAdviceClient客户端程序-2-0" class="headerlink" title="DailyAdviceClient客户端程序 2.0"></a><code>DailyAdviceClient</code>客户端程序 2.0</h3><p>这个程序吹创建<code>ServerSocket</code>并等待客户端的请求. 当它受到客户端请求时, 服务器会建立于客户端的<code>Socket</code>连接. 服务器接着会建立<code>PrintWriter</code>来送出信息给客户端.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DailyAdviceServer</span> &#123;</span><br><span class="line">    <span class="comment">// 锦囊妙计</span></span><br><span class="line">    String[] adviceList = &#123;<span class="string">&quot;Advice 1&quot;</span>, <span class="string">&quot;Advice 2&quot;</span>, <span class="string">&quot;Advice 3&quot;</span>, <span class="string">&quot;Advice 4&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ServerSocket会持续监听客户端在56747端口上的要求</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">56747</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器开始五西安等待客户端的请求</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 该方法会停下来等待要求达到之后才会继续</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用Socket连接发送消息, 并在送出后关闭连接</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sock.getOutputStream());</span><br><span class="line">                <span class="type">String</span> <span class="variable">advice</span> <span class="operator">=</span> getAdvice();</span><br><span class="line">                writer.println(advice);</span><br><span class="line">                writer.close();</span><br><span class="line">                System.out.println(advice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * adviceList.length);</span><br><span class="line">        <span class="keyword">return</span> adviceList[random];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DailyAdviceServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DailyAdviceServer</span>();</span><br><span class="line">        server.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写聊天客户端程序"><a href="#编写聊天客户端程序" class="headerlink" title="编写聊天客户端程序"></a>编写聊天客户端程序</h3><h4 id="第一版-只能发送的版本"><a href="#第一版-只能发送的版本" class="headerlink" title="第一版: 只能发送的版本"></a>第一版: 只能发送的版本</h4><p>依旧没写服务器代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatClientA</span> &#123;</span><br><span class="line">    JTextField outgoing;</span><br><span class="line">    PrintWriter writer;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Ludicrously Simple Chat Client&quot;</span>);</span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">mainPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        outgoing = <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">sendButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Send&quot;</span>);</span><br><span class="line">        sendButton.addActionListener(<span class="keyword">new</span> <span class="title class_">SendButtonListener</span>());</span><br><span class="line">        mainPanel.add(outgoing);</span><br><span class="line">        mainPanel.add(sendButton);</span><br><span class="line">        frame.getContentPane().add(BorderLayout.CENTER, mainPanel);</span><br><span class="line">        setUpNetworking();</span><br><span class="line">        frame.setSize(<span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setUpNetworking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sock = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">56747</span>);</span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(sock.getOutputStream());</span><br><span class="line">            System.out.println(<span class="string">&quot;networking established&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendButtonListener</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent ev)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.println(outgoing.getText());</span><br><span class="line">                writer.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            outgoing.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            outgoing.requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleChatClientA</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二版-可发送和接收版"><a href="#第二版-可发送和接收版" class="headerlink" title="第二版: 可发送和接收版"></a>第二版: 可发送和接收版</h4><p>该版本的程序需要解决一个问题: 如何从服务器中取得信息?</p>
<p>这是个比较容易的问题: 当我们设定网络的同时也把输入串流建立好, 然后使用<code>readLine()</code>读取信息. 问题在于: 何时从服务器取得信息? 最好的方法当然是在信息被送到服务器上的时候就把它读回来. 但是, 这样的程序应该怎么写? 需要有一个循环来等待服务器的消息, 但是这个程序又该放在哪里?</p>
<h3 id="线程与Thread"><a href="#线程与Thread" class="headerlink" title="线程与Thread"></a>线程与<code>Thread</code></h3><p>Java有多个线程, 但是<strong>只有一个<code>Thread</code>类</strong>. 它只是<code>java.lang</code>这个包中的一个类, <code>Thread</code>对象才代表线程, 当我们需要启动新的线程时需要建立一个新的<code>Thread</code>实例.</p>
<h4 id="一个以上的执行空间意味着什么"><a href="#一个以上的执行空间意味着什么" class="headerlink" title="一个以上的执行空间意味着什么?"></a>一个以上的执行空间意味着什么?</h4><p>当有一个以上的执行空间时, 看起来会像是有好几件事情同时发生. 但是实际上, 只有真正的多处理器系统才能同时执行好几件事, 但使用Java的线程可以让它们看起来好像在同时执行. 也就是说, 执行动作可以在执行空间间非常快速地来回交换, 因此产生了它们在同时执行的错觉.</p>
<p>线程要记录的一项事物就是目前线程执行空间做到哪里了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java虚拟机调用main()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// main()启动新的线程. 新的线程启动期间, main的线程会暂停执行</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadJob</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java虚拟机会在线程与原来的主线程间切换直到两者都完成为止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何启动新的线程"><a href="#如何启动新的线程" class="headerlink" title="如何启动新的线程"></a>如何启动新的线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立Runnable对象(线程的任务)</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立Thread对象并赋值Runnalbe(对象)</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Thread</span></span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<h4 id="Thread的任务"><a href="#Thread的任务" class="headerlink" title="Thread的任务"></a><code>Thread</code>的任务</h4><p>每个<code>Thread</code>需要一个任务来执行, 一个可以放在执行空间的任务.</p>
<p>任务是线程在启动时去执行的工作, 是新线程空间上的第一个方法. 它一定要长成这个样子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 会被新线程执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程怎么会直到要先放上哪个方法? 因为<code>Runnable</code>定义了一个协约. 因为<code>Runnable</code>定义了一个协约. 它自己是一个接口, 线程的任务可以被定义在任何实现<code>Runnable</code>的类上. 线程只在乎传入给<code>Thread</code>的构造函数的参数是否为实现<code>Runnable</code>的类.</p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        doMore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;top o&#x27; the stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;back in main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程有三种状态, 即<strong>新建</strong>、<strong>可执行</strong>和<strong>执行中</strong>. 当线程进入可执行状态, 它就会在可执行与执行中两种状态中来回转变.</p>
<h4 id="可执行-x2F-执行中循环"><a href="#可执行-x2F-执行中循环" class="headerlink" title="可执行&#x2F;执行中循环"></a>可执行&#x2F;执行中循环</h4><p>普通线程会在可执行与执行中两个状态中来回交替. 因为Java虚拟机的线程调度会把线程挑出来运行又把它踢回去让其他的线程有执行机会.</p>
<h4 id="线程有可能会暂时被挡住"><a href="#线程有可能会暂时被挡住" class="headerlink" title="线程有可能会暂时被挡住"></a>线程有可能会暂时被挡住</h4><p>调度器(scheduler)会因为某些原因暂停执行一个线程.</p>
<h3 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a>线程调度器</h3><p>线程调度器会决定哪个线程从等待状况中被挑出来运行, 以及何时把哪个线程送回等待被执行的状态.</p>
<p>但是, 不同虚拟机上的调度器有着不同的工作逻辑, 故我们的程序不能依靠调度的特定行为来保持执行的正确性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        doMore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;top of the stack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTestDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">threadJob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(threadJob);</span><br><span class="line"></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;back in main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="让线程小睡一下"><a href="#让线程小睡一下" class="headerlink" title="让线程小睡一下"></a>让线程小睡一下</h3><p>确保线程能够有机会执行的最好方式是让它们周期性地去睡一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>但是在这个方法有可能会抛出<code>InterruptedException</code>异常, 所有对它的调用都必须包含在<code>try/catch</code>块中. 因此, 真正的程序代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(实际上, 我们通常不必刻意使用<code>sleep()</code>来保证其他的线程会被执行. 这是一个很复杂的问题, 详见一些专门论述Java多线程的书籍.)</p>
<h3 id="建立与启动两个线程"><a href="#建立与启动两个线程" class="headerlink" title="建立与启动两个线程"></a>建立与启动两个线程</h3><p>线程可以有名字. 下面的例子中有两个线程. 它们都执行相同的工作: 在循环中列出线程的名字.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunThreads</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunThreads</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunThreads</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">alpha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">beta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runner);</span><br><span class="line">        alpha.setName(<span class="string">&quot;Alpha Thread&quot;</span>);</span><br><span class="line">        beta.setName(<span class="string">&quot;Beta Thread&quot;</span>);</span><br><span class="line">        alpha.start();</span><br><span class="line">        beta.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; is running .&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程的并发性问题"><a href="#多线程的并发性问题" class="headerlink" title="多线程的并发性问题"></a>多线程的并发性问题</h3><p>并发性会引发竞争状态, 进而引发数据的损毁. 这一切都来自于一种完全可能的状况, 即两个或以上的线程存取单一对象的数据. 也就是说, 两个不同执行空间上的方法都在堆上对同一个对象执行<code>getter</code>或<code>setter</code>.</p>
<p>为了解决这个问题, 我们需要设计一把锁, 使得每个方法在同时只能被一个线程调用. 这把锁就是<code>synchronized</code>.</p>
<p><code>synchronized</code>关键词代表线程需要一把钥匙来存取被同步化(synchronized)过的线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">makeWithdrawal</span><span class="params">(<span class="type">int</span> amount)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步化的死锁问题"><a href="#同步化的死锁问题" class="headerlink" title="同步化的死锁问题"></a>同步化的死锁问题</h4><p>如同步化的定义所述, 它会确保在需要的方法执行完毕前不执行任何其他操作. 问题来了: 如果那个”需要的方法”的执行需要某个被同步化确保不执行的内容怎么办? 这就完蛋了. 程序会永远地等下去. 这就是所谓的死锁.</p>
<p>Java没有处理死锁的机制, 想要尽可能地避免死锁只能依赖良好的多线程程序设计. 推荐阅读O’Relly出版的<em>Java Thread</em>, 上面对包括死锁在内的许多有关Java多线程的知识进行了清晰的论述.</p>
<h2 id="集合与泛型"><a href="#集合与泛型" class="headerlink" title="集合与泛型"></a>集合与泛型</h2></div><div class="article-licensing box"><div class="licensing-title"><p>Java学习笔记</p><p><a href="http://example.com/2022/06/12/java/">http://example.com/2022/06/12/java/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Arnold Miao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-06-12</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-06-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java核心技术卷1</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/06/09/CSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-item">CSS学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Arnold Miao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Arnold Miao</p><p class="is-size-6 is-block">Learner</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China, Asia</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-11T00:53:31.000Z">2022-07-11</time></p><p class="title"><a href="/2022/07/11/%E3%80%8A%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E7%9A%84%E5%B4%87%E9%AB%98%E5%AE%A2%E4%BD%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《意识形态的崇高客体》读书笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-09T05:23:28.000Z">2022-07-09</time></p><p class="title"><a href="/2022/07/09/MySQL%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">MySQL自学笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-09T02:18:36.000Z">2022-07-09</time></p><p class="title"><a href="/2022/07/09/%E5%9B%BE%E8%A7%A3HTTP/">图解HTTP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-28T02:32:59.000Z">2022-06-28</time></p><p class="title"><a href="/2022/06/28/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">算法入门</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-06-19T06:29:11.000Z">2022-06-19</time></p><p class="title"><a href="/2022/06/19/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B71/">Java核心技术卷1</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="小苗的个人博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 Arnold Miao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>